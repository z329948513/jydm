.版本 2

.程序集 集_编码进制转换
.程序集变量 集_AVX2, 逻辑型
.程序集变量 集_SSE2, 逻辑型

.子程序 BASE64编解码_ASM_初始化, , 公开
    ' 有BUG可以联系QQ：86427575
    ' 1.1版更新
    ' 1)  整合 AVX2指令集版本进去，内部会判断CPU是否支持，CPU支持的话性能会比80386版再提升90%左右，前提是需要编码的数据足够长。
    
    ' 1.2更新
    ' 1)  修复 BASE64编码_ASM()  计算 申请长度 的mulx指令，在老CPU上出现异常问题（感谢 sometimes 的反馈）。
    
    集_AVX2 ＝ CPU_IsAVX2_ASM ()
    集_SSE2 ＝ CPU_IsSSE2_ASM ()
    

.子程序 BASE64编码_ASM, 文本型, 公开, 调用前务必调用 BASE64编解码_ASM_初始化   自动选择版本：AVX2、80386
    .参数 参_字节集, 字节集
    .局部变量 局_长度, 整数型, , , 0x4
    .局部变量 局_AVX2, 逻辑型, , , 0x8
    .局部变量 局_申请长度, 整数型, , , 0xC

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 7, 139, 64, 4, 62, 137, 69, 252 }) ' 局_长度 ＝ 取字节集长度 (参_字节集)
    .如果真 (局_长度 ＞ 0)
        局_AVX2 ＝ 集_AVX2
        置入代码 ({ 139, 77, 252, 184, 171, 170, 170, 170, 141, 73, 2, 247, 225, 209, 234, 141, 4, 149, 1, 0, 0, 0, 137, 69, 244 }) ' 局_申请长度 = (局_长度 + 2) / 3 * 4 + 1
        内存_申请内存 (局_申请长度)
        ' 由VS2017+ICC编译后反汇编修整，字节集可转换为16进制，然后在x64dbg内找个地，CTRL+SHIFT+V 粘贴进去即可查看汇编代码。
        置入代码 ({ 137, 69, 244, 139, 85, 252, 139, 77, 8, 139, 9, 131, 193, 8, 255, 117, 248, 81, 80, 232, 7, 0, 0, 0, 139, 69, 244, 201, 194, 4, 0, 232, 215, 1, 0, 0, 86, 87, 83, 131, 236, 20, 139, 242, 139, 68, 36, 36, 139, 217, 139, 124, 36, 40, 137, 68, 36, 4, 128, 124, 36, 44, 0, 116, 9, 131, 254, 28, 15, 131, 28, 1, 0, 0, 131, 254, 2, 15, 134, 136, 0, 0, 0, 139, 206, 51, 210, 131, 193, 254, 15, 132, 125, 0, 0, 0, 137, 52, 36, 137, 76, 36, 8, 137, 124, 36, 12, 139, 116, 36, 12, 15, 182, 12, 50, 15, 182, 124, 50, 1, 15, 182, 116, 50, 2, 131, 194, 3, 137, 84, 36, 16, 15, 182, 20, 25, 131, 225, 3, 136, 16, 139, 215, 193, 225, 4, 131, 231, 15, 193, 234, 4, 11, 202, 193, 231, 2, 15, 182, 140, 25, 0, 1, 0, 0, 136, 72, 1, 139, 206, 193, 233, 6, 11, 249, 15, 182, 148, 31, 0, 1, 0, 0, 136, 80, 2, 15, 182, 140, 30, 0, 1, 0, 0, 139, 84, 36, 16, 136, 72, 3, 131, 192, 4, 59, 84, 36, 8, 114, 153, 139, 52, 36, 139, 124, 36, 12, 235, 2, 51, 210, 43, 242, 116, 104, 15, 182, 12, 58, 131, 254, 1, 117, 39, 15, 182, 20, 25, 131, 225, 3, 193, 225, 4, 136, 16, 15, 182, 140, 25, 0, 1, 0, 0, 187, 61, 0, 0, 0, 136, 72, 1, 136, 88, 2, 136, 88, 3, 131, 192, 4, 235, 56, 15, 182, 116, 58, 1, 139, 254, 15, 182, 20, 25, 131, 225, 3, 193, 225, 4, 131, 230, 15, 193, 239, 4, 11, 207, 136, 16, 15, 182, 140, 25, 0, 1, 0, 0, 136, 72, 1, 15, 182, 156, 179, 0, 1, 0, 0, 136, 88, 2, 198, 64, 3, 61, 131, 192, 4, 139, 84, 36, 4, 198, 0, 0, 43, 194, 43, 84, 36, 36, 3, 208, 133, 192, 15, 69, 194, 131, 196, 20, 91, 95, 94, 194, 12, 0, 197, 254, 111, 131, 0, 2, 0, 0, 197, 254, 111, 179, 32, 2, 0, 0, 197, 254, 111, 171, 64, 2, 0, 0, 197, 254, 111, 163, 96, 2, 0, 0, 197, 254, 111, 147, 128, 2, 0, 0, 197, 254, 111, 155, 160, 2, 0, 0, 196, 226, 125, 140, 71, 252, 235, 5, 197, 254, 111, 71, 252, 196, 226, 125, 0, 131, 192, 2, 0, 0, 131, 198, 232, 197, 253, 219, 187, 224, 2, 0, 0, 131, 199, 24, 197, 197, 228, 206, 197, 253, 219, 253, 197, 197, 213, 131, 0, 3, 0, 0, 197, 245, 235, 192, 197, 253, 216, 202, 197, 253, 100, 251, 197, 245, 248, 207, 196, 226, 93, 0, 201, 197, 253, 252, 193, 197, 254, 127, 0, 131, 192, 32, 131, 254, 32, 115, 175, 137, 68, 36, 4, 197, 248, 119, 233, 79, 254, 255, 255, 232, 0, 0, 0, 0, 89, 131, 193, 5, 195 })
        ' 码表（空间换时间）
        ' *** 缩略程序块 ***
        置入代码 ({ 65, 65, 65, 65, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 70, 70, 71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82, 82, 82, 82, 83, 83, 83, 83, 84, 84, 84, 84, 85, 85, 85, 85, 86, 86, 86, 86, 87, 87, 87, 87, 88, 88, 88, 88, 89, 89, 89, 89, 90, 90, 90, 90, 97, 97, 97, 97, 98, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 101, 101, 101, 101, 102, 102, 102, 102, 103, 103, 103, 103, 104, 104, 104, 104, 105, 105, 105, 105, 106, 106, 106, 106, 107, 107, 107, 107, 108, 108, 108, 108, 109, 109, 109, 109, 110, 110, 110, 110, 111, 111, 111, 111, 112, 112, 112, 112, 113, 113, 113, 113, 114, 114, 114, 114, 115, 115, 115, 115, 116, 116, 116, 116, 117, 117, 117, 117, 118, 118, 118, 118, 119, 119, 119, 119, 120, 120, 120, 120, 121, 121, 121, 121, 122, 122, 122, 122, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 43, 43, 43, 43, 47, 47, 47, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 })
        ' AVX2码表
        ' *** 缩略程序块 ***
        置入代码 ({ 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 65, 71, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 237, 240, 0, 0, 65, 71, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 237, 240, 0, 0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 5, 4, 6, 5, 8, 7, 9, 8, 11, 10, 12, 11, 14, 13, 15, 14, 1, 0, 2, 1, 4, 3, 5, 4, 7, 6, 8, 7, 10, 9, 11, 10, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1 })
    .如果真结束
    返回 (“”)

.子程序 BASE64解码_ASM, 字节集, 公开, 调用前务必调用 BASE64编解码_ASM_初始化   自动选择版本：AVX2、80386
    .参数 参_文本, 文本型
    .局部变量 局_长度, 整数型, , , 0x4
    .局部变量 局_AVX2, 逻辑型, , , 0x8
    .局部变量 局_申请长度, 整数型, , , 0xC

    局_长度 ＝ 取文本长度_ASM (参_文本)
    .如果真 (局_长度 ＞ 0)
        局_AVX2 ＝ 集_AVX2
        置入代码 ({ 139, 77, 252, 193, 233, 2, 141, 68, 73, 10, 62, 137, 69, 244 }) ' 局_申请长度 = 局_长度 / 4 * 3 + 10
        内存_申请内存 (局_申请长度)
        ' 由VS2017+ICC编译后反汇编修整，字节集可转换为16进制，然后在x64dbg内找个地，CTRL+SHIFT+V 粘贴进去即可查看汇编代码。
        置入代码 ({ 137, 69, 244, 199, 0, 1, 0, 0, 0, 131, 192, 8, 139, 77, 252, 139, 85, 8, 139, 18, 255, 117, 248, 82, 80, 232, 12, 0, 0, 0, 139, 77, 244, 137, 65, 4, 139, 193, 201, 194, 4, 0, 232, 70, 2, 0, 0, 86, 87, 83, 131, 236, 12, 139, 242, 139, 68, 36, 28, 139, 249, 139, 92, 36, 32, 128, 124, 36, 36, 0, 15, 132, 152, 0, 0, 0, 131, 255, 45, 15, 130, 143, 0, 0, 0, 197, 254, 111, 170, 0, 16, 0, 0, 197, 254, 111, 162, 32, 16, 0, 0, 197, 254, 111, 154, 64, 16, 0, 0, 197, 254, 111, 146, 96, 16, 0, 0, 197, 254, 111, 11, 197, 253, 114, 209, 4, 197, 245, 219, 245, 197, 253, 219, 197, 196, 226, 93, 0, 254, 196, 226, 101, 0, 240, 196, 226, 125, 23, 254, 117, 74, 197, 245, 116, 245, 131, 199, 224, 197, 205, 252, 192, 131, 195, 32, 197, 254, 111, 178, 128, 16, 0, 0, 196, 226, 109, 0, 248, 197, 245, 252, 207, 196, 226, 117, 4, 130, 160, 16, 0, 0, 197, 253, 245, 138, 192, 16, 0, 0, 196, 226, 117, 0, 186, 224, 16, 0, 0, 196, 226, 77, 54, 199, 197, 254, 127, 0, 131, 192, 24, 131, 255, 45, 115, 148, 197, 248, 119, 133, 255, 15, 132, 126, 1, 0, 0, 131, 255, 4, 15, 130, 117, 1, 0, 0, 247, 199, 3, 0, 0, 0, 15, 133, 105, 1, 0, 0, 128, 124, 59, 255, 61, 117, 14, 141, 87, 255, 131, 199, 254, 128, 124, 26, 255, 61, 15, 69, 250, 139, 207, 193, 233, 2, 131, 231, 3, 141, 81, 255, 15, 68, 202, 137, 76, 36, 8, 133, 201, 139, 200, 118, 98, 51, 210, 137, 124, 36, 4, 139, 250, 137, 4, 36, 15, 182, 3, 139, 20, 134, 15, 182, 67, 1, 11, 148, 134, 0, 4, 0, 0, 15, 182, 67, 2, 11, 148, 134, 0, 8, 0, 0, 15, 182, 67, 3, 11, 148, 134, 0, 12, 0, 0, 129, 250, 255, 255, 255, 1, 15, 131, 254, 0, 0, 0, 139, 194, 71, 131, 195, 4, 136, 17, 193, 232, 8, 193, 234, 16, 136, 65, 1, 136, 81, 2, 131, 193, 3, 59, 124, 36, 8, 114, 176, 139, 124, 36, 4, 139, 4, 36, 133, 255, 116, 122, 131, 255, 1, 117, 13, 15, 182, 19, 139, 28, 150, 137, 28, 36, 136, 25, 235, 76, 131, 255, 2, 117, 24, 15, 182, 19, 15, 182, 91, 1, 139, 20, 150, 11, 148, 158, 0, 4, 0, 0, 137, 20, 36, 136, 17, 235, 47, 137, 124, 36, 4, 15, 182, 59, 139, 20, 190, 15, 182, 123, 1, 15, 182, 91, 2, 11, 148, 190, 0, 4, 0, 0, 11, 148, 158, 0, 8, 0, 0, 137, 20, 36, 136, 17, 193, 234, 8, 136, 81, 1, 139, 124, 36, 4, 129, 60, 36, 255, 255, 255, 1, 115, 111, 139, 84, 36, 8, 141, 52, 127, 3, 246, 193, 238, 3, 141, 12, 82, 3, 241, 235, 73, 15, 182, 59, 139, 20, 190, 15, 182, 123, 1, 11, 148, 190, 0, 4, 0, 0, 15, 182, 123, 2, 15, 182, 91, 3, 11, 148, 190, 0, 8, 0, 0, 11, 148, 158, 0, 12, 0, 0, 129, 250, 255, 255, 255, 1, 115, 45, 139, 116, 36, 8, 139, 218, 139, 211, 136, 25, 141, 116, 118, 3, 193, 234, 8, 193, 235, 16, 136, 81, 1, 136, 89, 2, 133, 246, 116, 15, 43, 68, 36, 28, 3, 198, 131, 196, 12, 91, 95, 94, 194, 12, 0, 51, 192, 131, 196, 12, 91, 95, 94, 194, 12, 0, 232, 0, 0, 0, 0, 90, 131, 194, 5, 195 })
        ' 码表，有点大（空间换时间）
        ' *** 缩略程序块 ***
        置入代码 ({ 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 248, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 252, 0, 0, 0, 208, 0, 0, 0, 212, 0, 0, 0, 216, 0, 0, 0, 220, 0, 0, 0, 224, 0, 0, 0, 228, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 92, 0, 0, 0, 96, 0, 0, 0, 100, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 104, 0, 0, 0, 108, 0, 0, 0, 112, 0, 0, 0, 116, 0, 0, 0, 120, 0, 0, 0, 124, 0, 0, 0, 128, 0, 0, 0, 132, 0, 0, 0, 136, 0, 0, 0, 140, 0, 0, 0, 144, 0, 0, 0, 148, 0, 0, 0, 152, 0, 0, 0, 156, 0, 0, 0, 160, 0, 0, 0, 164, 0, 0, 0, 168, 0, 0, 0, 172, 0, 0, 0, 176, 0, 0, 0, 180, 0, 0, 0, 184, 0, 0, 0, 188, 0, 0, 0, 192, 0, 0, 0, 196, 0, 0, 0, 200, 0, 0, 0, 204, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 3, 224, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 3, 240, 0, 0, 3, 64, 0, 0, 3, 80, 0, 0, 3, 96, 0, 0, 3, 112, 0, 0, 3, 128, 0, 0, 3, 144, 0, 0, 3, 160, 0, 0, 3, 176, 0, 0, 3, 192, 0, 0, 3, 208, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 0, 16, 0, 0, 0, 32, 0, 0, 0, 48, 0, 0, 0, 64, 0, 0, 0, 80, 0, 0, 0, 96, 0, 0, 0, 112, 0, 0, 0, 128, 0, 0, 0, 144, 0, 0, 0, 160, 0, 0, 0, 176, 0, 0, 0, 192, 0, 0, 0, 208, 0, 0, 0, 224, 0, 0, 0, 240, 0, 0, 1, 0, 0, 0, 1, 16, 0, 0, 1, 32, 0, 0, 1, 48, 0, 0, 1, 64, 0, 0, 1, 80, 0, 0, 1, 96, 0, 0, 1, 112, 0, 0, 1, 128, 0, 0, 1, 144, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 1, 160, 0, 0, 1, 176, 0, 0, 1, 192, 0, 0, 1, 208, 0, 0, 1, 224, 0, 0, 1, 240, 0, 0, 2, 0, 0, 0, 2, 16, 0, 0, 2, 32, 0, 0, 2, 48, 0, 0, 2, 64, 0, 0, 2, 80, 0, 0, 2, 96, 0, 0, 2, 112, 0, 0, 2, 128, 0, 0, 2, 144, 0, 0, 2, 160, 0, 0, 2, 176, 0, 0, 2, 192, 0, 0, 2, 208, 0, 0, 2, 224, 0, 0, 2, 240, 0, 0, 3, 0, 0, 0, 3, 16, 0, 0, 3, 32, 0, 0, 3, 48, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 15, 128, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 15, 192, 0, 0, 13, 0, 0, 0, 13, 64, 0, 0, 13, 128, 0, 0, 13, 192, 0, 0, 14, 0, 0, 0, 14, 64, 0, 0, 14, 128, 0, 0, 14, 192, 0, 0, 15, 0, 0, 0, 15, 64, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 192, 0, 0, 1, 0, 0, 0, 1, 64, 0, 0, 1, 128, 0, 0, 1, 192, 0, 0, 2, 0, 0, 0, 2, 64, 0, 0, 2, 128, 0, 0, 2, 192, 0, 0, 3, 0, 0, 0, 3, 64, 0, 0, 3, 128, 0, 0, 3, 192, 0, 0, 4, 0, 0, 0, 4, 64, 0, 0, 4, 128, 0, 0, 4, 192, 0, 0, 5, 0, 0, 0, 5, 64, 0, 0, 5, 128, 0, 0, 5, 192, 0, 0, 6, 0, 0, 0, 6, 64, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 6, 128, 0, 0, 6, 192, 0, 0, 7, 0, 0, 0, 7, 64, 0, 0, 7, 128, 0, 0, 7, 192, 0, 0, 8, 0, 0, 0, 8, 64, 0, 0, 8, 128, 0, 0, 8, 192, 0, 0, 9, 0, 0, 0, 9, 64, 0, 0, 9, 128, 0, 0, 9, 192, 0, 0, 10, 0, 0, 0, 10, 64, 0, 0, 10, 128, 0, 0, 10, 192, 0, 0, 11, 0, 0, 0, 11, 64, 0, 0, 11, 128, 0, 0, 11, 192, 0, 0, 12, 0, 0, 0, 12, 64, 0, 0, 12, 128, 0, 0, 12, 192, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 62, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 63, 0, 0, 0, 52, 0, 0, 0, 53, 0, 0, 0, 54, 0, 0, 0, 55, 0, 0, 0, 56, 0, 0, 0, 57, 0, 0, 0, 58, 0, 0, 0, 59, 0, 0, 0, 60, 0, 0, 0, 61, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 7, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 10, 0, 0, 0, 11, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 14, 0, 0, 0, 15, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 18, 0, 0, 0, 19, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 22, 0, 0, 0, 23, 0, 0, 0, 24, 0, 0, 0, 25, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 26, 0, 0, 0, 27, 0, 0, 0, 28, 0, 0, 0, 29, 0, 0, 0, 30, 0, 0, 0, 31, 0, 0, 0, 32, 0, 0, 0, 33, 0, 0, 0, 34, 0, 0, 0, 35, 0, 0, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 0, 0, 0, 39, 0, 0, 0, 40, 0, 0, 0, 41, 0, 0, 0, 42, 0, 0, 0, 43, 0, 0, 0, 44, 0, 0, 0, 45, 0, 0, 0, 46, 0, 0, 0, 47, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 50, 0, 0, 0, 51, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1 })
        ' AVX2码表
        ' *** 缩略程序块 ***
        置入代码 ({ 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 21, 17, 17, 17, 17, 17, 17, 17, 17, 17, 19, 26, 27, 27, 27, 26, 21, 17, 17, 17, 17, 17, 17, 17, 17, 17, 19, 26, 27, 27, 27, 26, 16, 16, 1, 2, 4, 8, 4, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 1, 2, 4, 8, 4, 8, 16, 16, 16, 16, 16, 16, 16, 16, 0, 16, 19, 4, 191, 191, 185, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 19, 4, 191, 191, 185, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 2, 1, 0, 6, 5, 4, 10, 9, 8, 14, 13, 12, 255, 255, 255, 255, 2, 1, 0, 6, 5, 4, 10, 9, 8, 14, 13, 12, 255, 255, 255, 255 })
    .如果真结束
    返回 ({ })

.子程序 取文本长度_ASM, 整数型, 公开, 调用前务必调用 BASE64编解码_ASM_初始化    取文本型数据的长度，不包含结束0。自动选择版本：AVX2、SSE2、80386
    .参数 参_文本, 通用型, 参考, 文本变量或文本指针

    .判断开始 (集_AVX2)
        ' AVX2对齐版
        置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 51, 139, 232, 139, 200, 197, 253, 87, 192, 131, 225, 31, 131, 224, 224, 197, 253, 116, 8, 197, 253, 215, 209, 211, 234, 211, 226, 15, 188, 210, 117, 16, 131, 192, 32, 197, 253, 116, 8, 197, 253, 215, 209, 15, 188, 210, 116, 240, 43, 197, 1, 208, 93, 194, 4, 0 })
        ' *** 缩略程序块 ***
        ' mov eax,dword ptr ss:[ebp+0x8]
        ' mov eax,dword ptr ds:[eax]
        ' test eax,eax
        ' je end_1
        ' mov ebp,eax
        ' mov ecx,eax
        ' vxorpd ymm0,ymm0,ymm0
        ' and ecx,0x1F
        ' and eax,0xFFFFFFE0
        ' vpcmpeqb ymm1,ymm0,yword ptr ds:[eax]
        ' vpmovmskb edx,ymm1
        ' shr edx,cl
        ' shl edx,cl
        ' bsf edx,edx
        ' jne end_0
        ' loop_1:
        ' add eax,0x20
        ' vpcmpeqb ymm1,ymm0,yword ptr ds:[eax]
        ' vpmovmskb edx,ymm1
        ' bsf edx,edx
        ' je loop_1
        ' end_0:
        ' sub eax,ebp
        ' add eax,edx
        ' end_1:
        ' pop ebp
        ' ret 0x4
        
    .判断 (集_SSE2)
        ' SSE2对齐版
        置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 59, 137, 197, 137, 193, 102, 15, 239, 192, 131, 225, 15, 131, 224, 240, 102, 15, 111, 8, 102, 15, 116, 200, 102, 15, 215, 209, 211, 234, 211, 226, 15, 188, 210, 117, 20, 131, 192, 16, 102, 15, 111, 8, 102, 15, 116, 200, 102, 15, 215, 209, 15, 188, 210, 116, 236, 41, 232, 1, 208, 93, 194, 4, 0 })
        ' *** 缩略程序块 ***
        ' mov eax,dword ptr ss:[ebp+0x8]
        ' mov eax,dword ptr ds:[eax]
        ' test eax,eax
        ' je end_
        
        ' mov ebp,eax
        ' mov ecx,eax
        ' pxor xmm0,xmm0
        ' and ecx,0xF
        ' and eax,0xFFFFFFF0
        ' movdqa xmm1,xmmword ptr ds:[eax]
        ' pcmpeqb xmm1,xmm0
        ' pmovmskb edx,xmm1
        ' shr edx,cl
        ' shl edx,cl
        ' bsf edx,edx
        ' jne Label_a
        
        ' Label_b:
        ' add eax,0x10
        ' movdqa xmm1,xmmword ptr ds:[eax]
        ' pcmpeqb xmm1,xmm0
        ' pmovmskb edx,xmm1
        ' bsf edx,edx
        ' je Label_b
        
        ' Label_a:
        ' sub eax,ebp
        ' add eax,edx
        
        ' end_:
        ' pop ebp
        ' ret 0x4
        
    .默认
        ' 80386版
        置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 46, 87, 141, 80, 3, 139, 56, 131, 192, 4, 141, 143, 255, 254, 254, 254, 247, 215, 35, 207, 129, 225, 128, 128, 128, 128, 116, 233, 247, 193, 128, 128, 0, 0, 117, 6, 193, 233, 16, 131, 192, 2, 208, 225, 27, 194, 95, 201, 194, 4, 0 })
        ' *** 缩略程序块 ***
        ' mov eax,dword ptr [ebp+0x8]
        ' mov eax,dword ptr [eax]
        ' test eax,eax
        ' jz exit
        ' push edi
        ' lea edx,dword ptr [eax+0x3]
        
        ' label_b:
        ' mov edi,dword ptr [eax]
        ' add eax,4
        ' lea ecx,dword ptr [edi-0x01010101]
        ' not edi
        ' and ecx,edi
        ' and ecx,0x80808080
        ' jz label_b
        
        ' test ecx,0x8080
        ' jnz label_f
        ' shr ecx,16
        ' add eax,2
        
        ' label_f:
        ' shl cl,1
        ' sbb eax,edx
        ' pop edi
        ' exit:
        ' leave
        ' ret 0x4
    .判断结束
    返回 (0)

.子程序 CPU_IsAVX2_ASM, 逻辑型, , 判断CPU是否支持AVX2指令集
    置入代码 ({ 83, 184, 1, 0, 0, 0, 15, 162, 129, 225, 0, 0, 0, 24, 129, 249, 0, 0, 0, 24, 117, 43, 184, 7, 0, 0, 0, 185, 0, 0, 0, 0, 15, 162, 131, 227, 32, 131, 251, 32, 117, 23, 185, 0, 0, 0, 0, 15, 1, 208, 131, 224, 6, 131, 248, 6, 117, 7, 184, 1, 0, 0, 0, 235, 2, 51, 192, 91, 201, 195 })
    ' *** 缩略程序块 ***
    ' push ebx
    ' mov eax,0x1
    ' cpuid
    ' and ecx,0x18000000
    ' cmp ecx,0x18000000  //检查两个OXFAX和AVX特征标志
    ' jne NOT_SUPPORTED
    ' //处理器支持AVX指令，xgetbv已启用
    ' mov eax,0x7
    ' mov ecx,0x0
    ' cpuid
    ' and ebx,0x20
    ' cmp ebx,0x20  //检查AVX2特征标志
    ' jne NOT_SUPPORTED
    ' mov ecx,0x0
    ' xgetbv
    ' and eax,0x6
    ' cmp eax,0x6   //检查是否启用XMM和YMM状态支持
    ' jne NOT_SUPPORTED
    ' mov eax,0x1
    ' jmp done
    ' NOT_SUPPORTED:
    ' xor eax,eax
    ' done:
    ' pop ebx
    ' leave
    ' ret
    返回 (假)

.子程序 CPU_IsSSE2_ASM, 逻辑型, , 判断CPU是否支持SEE2指令集
    置入代码 ({ 83, 184, 1, 0, 0, 0, 15, 162, 129, 226, 0, 0, 0, 4, 139, 194, 91, 201, 195 })
    ' *** 缩略程序块 ***
    ' push ebx
    ' mov eax,0x1
    ' cpuid
    ' and edx,0x4000000  //检查EDX二进制值的第27位，是否为1，为1表示支持SSE2
    ' mov eax,edx
    ' pop ebx
    ' leave
    ' ret
    
    ' EDX二进制位信息：
    ' *** 缩略程序块 ***
    ' 1左移0 =FPU
    ' 1左移1 =VME
    ' 1左移2 =DE
    ' 1左移3 =PSE
    ' 1左移4 =TSC
    ' 1左移5 =MSR
    ' 1左移6 =PAE
    ' 1左移7 =MCE
    ' 1左移8 =CMPXCHG8B
    ' 1左移9 =APIC
    ' 1左移11=SYSENTER/SYSEXIT
    ' 1左移12=MTRR
    ' 1左移13=PGE
    ' 1左移14=MCA
    ' 1左移15=CMOV
    ' 1左移16=PAT
    ' 1左移17=PSE36
    ' 1左移18=PNS
    ' 1左移19=CLFSH
    ' 1左移21=DebugStore
    ' 1左移22=ACPI
    ' 1左移23=MMX
    ' 1左移24=FXSR
    ' 1左移25=SSE
    ' 1左移26=SSE2
    ' 1左移27=Selfsnoop
    ' 1左移28=HTT
    ' 1左移29=TM
    ' 1左移31=PBE
    返回 (假)

.子程序 编码_URL编码_快速, 文本型, 公开, 与PHP的 urlencode() 函数功能相同
    .参数 数据, 字节集
    .参数 大写, 逻辑型, 可空
    .局部变量 文本长度, 整数型
    .局部变量 返回值, 文本型

    文本长度 ＝ 0
    置入代码 ({ 80, 139, 69, 8, 139, 0, 139, 64, 4, 107, 192, 3, 137, 69, 252, 88 })
    ' push eax
    ' mov eax,[ebp+8]
    ' mov eax,[eax]
    ' mov eax,[eax+4]
    ' imul eax,3
    ' mov [ebp-4],eax
    ' pop eax
    返回值 ＝ 取空白文本 (文本长度)
    置入代码 ({ 235, 31, 128, 227, 15, 128, 251, 0, 114, 10, 128, 251, 9, 119, 5, 128, 195, 48, 235, 12, 10, 246, 116, 5, 128, 195, 55, 235, 3, 128, 195, 87, 195, 80, 83, 81, 82, 86, 87, 139, 117, 8, 138, 117, 12, 128, 230, 1, 139, 54, 139, 126, 4, 131, 198, 8, 51, 201, 139, 69, 248, 235, 117, 138, 28, 49, 50, 255, 128, 251, 32, 116, 15, 128, 251, 45, 116, 10, 128, 251, 46, 116, 5, 128, 251, 95, 117, 2, 235, 38, 128, 251, 48, 114, 7, 128, 251, 57, 119, 2, 235, 26, 128, 251, 65, 114, 7, 128, 251, 90, 119, 2, 235, 14, 128, 251, 97, 114, 7, 128, 251, 122, 119, 2, 235, 2, 183, 1, 10, 255, 116, 34, 178, 37, 136, 16, 138, 211, 138, 218, 192, 235, 4, 232, 110, 255, 255, 255, 136, 88, 1, 138, 218, 232, 100, 255, 255, 255, 136, 88, 2, 131, 192, 3, 235, 13, 138, 20, 49, 128, 250, 32, 117, 2, 178, 43, 136, 16, 64, 65, 59, 207, 114, 135, 50, 219, 136, 24, 95, 94, 90, 89, 91, 88 })
    ' jmp MAIN
    ' DEC2HEX:
    ' AND BL,0FH
    ' .if BL >=0 && BL <=9
    ' ADD BL,30H
    ' .else
    ' .if DH
    ' ADD BL,37H
    ' .elseif
    ' ADD BL,57H
    ' .endif
    ' .endif
    ' ret
    ' MAIN:
    ' push eax
    ' push ebx
    ' push ecx
    ' push edx
    ' push esi
    ' push edi
    ' mov esi,[ebp+8]
    ' mov dh,[ebp+12]
    ' and dh,1
    ' mov esi,[esi]
    ' mov edi,[esi+4]
    ' add esi,8
    ' xor ecx,ecx
    ' mov eax,[ebp-8]
    ' .while ecx < edi
    ' mov bl,[esi+ecx]
    ' xor bh,bh
    ' .if bl == 32 || bl == 45 || bl == 46 || bl == 95
    ' .elseif bl >= 48 && bl <= 57
    ' .elseif bl >= 65 && bl <= 90
    ' .elseif bl >= 97 && bl <= 122
    ' .else
    ' mov bh,1
    ' .endif
    ' .if bh
    ' mov dl,"%"
    ' mov [eax],dl
    ' mov dl,bl
    ' mov bl,dl
    ' shr bl,4
    ' call DEC2HEX
    ' mov [eax+1],bl
    ' mov bl,dl
    ' call DEC2HEX
    ' mov [eax+2],bl
    ' add eax,3
    ' .else
    ' mov dl,[esi+ecx]
    ' .if dl == 32
    ' mov dl,43
    ' .endif
    ' mov [eax],dl
    ' inc eax
    ' .endif
    ' inc ecx
    ' .endw
    ' xor bl,bl
    ' mov [eax],bl
    ' pop edi
    ' pop esi
    ' pop edx
    ' pop ecx
    ' pop ebx
    ' pop eax
    
    返回 (返回值)

.子程序 汇编_字节集URL解码, , , 将参数的内容直接进行URL解码,结果在原变量中
    .参数 局_字节集变量参数, 字节集

    置入代码 ({ 96, 139, 69, 8, 139, 0, 131, 192, 8, 80, 139, 248, 139, 240, 172, 60, 0, 116, 37, 60, 37, 117, 30, 73, 172, 60, 57, 118, 4, 36, 223, 44, 7, 44, 48, 138, 224, 192, 228, 4, 172, 60, 57, 118, 4, 36, 223, 44, 7, 44, 48, 10, 196, 170, 235, 214, 91, 139, 67, 252, 78, 43, 198, 3, 199, 137, 67, 252, 97, 201, 194, 4, 0 })

.子程序 编码_URL解码_快速, 文本型, 公开
    .参数 参_解码文本, 文本型
    .参数 参_是否UTF8, 逻辑型, 可空
    .参数 参_汇编模式, 逻辑型, 可空
    .局部变量 局_字节集变量, 字节集
    .局部变量 局_返回字节集, 字节型, , "0"
    .局部变量 局_循环容器, 整数型
    .局部变量 Len, 整数型
    .局部变量 c1, 字节型
    .局部变量 c0, 字节型
    .局部变量 num, 整数型

    .如果真 (参_解码文本 ＝ “”)
        返回 (“”)
    .如果真结束
    
    局_字节集变量 ＝ 到字节集 (参_解码文本)
    .如果 (参_汇编模式)
        ' http://bbs.125.la/forum.php?mod=viewthread&tid=14226272
        局_字节集变量 ＝ 局_字节集变量 ＋ { 0 }
        汇编_字节集URL解码 (局_字节集变量)
    .否则
        Len ＝ 取字节集长度 (局_字节集变量)
        局_循环容器 ＝ 1
        .判断循环首 (局_循环容器 ≤ Len)
            .判断开始 (局_字节集变量 [局_循环容器] ≠ 37)
                加入成员 (局_返回字节集, 局_字节集变量 [局_循环容器])
            .默认
                
                局_循环容器 ＝ 局_循环容器 ＋ 1
                .如果真 (Len ＜ 局_循环容器)
                    ' 防止数组溢出
                    跳出循环 ()
                .如果真结束
                c1 ＝ 局_字节集变量 [局_循环容器]
                局_循环容器 ＝ 局_循环容器 ＋ 1
                
                .如果真 (Len ＜ 局_循环容器)
                    ' 防止数组溢出
                    跳出循环 ()
                .如果真结束
                
                c0 ＝ 局_字节集变量 [局_循环容器]
                num ＝ hex2dec (c1) × 16 ＋ hex2dec (c0)
                加入成员 (局_返回字节集, num)
            .判断结束
            
            局_循环容器 ＝ 局_循环容器 ＋ 1
        .判断循环尾 ()
        局_字节集变量 ＝ 到字节集 (局_返回字节集)
    .如果结束
    
    .如果真 (参_是否UTF8)
        返回 (编码_Utf8到Ansi (局_字节集变量))
    .如果真结束
    返回 (到文本 (局_字节集变量))

.子程序 hex2dec, 整数型
    .参数 c, 字节型

    .判断开始 (c ≥ 48 且 c ≤ 57)
        返回 (c － 48)
    .判断 (c ≥ 97 且 c ≤ 102)
        返回 (c － 97 ＋ 10)
    .判断 (c ≥ 65 且 c ≤ 70)
        返回 (c － 65 ＋ 10)
    .默认
        返回 (-1)
    .判断结束
    

.子程序 编码_URL编码_JS, 文本型, 公开
    .参数 参_待编码文本, 文本型
    .参数 参_类型, 整数型, 可空, 默认：0     0=encodeURI 1=encodeURIComponent  
    .局部变量 JS, 类_脚本组件
    .局部变量 局_结果, 文本型
    .局部变量 局_类型, 文本型

    .判断开始 (参_类型 ＝ 0)
        局_类型 ＝ “encodeURI” ' 支持&符号编码 感谢【不想说话的树】提供
    .判断 (参_类型 ＝ 1)
        局_类型 ＝ “encodeURIComponent”
    .默认
        局_类型 ＝ “encodeURI”
    .判断结束
    局_结果 ＝ JS.运行 (局_类型, 参_待编码文本, , , , , )
    ' encodeURIComponent   把URI字符串采用URF-8编码格式转化成escape格式的字符串。与encodeURI相比，这个函数会将更多的字符进行编码，比如"/"等字符。所以如果字符串里面包含了URI的几个部分的话，不能用这个来进行编码。否则“/”字符被编码后将URL显示错误。不会被此方法编码的字符：! * ( )
    
    ' encodeURI  把URI字符串采用UTF-8编码格式转化成escape格式的字符串。不会被此方法编码的字符：! @ # $ & ( ) = ： / ; ? + '
    返回 (局_结果)

.子程序 编码_URL解码_JS, 文本型, 公开
    .参数 参_待编码文本, 文本型
    .参数 参_类型, 整数型, 可空, 默认：0     0=decodeURI 1=decodeURIComponent  
    .局部变量 JS, 类_脚本组件
    .局部变量 局_结果, 文本型
    .局部变量 局_类型, 文本型

    .判断开始 (参_类型 ＝ 0)
        局_类型 ＝ “decodeURI”
    .判断 (参_类型 ＝ 1)
        局_类型 ＝ “decodeURIComponent”
    .默认
        局_类型 ＝ “decodeURI”
    .判断结束
    局_结果 ＝ JS.运行 (局_类型, 参_待编码文本, , , , , )
    返回 (局_结果)

.子程序 编码_URL编码_局部, 文本型, 公开, 一般含有中文或#%&+符号的GET或POST表单参数才需要进行编码..不要对整个网址域名和页面文件名称进行编码
    .参数 参_URL, 文本型, , 注意:不要编码整个网址,如 http://www.baidu.com/s?wd=精易模块 只需要编码 精易模块 文本
    .参数 参_是否UTF8, 逻辑型, 可空, 采用UFT_8编码     示例代码如  "http://www.baidu.com/s?wd=" + URL编码 ( "精易模块" )
    .局部变量 局_符号, 逻辑型, , , 把符号 :/?-=()_*. 也编码.注意:不该对网址域名和页面文件名进行符号编码,但GET或POST的提交参数可以进行符号编码.

    .局部变量 局_TEMP, 字节集
    .局部变量 计次, 整数型
    .局部变量 局_返回, 字节集
    .局部变量 索引, 整数型
    .局部变量 局_指针, 整数型

    .如果 (参_是否UTF8)
        局_TEMP ＝ 编码_UTF8编码 (参_URL, )
    .否则
        局_TEMP ＝ 到字节集 (参_URL)
    .如果结束
    
    .如果真 (SEH_安装简单SEH ())
        局_返回 ＝ 取空白字节集 (取字节集长度 (局_TEMP) × 3 ＋ 64)
        局_指针 ＝ 取字节集指针 (局_返回)
        
        .计次循环首 (取字节集长度 (局_TEMP), 计次)
            递增 (索引)
            递增 (局_指针) ' 58,47,63,45,61,40,41,95,46
            .如果真 (局_TEMP [计次] ＞ 32 且 局_TEMP [计次] ＜ 127) ' 排除空格与之前的字符及128值
                .如果真 (局_TEMP [计次] ≠ 35 且 局_TEMP [计次] ≠ 37 且 局_TEMP [计次] ≠ 38 且 局_TEMP [计次] ≠ 43) ' #%&+
                    局_返回 [索引] ＝ 局_TEMP [计次]
                    到循环尾 ()
                .如果真结束
                
            .如果真结束
            局_返回 [索引] ＝ 37
            wvsprintfA_整数型 (局_指针, “%02X”, 局_TEMP [计次])
            索引 ＝ ADD__ (索引, 2, )
            局_指针 ＝ ADD__ (局_指针, 2, )
            
            
            
        .计次循环尾 ()
        
    .如果真结束
    SEH_删除简单SEH ()
    返回 (到文本 (局_返回))

.子程序 编码_URL解码_局部, 文本型, 公开
    .参数 参_URL, 文本型, , 待解码的密文URL地址
    .参数 参_是否UTF8, 逻辑型, 可空, 采用UFT_8解码
    .局部变量 局_TEMP, 字节集
    .局部变量 计次, 整数型
    .局部变量 局_长度, 整数型
    .局部变量 局_H, 整数型
    .局部变量 局_L, 整数型
    .局部变量 局_返回, 字节集
    .局部变量 索引, 整数型
    .局部变量 局_窄文, 文本型

    局_TEMP ＝ 到字节集 (参_URL) ＋ { 0, 0, 0, 0, 0, 0, 0, 0 }
    局_长度 ＝ 取字节集长度 (局_TEMP)
    局_返回 ＝ 取空白字节集 (局_长度)
    局_长度 ＝ 局_长度 － 8
    .判断循环首 (计次 ＜ 局_长度)
        递增 (计次)
        递增 (索引)
        ' 37,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,97,98,99,100,101,102 '%0-9A-Fa-f
        .如果 (局_TEMP [计次] ＝ 37) ' %
            递增 (计次)
            .判断开始 (局_TEMP [计次] ＞ 96) ' a-f
                局_H ＝ 局_TEMP [计次] － 87
            .判断 (局_TEMP [计次] ＞ 64) ' A-F
                局_H ＝ 局_TEMP [计次] － 55
            .默认
                局_H ＝ 局_TEMP [计次] － 48
            .判断结束
            
            递增 (计次)
            .判断开始 (局_TEMP [计次] ＞ 96) ' a-f
                局_L ＝ 局_TEMP [计次] － 87
            .判断 (局_TEMP [计次] ＞ 64) ' A-F
                局_L ＝ 局_TEMP [计次] － 55
            .默认
                局_L ＝ 局_TEMP [计次] － 48
            .判断结束
            
            局_返回 [索引] ＝ 局_H × 16 ＋ 局_L
        .否则
            局_返回 [索引] ＝ 局_TEMP [计次]
        .如果结束
        
    .判断循环尾 ()
    .如果真 (参_是否UTF8)
        编码_UTF8解码 (局_返回, 局_窄文)
        返回 (局_窄文)
    .如果真结束
    返回 (到文本 (局_返回))

.子程序 编码_UTF8编码, 字节集, 公开, 把一段窄文本型或宽文本数据转换成UTF8格式数据
    .参数 文本数据, 文本型, 可空, 本函数的两个参数根据需要只可提供其中之一个参数
    .参数 宽文本型, 字节集, 可空, 本函数的两个参数根据需要只可提供其中之一个参数
    .局部变量 字数, 整数型
    .局部变量 长度, 整数型
    .局部变量 宽文, 字节集

    .局部变量 UTF8, 字节集

    .如果真 (文本数据 ＝ “” 且 宽文本型 ＝ { })
        返回 ({ })
    .如果真结束
    .如果 (SEH_安装简单SEH ())
        .如果 (文本数据 ≠ “”) ' 先转为宽文本
            字数 ＝ MultiByteToWideChar (0, 0, 取指针文本_ (文本数据), -1, 0, 0)
            字数 ＝ SUB__ (字数, 1)
            长度 ＝ 字数 × 2
            
            宽文 ＝ 取空白字节集 (长度)
            MultiByteToWideChar (0, 0, 取指针文本_ (文本数据), -1, 取指针_字节集型 (宽文), 字数)
            
        .否则
            宽文 ＝ 宽文本型
            字数 ＝ 取字节集长度 (宽文) ＼ 2
        .如果结束
        
        长度 ＝ WideCharToMultiByte (65001, 0, 取指针字节集_ (宽文), 字数, 取指针字节集_ (UTF8), 0, 0, 0)
        UTF8 ＝ 取空白字节集 (长度)
        WideCharToMultiByte (65001, 0, 取指针字节集_ (宽文), 字数, 取指针_字节集型 (UTF8), 长度, 0, 0)
        
    .否则
        UTF8 ＝ { }
    .如果结束
    SEH_删除简单SEH ()
    返回 (UTF8)

.子程序 编码_UTF8解码, 字节集, 公开, 直接返回宽字节  参考返回窄字节
    .参数 UTF8数据, 字节集, , 待解码的UTF8格式编码数据
    .参数 文本数据, 文本型, 参考 可空, 参考返回 文本数据
    .局部变量 指针, 整数型
    .局部变量 长度, 整数型

    .局部变量 字符, 整数型
    .局部变量 宽文, 字节集

    文本数据 ＝ “”
    .如果真 (UTF8数据 ≠ { })
        .如果 (SEH_安装简单SEH ())
            长度 ＝ 取字节集长度 (UTF8数据)
            指针 ＝ 取字节集指针 (UTF8数据)
            字符 ＝ MultiByteToWideChar (65001, 0, 指针, 长度, 0, 0)
            
            宽文 ＝ 取空白字节集 (字符 × 2)
            MultiByteToWideChar (65001, 0, 指针, 长度, 取指针_字节集型 (宽文), 字符)
            .如果真 (假 ＝ 是否为空 (文本数据))
                长度 ＝ WideCharToMultiByte (0, 0, 取指针字节集_ (宽文), 字符, 取指针文本_ (文本数据), 0, 0, 0)
                文本数据 ＝ 取空白文本 (长度)
                WideCharToMultiByte (0, 0, 取指针字节集_ (宽文), 字符, 取指针_文本型 (文本数据), 长度, 0, 0)
            .如果真结束
            
        .否则
            宽文 ＝ { }
        .如果结束
        SEH_删除简单SEH ()
        返回 (宽文)
    .如果真结束
    返回 ({ })

.子程序 进制_三十六到十, 长整数型, 公开, 将三十六进制文本转换为十进制长整数，暂不支持负数。源码由雪山凌狐提供
    .参数 三十六进制文本, 文本型, , 传入三十六进制的文本，必须为字母或者数字，字母无论大小写，但最好大写
    .局部变量 循环次数, 整数型
    .局部变量 文本长度, 整数型
    .局部变量 此次字符, 文本型
    .局部变量 十进制和, 长整数型

    文本长度 ＝ 取文本长度 (三十六进制文本)
    .计次循环首 (文本长度, 循环次数)
        此次字符 ＝ 取文本中间 (三十六进制文本, 文本长度 － 循环次数 ＋ 1, 1)
        十进制和 ＝ 十进制和 ＋ 进制_三十六_字符处理 (此次字符) × 到长整数 (求次方 (36, 循环次数 － 1))
    .计次循环尾 ()
    返回 (十进制和)

.子程序 进制_三十六_字符处理, 整数型, , 每次只能传入一个字符，不符合要求的一律返回0，内部使用，不公开。源码由雪山凌狐提供
    .参数 待处理的三十六进制字符, 文本型, , 每次只能传入一个字符
    .局部变量 str, 文本型
    .局部变量 szTmp, 文本型
    .局部变量 nPos, 整数型

    str ＝ “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ”
    szTmp ＝ 到大写 (取文本左边 (待处理的三十六进制字符, 1))
    nPos ＝ 寻找文本 (str, szTmp, , 假)
    .如果真 (nPos ＝ -1 或 nPos ＝ 1)
        返回 (0)
    .如果真结束
    返回 (nPos － 1) ' 写专业一点,这个不是写给老板看的,不需要写那么多行代码
    
    ' *** 缩略程序块 ***
    ' .判断开始 (待处理的三十六进制字符 ＝ “0”)
        ' 返回 (0)
    ' .判断 (待处理的三十六进制字符 ＝ “1”)
        ' 返回 (1)
    ' .判断 (待处理的三十六进制字符 ＝ “2”)
        ' 返回 (2)
    ' .判断 (待处理的三十六进制字符 ＝ “3”)
        ' 返回 (3)
    ' .判断 (待处理的三十六进制字符 ＝ “4”)
        ' 返回 (4)
    ' .判断 (待处理的三十六进制字符 ＝ “5”)
        ' 返回 (5)
    ' .判断 (待处理的三十六进制字符 ＝ “6”)
        ' 返回 (6)
    ' .判断 (待处理的三十六进制字符 ＝ “7”)
        ' 返回 (7)
    ' .判断 (待处理的三十六进制字符 ＝ “8”)
        ' 返回 (8)
    ' .判断 (待处理的三十六进制字符 ＝ “9”)
        ' 返回 (9)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “A”)
        ' 返回 (10)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “B”)
        ' 返回 (11)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “C”)
        ' 返回 (12)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “D”)
        ' 返回 (13)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “E”)
        ' 返回 (14)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “F”)
        ' 返回 (15)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “G”)
        ' 返回 (16)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “H”)
        ' 返回 (17)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “I”)
        ' 返回 (18)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “J”)
        ' 返回 (19)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “K”)
        ' 返回 (20)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “L”)
        ' 返回 (21)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “M”)
        ' 返回 (22)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “N”)
        ' 返回 (23)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “O”)
        ' 返回 (24)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “P”)
        ' 返回 (25)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “Q”)
        ' 返回 (26)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “R”)
        ' 返回 (27)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “S”)
        ' 返回 (28)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “T”)
        ' 返回 (29)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “U”)
        ' 返回 (30)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “V”)
        ' 返回 (31)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “W”)
        ' 返回 (32)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “X”)
        ' 返回 (33)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “Y”)
        ' 返回 (34)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “Z”)
        ' 返回 (35)
    ' .默认
        ' 返回 (0)
    ' .判断结束
    

.子程序 进制_十到三十六, 文本型, 公开, 将十进制数转换为三十六进制文本，暂不支持负数，返回的三十六进制文本若有字母默认为大写字母。源码由雪山凌狐提供
    .参数 十进制数, 长整数型, , 传入十进制数
    .局部变量 剩余十进制数, 长整数型
    .局部变量 余数, 整数型
    .局部变量 三十六进制数, 文本型

    剩余十进制数 ＝ 十进制数
    .循环判断首 ()
        余数 ＝ 到整数 (剩余十进制数 ％ 36)
        剩余十进制数 ＝ 剩余十进制数 ＼ 36
        三十六进制数 ＝ 进制_三十六_整数处理 (余数) ＋ 三十六进制数
    .循环判断尾 (剩余十进制数 ≥ 36)
    三十六进制数 ＝ 进制_三十六_整数处理 (到整数 (剩余十进制数)) ＋ 三十六进制数
    
    返回 (三十六进制数)
    

.子程序 进制_三十六_整数处理, 文本型, , 传入范围为0-35，若不符合要求则返回空文本，内部使用，不公开。源码由雪山凌狐提供
    .参数 十进制数, 整数型, , 传入十进制数，范围为0-35
    .局部变量 str, 文本型

    str ＝ “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ”
    返回 (取文本中间 (str, 十进制数 ＋ 1, 1))
    
    ' *** 缩略程序块 ***
    ' .判断开始 (十进制数 ＝ 0)
        ' 返回 (“0”)
    ' .判断 (十进制数 ＝ 1)
        ' 返回 (“1”)
    ' .判断 (十进制数 ＝ 2)
        ' 返回 (“2”)
    ' .判断 (十进制数 ＝ 3)
        ' 返回 (“3”)
    ' .判断 (十进制数 ＝ 4)
        ' 返回 (“4”)
    ' .判断 (十进制数 ＝ 5)
        ' 返回 (“5”)
    ' .判断 (十进制数 ＝ 6)
        ' 返回 (“6”)
    ' .判断 (十进制数 ＝ 7)
        ' 返回 (“7”)
    ' .判断 (十进制数 ＝ 8)
        ' 返回 (“8”)
    ' .判断 (十进制数 ＝ 9)
        ' 返回 (“9”)
    ' .判断 (十进制数 ＝ 10)
        ' 返回 (“A”)
    ' .判断 (十进制数 ＝ 11)
        ' 返回 (“B”)
    ' .判断 (十进制数 ＝ 12)
        ' 返回 (“C”)
    ' .判断 (十进制数 ＝ 13)
        ' 返回 (“D”)
    ' .判断 (十进制数 ＝ 14)
        ' 返回 (“E”)
    ' .判断 (十进制数 ＝ 15)
        ' 返回 (“F”)
    ' .判断 (十进制数 ＝ 16)
        ' 返回 (“G”)
    ' .判断 (十进制数 ＝ 17)
        ' 返回 (“H”)
    ' .判断 (十进制数 ＝ 18)
        ' 返回 (“I”)
    ' .判断 (十进制数 ＝ 19)
        ' 返回 (“J”)
    ' .判断 (十进制数 ＝ 20)
        ' 返回 (“K”)
    ' .判断 (十进制数 ＝ 21)
        ' 返回 (“L”)
    ' .判断 (十进制数 ＝ 22)
        ' 返回 (“M”)
    ' .判断 (十进制数 ＝ 23)
        ' 返回 (“N”)
    ' .判断 (十进制数 ＝ 24)
        ' 返回 (“O”)
    ' .判断 (十进制数 ＝ 25)
        ' 返回 (“P”)
    ' .判断 (十进制数 ＝ 26)
        ' 返回 (“Q”)
    ' .判断 (十进制数 ＝ 27)
        ' 返回 (“R”)
    ' .判断 (十进制数 ＝ 28)
        ' 返回 (“S”)
    ' .判断 (十进制数 ＝ 29)
        ' 返回 (“T”)
    ' .判断 (十进制数 ＝ 30)
        ' 返回 (“U”)
    ' .判断 (十进制数 ＝ 31)
        ' 返回 (“V”)
    ' .判断 (十进制数 ＝ 32)
        ' 返回 (“W”)
    ' .判断 (十进制数 ＝ 33)
        ' 返回 (“X”)
    ' .判断 (十进制数 ＝ 34)
        ' 返回 (“Y”)
    ' .判断 (十进制数 ＝ 35)
        ' 返回 (“Z”)
    ' .默认
        ' 返回 (“”)
    ' .判断结束
    

.子程序 编码_Ansi到Utf8_无BOM文件, 逻辑型, 公开, 将文本内容写出保存成utf8无BOM格式编码文件。成功返回真，失败返回假。源码由雪山凌狐提供
    .参数 文本, 文本型, , 请输入要转换的文本
    .参数 保存路径, 文本型, , 请输入保存到的文件的完整路径
    .局部变量 stream, 对象
    .局部变量 newstream, 对象

    线程_初始化COM库 ()
    .如果真 (stream.创建 (“adodb.stream”, ) ＝ 假)
        返回 (假)
    .如果真结束
    stream.写属性 (“Type”, 2) ' text
    stream.写属性 (“mode”, 3)
    stream.写属性 (“Charset”, “utf-8”)
    stream.方法 (“Open”, )
    stream.方法 (“WriteText”, 文本)
    stream.写属性 (“Position”, 3)
    .如果真 (newstream.创建 (“adodb.stream”, ) ＝ 假)
        返回 (假)
    .如果真结束
    newstream.写属性 (“mode”, 3)
    newstream.写属性 (“Type”, 1)
    newstream.方法 (“Open”, )
    stream.方法 (“CopyTo”, newstream)
    newstream.方法 (“SaveToFile”, 保存路径, 2)
    stream.方法 (“flush”, )
    stream.方法 (“Close”, )
    线程_取消COM库 ()
    
    返回 (真)

.子程序 到逻辑型, 逻辑型, 公开, 为了方便将文本型的真假二字转换成逻辑型数据或整数型转换为逻辑型编写的子程序，如果输入空值会默认返回假.源码由雪山凌狐提供
    .参数 欲转换的文本型数据, 文本型, 可空, 正常的文本型数据为“真”字或者“假”字，其他情况一律返回假，为空时默认返回假，跟整数型数据二选其一
    .参数 欲转换的整数型数据, 整数型, 可空, 传入0返回假，其他整数都返回真，若为空，默认传入0，返回假，跟文本型数据二选其一
    .参数 转换模式, 整数型, 可空, 模式1为文本型，模式2为整数型，传入其他或为空则默认为模式1

    .如果真 (是否为空 (转换模式))
        转换模式 ＝ 1
    .如果真结束
    .如果真 (转换模式 ＜ 1 或 转换模式 ＞ 2)
        转换模式 ＝ 1
    .如果真结束
    
    .判断开始 (转换模式 ＝ 1)
        ' 转换的是文本
        .如果真 (是否为空 (欲转换的文本型数据))
            返回 (假)
        .如果真结束
        
        .如果 (欲转换的文本型数据 ＝ “真”)
            返回 (真)
        .否则
            返回 (假)
        .如果结束
        
        
    .判断 (转换模式 ＝ 2)
        ' 转换的是整数
        .如果真 (是否为空 (欲转换的整数型数据))
            欲转换的整数型数据 ＝ 0
        .如果真结束
        
        .如果 (欲转换的整数型数据 ＝ 0)
            返回 (假)
        .否则
            返回 (真)
        .如果结束
        
    .默认
        ' 不会运行这一句的，但是为了让程序具有返回值定义，添加的
        返回 (假)
    .判断结束
    

.子程序 到逻辑型_通用版, 逻辑型, 公开, 非0数值,非空字符串,非空字节集返回真,其他返回假,支持所有基础数据类型,禁止传递非基础数据类型,否则都返回假
    .参数 数据, 通用型, , 如果传递过来的是文本或字节集,并且这个数据是"假",那也返回假,有没有空格都支持,支持传递栈地址,堆地址
    .局部变量 addr, 整数型
    .局部变量 bin, 字节集
    .局部变量 ret, 字节集

    置入代码 ({ 139, 69, 8, 137, 69, 252 }) ' 取参数地址,存到第一个变量
    IsBadCodePtr (addr) ' 判断指针是否有效
    置入代码 ({ 131, 248, 0, 118, 7, 139, 69, 8, 201, 194, 4, 0 }) ' 如果指针无效,则返回,非0返回真
    IsBadCodePtr (指针_到整数 (addr)) ' 在判断一下,有可能用户传递过来的是变量的栈地址
    置入代码 ({ 11, 192, 117, 8, 139, 69, 8, 139, 0, 137, 69, 252 }) ' 如果传递过来的是栈地址,那就取堆地址,并放到第一个变量,如果不是则不处理
    
    bin ＝ 指针到字节集 (addr, 4) ' 取这个地址的4个字节,做为一个判断是字节集还是文本的方法
    ' 这样的判断不是很严谨,如果有人非要搞事情,传递个  字符(1)+字符(0)+字符(0)+字符(0),那这里也会被判断为字节集,不过搞事情的人不多,不要紧
    .判断开始 (bin ＝ { 1, 0, 0, 0 }) ' 传过来的是字节集类型
        ret ＝ 指针到字节集 (addr ＋ 8, 指针_到整数 (addr ＋ 4)) ' 字节集从第八个字节才是实际数据,第4-第七个字节是数据长度,把数据取出来
        ret ＝ 子字节集替换 (ret, { 32 }, , , ) ' 删除全部的空格
        .如果真 (ret ＝ 到字节集 (“假”)) ' 如果这个字节集是"假" 这个字,也返回假,这里不做非ansi编码的判断,需要的自己加
            返回 (假)
        .如果真结束
        返回 (ret ≠ { }) ' 剩下的只要不是空字节集就返回真
    .默认
        ' 不做非基础类型的判断,只做文本和字节集的判断
        .如果真 (删全部空 (指针到文本 (addr)) ＝ “假”) ' 如果传递过来的是"假" 那就返回假,这里不做非ansi编码的判断,需要的自己加
            返回 (假)
        .如果真结束
        返回 (取字节集左边 (bin, 1) ≠ { 0 }) ' 剩下的只要不是空字符串都返回真
    .判断结束
    返回 (假)

.子程序 内部_bmzh, 字节集, , 内部调用
    .参数 待转换数据, 字节集
    .参数 转换前编码, 文本型
    .参数 转换后编码, 文本型
    .参数 转换后数据开始位置, 整数型, 可空
    .局部变量 对象, 对象
    .局部变量 文本, 文本型
    .局部变量 字节集, 字节集
    .局部变量 变体型, 变体型

    CoInitialize (0)
    对象.创建 (“Adodb.Stream”, )
    对象.写属性 (“Type”, 1) ' 流类型为字节集
    对象.方法 (“Open”, )
    变体型.置类型 (7)
    变体型.创建数组 (1, 取字节集长度 (待转换数据))
    变体型.赋值 (待转换数据, )
    对象.方法 (“Write”, 变体型)
    对象.写属性 (“Position”, 0)
    对象.写属性 (“Type”, 2) ' 流类型为文本
    对象.写属性 (“Charset”, 转换前编码)
    文本 ＝ 对象.文本方法 (“ReadText”, )
    对象.方法 (“Close”, )
    对象.方法 (“Open”, )
    对象.写属性 (“Charset”, 转换后编码)
    对象.方法 (“WriteText”, 文本)
    对象.写属性 (“Position”, 0)
    对象.写属性 (“Type”, 1) ' 流类型为字节集
    .如果真 (是否为空 (转换后数据开始位置) ＝ 假)
        对象.写属性 (“Position”, 转换后数据开始位置)
    .如果真结束
    字节集 ＝ 对象.通用方法 (“Read”, ).取字节集 ()
    对象.清除 ()
    CoUninitialize ()
    返回 (字节集)

.子程序 编码_编码转换对象, 字节集, 公开, 默认“UTF-8”到“GBK”解码
    .参数 待转换数据, 字节集
    .参数 转换前编码, 文本型, 可空, utf-8；unicode；GBK 等
    .参数 转换后编码, 文本型, 可空, utf-8；unicode；GBK 等
    .参数 转换后数据开始位置, 整数型, 可空, 位置从0开始。unicode编码标识占2个字节，utf-8编码标识占3个字节
    .局部变量 ret, 字节集

    .如果真 (转换前编码 ＝ “”)
        转换前编码 ＝ “UTF-8”
    .如果真结束
    
    .如果真 (转换后编码 ＝ “”)
        转换后编码 ＝ “GBK”
    .如果真结束
    线程_初始化COM库 ()
    .如果 (是否为空 (转换后数据开始位置))
        ret ＝ 内部_bmzh (待转换数据, 转换前编码, 转换后编码)
    .否则
        ret ＝ 内部_bmzh (待转换数据, 转换前编码, 转换后编码, 转换后数据开始位置)
    .如果结束
    线程_取消COM库 ()
    返回 (ret)

.子程序 字符交换, 字节集
    .参数 字节集, 字节集
    .局部变量 局_计次, 整数型
    .局部变量 局_长度
    .局部变量 局_字节集, 字节集

    局_长度 ＝ 取字节集长度 (字节集)
    局_字节集 ＝ 取空白字节集 (局_长度)
    .变量循环首 (1, 局_长度, 2, 局_计次)
        局_字节集 [局_计次] ＝ 字节集 [局_计次 ＋ 1]
        局_字节集 [局_计次 ＋ 1] ＝ 字节集 [局_计次]
    .变量循环尾 ()
    返回 (局_字节集)

.子程序 输出字节集, 文本型, , ansi到usc2
    .参数 原文, 字节集
    .局部变量 局_原文长度, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_结果, 字节集
    .局部变量 局_记录, 整数型
    .局部变量 局_数组2, 整数型, , "256"
    .局部变量 局_数组1, 整数型, , "256"

    局_原文长度 ＝ 取字节集长度 (原文) － 2
    .如果真 (局_原文长度 ＜ 1)
        返回 (“”)
    .如果真结束
    局_数组1 ＝ { 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70 }
    局_数组2 ＝ { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70 }
    局_结果 ＝ 取空白字节集 (局_原文长度 × 2)
    局_记录 ＝ 1
    .变量循环首 (1, 局_原文长度, 1, 局_计次)
        局_结果 [局_记录] ＝ 局_数组1 [原文 [局_计次] ＋ 1]
        局_结果 [局_记录 ＋ 1] ＝ 局_数组2 [原文 [局_计次] ＋ 1]
        局_记录 ＝ 局_记录 ＋ 2
    .变量循环尾 ()
    返回 (到文本 (局_结果))

.子程序 转到字节集, 字节集
    .参数 原文, 字节集
    .局部变量 局_长度, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_结果, 字节集
    .局部变量 局_记录, 整数型
    .局部变量 局_新码表, 字节型, , "70,70"
    .局部变量 局_码表, 字节集
    .局部变量 局_临时文本, 文本型

    局_长度 ＝ 取字节集长度 (原文)
    .如果真 (局_长度 ＜ 1)
        返回 ({ })
    .如果真结束
    局_码表 ＝ 到字节集 (“0123456789ABCDEF”)
    .变量循环首 (0, 15, 1, 局_计次)
        .变量循环首 (0, 15, 1, 局_记录)
            局_新码表 [局_码表 [局_计次 ＋ 1]] [局_码表 [局_记录 ＋ 1]] ＝ 左移 (局_计次, 4) ＋ 局_记录
        .变量循环尾 ()
    .变量循环尾 ()
    局_结果 ＝ 取空白字节集 (局_长度 ÷ 2)
    局_记录 ＝ 1
    .变量循环首 (1, 局_长度, 2, 局_计次)
        局_结果 [局_记录] ＝ 局_新码表 [原文 [局_计次]] [原文 [局_计次 ＋ 1]]
        局_记录 ＝ 局_记录 ＋ 1
    .变量循环尾 ()
    返回 (局_结果)

.子程序 Ansi到Unicode_字节集, 字节集
    .参数 Ansi, 字节集
    .参数 原始编码, 整数型, 可空
    .局部变量 临时_Ansi字节集, 字节集
    .局部变量 Unicode, 字节集
    .局部变量 长度, 整数型

    .如果真 (是否为空 (原始编码))
        原始编码 ＝ 65001
    .如果真结束
    临时_Ansi字节集 ＝ Ansi ＋ { 0 }
    长度 ＝ MultiByteToWideChar (0, 0, 取指针_字节集型 (临时_Ansi字节集), -1, 0, 0)
    Unicode ＝ 取空白字节集 (长度 × 2 ＋ 2)
    MultiByteToWideChar (原始编码, 0, 取指针_字节集型 (临时_Ansi字节集), -1, 取指针_字节集型 (Unicode), 长度)
    返回 (Unicode)
    

.子程序 Unicode到Ansi_字节集, 文本型
    .参数 Unicode, 字节集
    .参数 目标编码, 整数型, 可空
    .局部变量 Ansi, 文本型
    .局部变量 长度, 整数型

    .如果真 (是否为空 (目标编码))
        目标编码 ＝ 0
    .如果真结束
    长度 ＝ WideCharToMultiByte (0, 0, 取指针_字节集型 (Unicode), -1, 0, 0, 0, 0)
    Ansi ＝ 取空白文本 (长度 × 2)
    WideCharToMultiByte (目标编码, 0, 取指针_字节集型 (Unicode), -1, 取指针_文本型 (Ansi), 长度 × 2, 0, 0)
    返回 (Ansi)
    

.子程序 Ansi到Unicode, 字节集
    .参数 Ansi, 文本型
    .参数 原始编码, 整数型, 可空
    .局部变量 Unicode, 字节集
    .局部变量 长度, 整数型

    .如果真 (是否为空 (原始编码))
        原始编码 ＝ 65001
    .如果真结束
    长度 ＝ MultiByteToWideChar (0, 0, 取指针文本_ (Ansi), -1, 0, 0)
    Unicode ＝ 取空白字节集 (长度 × 2)
    MultiByteToWideChar (原始编码, 0, 取指针文本_ (Ansi), -1, 取指针_字节集型 (Unicode), 长度)
    返回 (Unicode)

.子程序 Unicode到Ansi, 文本型
    .参数 Unicode, 字节集
    .参数 目标编码, 整数型, 可空
    .局部变量 Ansi, 文本型
    .局部变量 长度, 整数型

    .如果真 (是否为空 (目标编码))
        目标编码 ＝ 0
    .如果真结束
    长度 ＝ WideCharToMultiByte (0, 0, 取指针_字节集型 (Unicode), -1, 0, 0, 0, 0)
    Ansi ＝ 取空白文本 (长度 × 2)
    WideCharToMultiByte (目标编码, 0, 取指针_字节集型 (Unicode), -1, 取指针_文本型 (Ansi), 长度 × 2, 0, 0)
    返回 (Ansi)
    

.子程序 编码_运行JS代码, 文本型, 公开, 失败返回“JS代码运行失败”，如果此命令用于线程内，请在线程子程序里的第一行加上 线程_初始化COM库 ()
    .参数 JS代码, 文本型
    .参数 函数名, 文本型, , 要运行的Js函数名
    .参数 参数一, 文本型, 可空
    .参数 参数二, 文本型, 可空
    .参数 参数三, 文本型, 可空
    .参数 参数四, 文本型, 可空
    .局部变量 脚本, 类_脚本组件

    .如果真 (脚本.执行 (JS代码))
        返回 (脚本.运行 (函数名, 参数一, 参数二, 参数三, 参数四))
    .如果真结束
    返回 (“JS代码运行失败”)
    

.子程序 编码_URL解码, 文本型, 公开, 将网页返回的数据解码
    .参数 URL, 文本型
    .参数 是否UTF8, 逻辑型, 可空, 先将文本串解码为文本,再从UTF8转成GBK编码
    .局部变量 循环容器, 整数型
    .局部变量 Len, 整数型
    .局部变量 HEX, 文本型
    .局部变量 目标, 文本型
    .局部变量 H, 整数型
    .局部变量 L, 整数型

    Len ＝ 取文本长度 (URL)
    循环容器 ＝ 1
    HEX ＝ “0123456789ABCDEF”
    .判断循环首 (循环容器 ≤ Len)
        .判断开始 (取文本中间 (URL, 循环容器, 1) ≠ “%”)
            目标 ＝ 目标 ＋ 取文本中间 (URL, 循环容器, 1)
        .默认
            循环容器 ＝ 循环容器 ＋ 1
            H ＝ 寻找文本 (HEX, 到大写 (取文本中间 (URL, 循环容器, 1)), , 假) － 1
            循环容器 ＝ 循环容器 ＋ 1
            L ＝ 寻找文本 (HEX, 到大写 (取文本中间 (URL, 循环容器, 1)), , 假) － 1
            目标 ＝ 目标 ＋ 字符 (H × 16 ＋ L)
        .判断结束
        循环容器 ＝ 循环容器 ＋ 1
    .判断循环尾 ()
    .如果真 (是否UTF8)
        目标 ＝ 编码_utf8到gb2312 (目标)
    .如果真结束
    返回 (目标)

.子程序 编码_URL编码, 文本型, 公开, 将指定文本编码
    .参数 欲编码的文本, 文本型
    .参数 不编码字母数字, 逻辑型, 可空, 不需要编码【字母数字.-】可以把此参数设置为真
    .参数 是否UTF8, 逻辑型, 可空, 先把文本转换成UTF8编码,再编码成URL
    .局部变量 结果文本, 文本型
    .局部变量 字节集, 字节集
    .局部变量 计次, 整数型
    .局部变量 temp, 文本型

    .如果真 (欲编码的文本 ＝ “”)
        返回 (“”)
    .如果真结束
    
    .判断开始 (是否UTF8)
        字节集 ＝ 到字节集 (编码_gb2312到utf8 (欲编码的文本))
    .默认
        字节集 ＝ 到字节集 (欲编码的文本)
    .判断结束
    
    .变量循环首 (1, 取字节集长度 (字节集), 1, 计次)
        temp ＝ 取十六进制文本 (字节集 [计次])
        .如果真 (取文本长度 (temp) ＜ 2)
            temp ＝ “0” ＋ temp
        .如果真结束
        
        .如果 (不编码字母数字)
            .判断开始 (字节集 [计次] ＞ 44 且 字节集 [计次] ＜ 58 且 字节集 [计次] ≠ 47)
                ' -.0-9
                结果文本 ＝ 结果文本 ＋ 字符 (字节集 [计次])
                
            .判断 (字节集 [计次] ＞ 64 且 字节集 [计次] ＜ 91) ' A-Z
                结果文本 ＝ 结果文本 ＋ 字符 (字节集 [计次])
                
            .判断 (字节集 [计次] ＞ 96 且 字节集 [计次] ＜ 123) ' a-z
                结果文本 ＝ 结果文本 ＋ 字符 (字节集 [计次])
                
            .默认
                结果文本 ＝ 结果文本 ＋ “%” ＋ temp
            .判断结束
            
        .否则
            结果文本 ＝ 结果文本 ＋ “%” ＋ temp
        .如果结束
        
    .变量循环尾 ()
    返回 (结果文本)

.子程序 编码_BASE64编码, 文本型, 公开, BASE64编码处理；成功返回编码后的文本；
    .参数 待编码数据, 字节集, , 待编码字节集
    .局部变量 余数
    .局部变量 临时, 字节型, , "3"
    .局部变量 变量
    .局部变量 集合, 字节集
    .局部变量 长度, 整数型
    .局部变量 字符, 字节集
    .局部变量 i

    长度 ＝ 取字节集长度 (待编码数据)
    .如果真 (长度 ＜ 1)
        返回 (“”)
    .如果真结束
    余数 ＝ 长度 ％ 3
    .如果真 (余数 ＞ 0)
        待编码数据 ＝ 待编码数据 ＋ 取空白字节集 (3 － 余数)
    .如果真结束
    长度 ＝ 取字节集长度 (待编码数据)
    字符 ＝ 取空白字节集 (长度 × 4 ÷ 3)
    i ＝ 1
    集合 ＝ 到字节集 (“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”)
    .变量循环首 (1, 长度, 3, 变量)
        临时 [1] ＝ 待编码数据 [变量]
        临时 [2] ＝ 待编码数据 [变量 ＋ 1]
        临时 [3] ＝ 待编码数据 [变量 ＋ 2]
        字符 [i] ＝ 集合 [右移 (临时 [1], 2) ＋ 1]
        字符 [i ＋ 1] ＝ 集合 [左移 (位与 (临时 [1], 3), 4) ＋ 右移 (临时 [2], 4) ＋ 1]
        字符 [i ＋ 2] ＝ 集合 [左移 (位与 (临时 [2], 15), 2) ＋ 右移 (临时 [3], 6) ＋ 1]
        字符 [i ＋ 3] ＝ 集合 [位与 (临时 [3], 63) ＋ 1]
        i ＝ i ＋ 4
    .变量循环尾 ()
    .如果真 (余数 ＞ 0)
        长度 ＝ 取字节集长度 (字符)
        .如果 (余数 ＝ 1)
            字符 [长度 － 1] ＝ 到字节 (取代码 (“=”, ))
            字符 [长度] ＝ 到字节 (取代码 (“=”, ))
        .否则
            字符 [长度] ＝ 到字节 (取代码 (“=”, ))
        .如果结束
        
    .如果真结束
    返回 (到文本 (字符))

.子程序 编码_BASE64解码, 字节集, 公开, BASE64解码处理；成功返回解码后的字节集数据；
    .参数 编码文本, 文本型, , 待解码的文本
    .参数 去除右边空白字节集, 逻辑型, 可空
    .局部变量 文本长度
    .局部变量 整倍数
    .局部变量 三字节组, 字节型, , "3"
    .局部变量 四字节组, 字节型, , "4"
    .局部变量 编码值
    .局部变量 X
    .局部变量 n
    .局部变量 二进制数据, 字节集

    编码文本 ＝ 删全部空 (编码文本)
    编码文本 ＝ 子文本替换 (编码文本, #换行符, , , , 真)
    文本长度 ＝ 取文本长度 (编码文本)
    整倍数 ＝ 文本长度 ＼ 4
    .如果真 (文本长度 ％ 4 ≠ 0)
        整倍数 ＝ 整倍数 ＋ 1
    .如果真结束
    .计次循环首 (整倍数, X)
        .计次循环首 (4, n)
            四字节组 [n] ＝ 到字节 (取代码 (编码文本, (X － 1) × 4 ＋ n))
            编码值 ＝ 寻找文本 (“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”, 字符 (四字节组 [n]), , 假)
            .如果真 (编码值 ＝ -1)
                跳出循环 ()
            .如果真结束
            四字节组 [n] ＝ 编码值 － 1
        .计次循环尾 ()
        三字节组 [1] ＝ 到字节 (位或 (四字节组 [1] × 4, 四字节组 [2] ÷ 16))
        三字节组 [2] ＝ 到字节 (位或 (四字节组 [2] × 16, 四字节组 [3] ÷ 4))
        三字节组 [3] ＝ 到字节 (位或 (四字节组 [3] × 64, 四字节组 [4]))
        二进制数据 ＝ 二进制数据 ＋ 到字节集 (三字节组)
        处理事件 ()
    .计次循环尾 ()
    .如果真 (n ＜ 5) ' 最后一组4字符是提前退出的,截取字节集
        n ＝ 5 － n
        二进制数据 ＝ 取字节集左边 (二进制数据, 取字节集长度 (二进制数据) － n)
    .如果真结束
    .如果真 (去除右边空白字节集)
        二进制数据 ＝ 去除右边空字节集 (二进制数据)
    .如果真结束
    返回 (二进制数据)

.子程序 编码_BASE64编码A, 字节集, 公开, Api版，编码_BASE64编码
    .参数 待编码数据, 字节集
    .局部变量 整数_数据长度, 整数型
    .局部变量 整数_编码长度, 整数型
    .局部变量 字节_数据缓存, 字节集

    整数_数据长度 ＝ 取字节集长度 (待编码数据)
    .如果真 (CryptBinaryToStringA (待编码数据, 整数_数据长度, 1 ＋ 1073741824, 字节_数据缓存, 整数_编码长度) ＝ 假)
        返回 ({ })
    .如果真结束
    字节_数据缓存 ＝ 取空白字节集 (整数_编码长度)
    CryptBinaryToStringA (待编码数据, 整数_数据长度, 1 ＋ 1073741824, 字节_数据缓存, 整数_编码长度)
    返回 (去除右边空字节集 (字节_数据缓存))

.子程序 编码_BASE64解码A, 字节集, 公开, Api版，编码_BASE64解码
    .参数 待解码数据, 字节集
    .局部变量 整数_数据长度, 整数型
    .局部变量 整数_解码长度, 整数型
    .局部变量 字节_数据缓存, 字节集

    整数_数据长度 ＝ 取字节集长度 (待解码数据)
    .如果真 (CryptStringToBinaryA (待解码数据, 整数_数据长度, 1, 字节_数据缓存, 整数_解码长度, 0, 0) ＝ 假)
        返回 ({ })
    .如果真结束
    字节_数据缓存 ＝ 取空白字节集 (整数_解码长度)
    CryptStringToBinaryA (待解码数据, 整数_数据长度, 1, 字节_数据缓存, 整数_解码长度, 0, 0)
    返回 (去除右边空字节集 (字节_数据缓存))

.子程序 编码_RC4加密, 字节集, 公开
    .参数 明文, 字节集
    .参数 密钥, 文本型

    返回 (校验_取rc4 (明文, 密钥))

.子程序 编码_RC4解密, 字节集, 公开
    .参数 密文, 字节集
    .参数 密钥, 文本型

    返回 (校验_取rc4 (密文, 密钥))

.子程序 去除右边空字节集, 字节集
    .参数 字节集数据, 字节集
    .局部变量 i, 整数型
    .局部变量 字节集, 字节集

    字节集 ＝ 字节集数据
    .计次循环首 (取字节集长度 (字节集数据), i)
        .如果 (取字节集右边 (字节集, 1) ＝ { 0 })
            字节集 ＝ 取字节集左边 (字节集, 取字节集长度 (字节集) － 1)
        .否则
            跳出循环 ()
        .如果结束
        
    .计次循环尾 ()
    返回 (字节集)

.子程序 编码_简体到繁体, 文本型, 公开, 将简体中文转换成繁体中文；成功返回转换后的繁体内容；
    .参数 简体文本, 文本型, , 欲转换的文本内容
    .局部变量 文本长度, 整数型
    .局部变量 繁体文本, 文本型

    文本长度 ＝ 取文本长度 (简体文本)
    繁体文本 ＝ 取空白文本 (文本长度)
    _文本简繁体转换 (2052, 67108864, 简体文本, 文本长度, 繁体文本, 文本长度)
    返回 (繁体文本)
    ' 第一个参数Locale在这里代表所处理的文本的编码格式，2052为中文GBK编码。
    ' 第二个参数dwMapFlags代表转换目标类型，67108864为到繁体类型，33554432为到简体类型

.子程序 编码_繁体到简体, 文本型, 公开, 将繁体中文转换成简体中文；成功返回转换后的简体内容；
    .参数 繁体文本, 文本型, , 欲转换的文本内容
    .局部变量 文本长度, 整数型
    .局部变量 简体文本, 文本型

    文本长度 ＝ 取文本长度 (繁体文本)
    简体文本 ＝ 取空白文本 (文本长度)
    _文本简繁体转换 (2052, 33554432, 繁体文本, 文本长度, 简体文本, 文本长度)
    返回 (简体文本)

.子程序 编码_usc2到ansi, 文本型, 公开, 将usc2转变成ansi  如 %u0031%u0032%u0033 转换后为 123 失败返回空文本
    .参数 欲转换的文本, 文本型, , \u %u \u25 等3种格式,如果是其它格式,请先用子文本替换成这三种的任意一种才能正常转换
    .局部变量 脚本对象, 对象
    .局部变量 局_文本, 文本型
    .局部变量 局_返回值, 文本型

    局_文本 ＝ 子文本替换 (欲转换的文本, #换行符, “{$}”, , , 真)
    .如果真 (取字节集左边 (到字节集 (取文本左边 (局_文本, 10)), 1) ＝ { 13 })
        局_文本 ＝ 到文本 (子字节集替换 (到字节集 (局_文本), { 13 }, { }, , 1))
    .如果真结束
    .判断开始 (寻找文本 (局_文本, “\u”, , 假) ≠ -1)
        局_文本 ＝ 子文本替换 (局_文本, “\u”, “%u”, , , 真)
    .判断 (寻找文本 (局_文本, “\u25”, , 假) ≠ -1)
        局_文本 ＝ 子文本替换 (局_文本, “\u25”, “%u”, , , 真)
    .默认
        
    .判断结束
    局_文本 ＝ 子文本替换 (局_文本, “'”, “’”, , , 真)
    线程_初始化COM库 ()
    脚本对象.创建 (“ScriptControl”, )
    脚本对象.写属性 (“Language”, “JScript”)
    脚本对象.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ 局_文本 ＋ “';return unescape(x);}”)
    局_返回值 ＝ 脚本对象.文本方法 (“Run”, “xx”)
    局_文本 ＝ 内_编码_Unicode到Ansi_对象 (到字节集 (局_文本))
    局_返回值 ＝ 选择 (取文本长度 (局_返回值) ＝ 0, 局_文本, 局_返回值)
    脚本对象.清除 ()
    线程_取消COM库 ()
    局_返回值 ＝ 子文本替换 (局_返回值, “’”, “'”, , , 真)
    返回 (子文本替换 (局_返回值, “{$}”, #换行符, , , 真))

.子程序 内_编码_Unicode到Ansi_对象, 文本型, , 带BOM头信息编码转换。
    .参数 参_欲转换的内容, 字节集
    .局部变量 变_Dx, 对象
    .局部变量 变_Text, 文本型
    .局部变量 变_btx, 变体型
    .局部变量 变_type, 文本型

    CoInitialize (0)
    变_btx.赋值 (参_欲转换的内容, )
    .如果真 (变_Dx.创建 (“Adodb.Stream”, ) ＝ 假)
        返回 (“”)
    .如果真结束
    变_Dx.写属性 (“Type”, 1)
    变_Dx.写属性 (“Mode”, 3)
    变_Dx.方法 (“Open”, )
    变_Dx.方法 (“Write”, 变_btx)
    变_Dx.写属性 (“Position”, 0)
    变_Dx.写属性 (“Type”, 2)
    变_Dx.写属性 (“Charset”, “unicode”)
    变_Text ＝ 变_Dx.文本方法 (“ReadText”, )
    变_Dx.方法 (“Close”, )
    CoUninitialize ()
    返回 (变_Text)

.子程序 编码_ansi到usc2, 文本型, 公开, 将ansi转变成usc2  如 123 转换后为 %u0031%u0032%u0033 失败返回空文本
    .参数 欲转换的文本, 文本型
    .参数 是否不转换括号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换 { }[ ]( ) 等括号，注意；不处理全角字符串
    .参数 是否不转换符号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换:," 等符号
    .参数 分割符, 文本型, 可空, 可空。默认为：%u  如填：%u,返回的数据如:%u0031%u0032%u0033，填\u，返回的数据如:\u0031\u0032\u0033
    .局部变量 脚本对象, 对象
    .局部变量 局_文本, 文本型

    局_文本 ＝ 子文本替换 (欲转换的文本, “'”, “’”, , , 真)
    线程_初始化COM库 ()
    脚本对象.创建 (“ScriptControl”, )
    脚本对象.写属性 (“Language”, “JScript”)
    脚本对象.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ 局_文本 ＋ “';return escape(x);}”)
    局_文本 ＝ 脚本对象.文本方法 (“Run”, “xx”)
    脚本对象.清除 ()
    线程_取消COM库 ()
    .如果真 (是否不转换括号)
        局_文本 ＝ 子文本替换 (局_文本, “%7B”, “{”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%7D”, “}”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%5B”, “[”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%5D”, “]”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%28”, “(”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%29”, “)”, , , 真)
    .如果真结束
    .如果真 (是否不转换符号)
        局_文本 ＝ 子文本替换 (局_文本, “%3A”, “:”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%2C”, “,”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%22”, #引号, , , 真)
    .如果真结束
    
    .如果真 (分割符 ≠ “%u” 且 删首尾空 (分割符) ≠ “”)
        局_文本 ＝ 子文本替换 (局_文本, “%u”, 分割符, , , 真)
    .如果真结束
    返回 (子文本替换 (局_文本, “’”, “'”, , 取文本长度 (局_文本), 真))

.子程序 编码_usc2到ansi_EX, 文本型, 公开, 将usc2转变成ansi  如 %u0031%u0032%u0033 转换后为 123 失败返回空文本
    .参数 欲转换的文本, 文本型
    .参数 分割符, 文本型, , 如:%u0031%u0032%u0033，分隔符填：%u
    .局部变量 Usc2, 文本型, , , 欲转换的Ucs2编码的16进制文本
    .局部变量 Script, 对象
    .局部变量 sbuffer, 文本型

    Usc2 ＝ 子文本替换 (欲转换的文本, 分割符, “%u”, , , 真)
    CoInitialize (0)
    Script.创建 (“ScriptControl”, )
    Script.写属性 (“Language”, “JScript”)
    Script.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ Usc2 ＋ “';return unescape(x);}”)
    sbuffer ＝ Script.文本方法 (“Run”, “xx”)
    Script.清除 ()
    CoUninitialize ()
    返回 (sbuffer)

.子程序 编码_ansi到usc2_EX, 文本型, 公开, 将ansi转变成usc2   如 123 转换后为 %u0031%u0032%u0033 失败返回空文本
    .参数 欲转换的文本, 文本型
    .参数 分割符, 文本型, , 如填：%u,返回的数据如:%u0031%u0032%u0033
    .参数 是否不转换括号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换 { }[ ]( ) 等括号
    .参数 是否不转换符号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换:," 等符号
    .局部变量 Unicode, 字节集
    .局部变量 len, 整数型
    .局部变量 i, 整数型
    .局部变量 allUsc2, 文本型
    .局部变量 oneUsc2, 文本型, , , EX加强版 由“御风软件”提供

    len ＝ MultiByteToWideChar (0, 0, 取指针文本_ (欲转换的文本), 取文本长度 (欲转换的文本) ＋ 1, 取指针字节集_ (Unicode), 0)
    Unicode ＝ 取空白字节集 (len × 2)
    MultiByteToWideChar (0, 0, 取指针文本_ (欲转换的文本), 取文本长度 (欲转换的文本) ＋ 1, 取指针_字节集型 (Unicode), len × 2)
    .计次循环首 (len － 1, i)
        oneUsc2 ＝ 取文本右边 (“00” ＋ 取十六进制文本 (Unicode [i × 2]), 2) ＋ 取文本右边 (“00” ＋ 取十六进制文本 (Unicode [i × 2 － 1]), 2)
        oneUsc2 ＝ 分割符 ＋ oneUsc2
        allUsc2 ＝ allUsc2 ＋ oneUsc2
    .计次循环尾 ()
    .如果真 (是否不转换括号)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “007B”, “{”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “007D”, “}”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “005B”, “[”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “005D”, “]”, , , 真)
    .如果真结束
    .如果真 (是否不转换符号)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “003A”, “:”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “002C”, “,”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “0022”, #引号, , , 真)
    .如果真结束
    返回 (allUsc2)

.子程序 编码_utf8到gb2312, 文本型, 公开
    .参数 欲转换的源码, 文本型

    返回 (Unicode到Ansi (Ansi到Unicode (欲转换的源码), 936)) ' 从utf8到gb2312

.子程序 编码_utf8到gb2312_字节集, 文本型
    .参数 欲转换的源码, 字节集

    返回 (Unicode到Ansi (Ansi到Unicode_字节集 (欲转换的源码), 936)) ' 从utf8到gb2312

.子程序 编码_gb2312到utf8, 文本型, 公开
    .参数 欲转换的源码, 文本型

    
    返回 (Unicode到Ansi (Ansi到Unicode (欲转换的源码, 936), 65001)) ' 从utf8到gb2312

.子程序 编码_ASCII到Unicode, 字节集, 公开, 将ASCII码转换为Unicode码；成功返回转换后的字节集；
    .参数 ASCII文本, 文本型, , 欲转换的ASCII文本
    .局部变量 Unicode长度, 整数型, , , 单位: Word
    .局部变量 Unicode字节集, 字节集

    Unicode长度 ＝ MultiByteToWideChar (936, 0, 取指针文本_ (ASCII文本), -1, 0, 0)
    ' 936 表示简体中文代码页; -1 表示以"0"作为文本终止符
    ' 如果要去掉转换后Unicode字节集末尾的{0,0}，则Unicode长度再减去1
    Unicode字节集 ＝ 取空白字节集 (Unicode长度 × 2)
    MultiByteToWideChar (936, 0, 取指针文本_ (ASCII文本), -1, 取指针_字节集型 (Unicode字节集), Unicode长度)
    返回 (Unicode字节集)

.子程序 编码_U编码转换, 文本型, 公开, 默认转换类型为to16un
    .参数 要转的文本, 文本型
    .参数 转换类型, 文本型, 可空, to16on to16un to10on to10un
    .局部变量 js, 类_脚本组件

    .如果真 (是否为空 (转换类型))
        转换类型 ＝ “to16un”
    .如果真结束
    js.执行 (#U码)
    返回 (js.运行 (转换类型, 要转的文本))

.子程序 编码_Unicode到Ansi, 文本型, 公开, 将Unicode码转换为Ansi码；成功返回转换后的文本；
    .参数 Unicode, 字节集, , 欲转换的Unicode字节集
    .局部变量 局_计数, 整数型
    .局部变量 局_结果数据, 字节集
    .局部变量 局_结果文本, 文本型

    局_计数 ＝ 取字节集长度 (Unicode) ÷ 2 ' 字符数目两个
    局_计数 ＝ WideCharToMultiByte (936, 512, 取指针_字节集型 (Unicode), 局_计数, 0, 0, 0, 0) ' 取转换后的数目
    局_结果数据 ＝ 取空白字节集 (局_计数)
    WideCharToMultiByte (936, 512, 取指针_字节集型 (Unicode), -1, 取指针_字节集型 (局_结果数据), 局_计数, 0, 0)
    局_结果文本 ＝ 取字节集数据 (局_结果数据, #文本型, )
    返回 (局_结果文本)

.子程序 编码_Unicode到Ansi_对象, 文本型, 公开, 带BOM头信息编码转换。
    .参数 欲转换的文本, 字节集
    .局部变量 Dx, 对象
    .局部变量 Text, 文本型
    .局部变量 btx, 变体型
    .局部变量 type, 文本型

    CoInitialize (0)
    btx.赋值 (欲转换的文本, )
    .如果真 (Dx.创建 (“Adodb.Stream”, ) ＝ 假)
        返回 (“”)
    .如果真结束
    Dx.写属性 (“Type”, 1)
    Dx.写属性 (“Mode”, 3)
    Dx.方法 (“Open”, )
    Dx.方法 (“Write”, btx)
    Dx.写属性 (“Position”, 0)
    Dx.写属性 (“Type”, 2)
    Dx.写属性 (“Charset”, “unicode”)
    Text ＝ Dx.文本方法 (“ReadText”, )
    Dx.方法 (“Close”, )
    CoUninitialize ()
    返回 (Text)

.子程序 编码_Ansi到Unicode, 字节集, 公开, 将Ansi码转换为Unicode码；成功返回转换后的字节集；
    .参数 Ansi, 文本型, , 欲转换的Ansi文本
    .参数 非标准Unicode编码, 逻辑型, 可空, 默认为假，为标准Unicode编码
    .局部变量 数据2, 字节集
    .局部变量 长度, 整数型

    .如果真 (Ansi ＝ “”)
        返回 ({ })
    .如果真结束
    长度 ＝ MultiByteToWideChar (0, 0, 取指针文本_ (Ansi), -1, 0, 0)
    数据2 ＝ 取空白字节集 (长度 × 2)
    MultiByteToWideChar (936, 0, 取指针文本_ (Ansi), -1, 取指针_字节集型 (数据2), 长度 × 2)
    .如果真 (非标准Unicode编码)
        数据2 ＝ 取字节集左边 (数据2, 取字节集长度 (数据2) － 2)
    .如果真结束
    返回 (数据2)

.子程序 编码_Unicode到Ansi_文本型, 文本型, 公开, 将Unicode码转换为Ansi码，成功返回转换后的文本。
    .参数 UniCode文本, 文本型, , 欲转换的Unicode文本，如：“&#31934&#26131&#-29766&#22363”
    .局部变量 局_计数, 整数型
    .局部变量 局_结果数据, 字节集
    .局部变量 局_结果文本, 文本型
    .局部变量 Unicode, 字节集
    .局部变量 数组, 文本型, , "0"

    数组 ＝ 分割文本 (UniCode文本, “&#”, )
    删除成员 (数组, 1, 1)
    .计次循环首 (取数组成员数 (数组), 局_计数)
        Unicode ＝ Unicode ＋ 到字节集 (到短整数 (数组 [局_计数]))
    .计次循环尾 ()
    局_计数 ＝ 取字节集长度 (Unicode) ÷ 2 ' 字符数目两个
    局_计数 ＝ WideCharToMultiByte (936, 512, 取指针_字节集型 (Unicode), 局_计数, 0, 0, 0, 0) ' 取转换后的数目
    局_结果数据 ＝ 取空白字节集 (局_计数)
    WideCharToMultiByte (936, 512, 取指针_字节集型 (Unicode), -1, 取指针_字节集型 (局_结果数据), 局_计数, 0, 0)
    局_结果文本 ＝ 取字节集数据 (局_结果数据, #文本型, )
    返回 (局_结果文本)
    

.子程序 编码_Ansi到Unicode_文本型, 文本型, 公开, 将Ansi码转换为Unicode码，如：将“精易论坛”转换后将返回格式如：“&#31934&#26131&#-29766&#22363”
    .参数 Ansi, 文本型, , 欲转换的文本，如：“精易论坛”。
    .局部变量 局_文本, 文本型
    .局部变量 数据2, 字节集
    .局部变量 长度, 整数型
    .局部变量 i, 整数型

    .如果真 (删首尾空 (Ansi) ＝ “”)
        返回 (“”)
    .如果真结束
    长度 ＝ MultiByteToWideChar (936, 0, 取指针文本_ (Ansi), -1, 0, 0)
    数据2 ＝ 取空白字节集 (长度 × 2)
    MultiByteToWideChar (936, 0, 取指针文本_ (Ansi), -1, 取指针_字节集型 (数据2), 长度 × 2)
    数据2 ＝ 取字节集左边 (数据2, 取字节集长度 (数据2) － 2)
    .变量循环首 (1, 取字节集长度 (数据2), 2, i)
        局_文本 ＝ 局_文本 ＋ “&#” ＋ 到文本 (取字节集数据 (取字节集中间 (数据2, i, 2), #整数型, ))
    .变量循环尾 ()
    返回 (局_文本)

.子程序 编码_Ansi到ASCII_文本型, 文本型, 公开, 此代码由易友【菜虫】提供， 将Ansi码转换为ASCII码，如：将“精易论坛”转换后将返回格式如：“&#48811&#53975&#49883&#52403”
    .参数 Ansi, 文本型, , 欲转换的文本，如：“精易论坛”。
    .局部变量 长度, 整数型
    .局部变量 i, 小数型
    .局部变量 长度2, 整数型
    .局部变量 数据, 字节集
    .局部变量 局_文本, 文本型

    .如果真 (删首尾空 (Ansi) ＝ “”)
        返回 (“”)
    .如果真结束
    
    长度 ＝ 1
    .循环判断首 ()
        i ＝ i ＋ 1
        长度2 ＝ 取文本长度 (Ansi)
        数据 ＝ 到字节集 (取文本中间 (Ansi, i × 2 － 长度, 2))
        .如果 (数据 [1] ＜ 128)
            长度 ＝ 1 ＋ 长度
            局_文本 ＝ 局_文本 ＋ “&#” ＋ 到文本 (数据 [1])
        .否则
            局_文本 ＝ 局_文本 ＋ “&#” ＋ 到文本 (数据 [1] × 256 ＋ 数据 [2])
        .如果结束
        
    .循环判断尾 (i × 2 － 长度 ＋ 1 ＜ 取文本长度 (Ansi))
    
    返回 (局_文本)
    

.子程序 编码_Utf8到Unicode, 字节集, 公开, 将UTF8数据转换到Unicode
    .参数 utf8字节集, 字节集
    .局部变量 局_长度, 整数型
    .局部变量 局_地址, 整数型
    .局部变量 局_地址长度, 整数型
    .局部变量 局_指针, 整数型
    .局部变量 局_字符长, 整数型
    .局部变量 局_Unicode, 字节集

    局_长度 ＝ 取字节集长度 (utf8字节集)
    局_地址 ＝ 取指针字节集_ (utf8字节集)
    局_地址长度 ＝ lstrlenA (局_地址) ＋ 1
    .如果真 (0 ≤ 局_地址长度 且 局_地址长度 ≤ 局_长度)
        局_长度 ＝ 局_地址长度
    .如果真结束
    局_指针 ＝ A2W_指针 (局_地址, 局_长度, 65001, 局_字符长)
    局_Unicode ＝ 取空白字节集 (局_字符长 × 2)
    RtlMoveMemory (取指针字节集_ (局_Unicode), 局_指针, 局_字符长 × 2)
    HeapFree (GetProcessHeap (), 0, 局_指针)
    返回 (局_Unicode)

.子程序 编码_Unicode到Utf8, 字节集, 公开, 将Unicode转换到UTF8
    .参数 Unicode字节集, 字节集
    .局部变量 局_字节长度, 整数型
    .局部变量 局_地址, 整数型
    .局部变量 局_地址长度, 整数型
    .局部变量 局_指针, 整数型
    .局部变量 局_字符长, 整数型
    .局部变量 局_Utf8, 字节集

    局_字节长度 ＝ 取字节集长度 (Unicode字节集) ÷ 2
    局_地址 ＝ 取指针字节集_ (Unicode字节集)
    局_地址长度 ＝ lstrlenW (局_地址)
    .如果真 (0 ≤ 局_地址长度 且 局_地址长度 ≤ 局_字节长度)
        局_字节长度 ＝ 局_地址长度
    .如果真结束
    局_指针 ＝ W2A_指针 (局_地址, 局_字节长度, 65001, 局_字符长)
    局_Utf8 ＝ 取空白字节集 (局_字符长)
    RtlMoveMemory (取指针字节集_ (局_Utf8), 局_指针, 局_字符长)
    HeapFree (GetProcessHeap (), 0, 局_指针)
    返回 (局_Utf8)

.子程序 编码_Ansi到Utf8, 字节集, 公开
    .参数 ansi文本, 文本型
    .局部变量 局_临时, 字节集

    局_临时 ＝ 编码_Ansi到Unicode (ansi文本, )
    返回 (编码_Unicode到Utf8 (局_临时))
    

.子程序 编码_Ansi到Utf8_对象, 字节集, 公开
    .参数 文本, 文本型
    .局部变量 stream, 对象
    .局部变量 string, 变体型

    线程_初始化COM库 ()
    .如果真 (stream.创建 (“adodb.stream”, ) ＝ 假)
        返回 ({ })
    .如果真结束
    stream.写属性 (“Type”, 2) ' text
    stream.写属性 (“Charset”, “utf-8”)
    stream.方法 (“Open”, )
    stream.方法 (“WriteText”, 文本)
    stream.写属性 (“Position”, 0)
    stream.写属性 (“Type”, 1) ' 二进制
    string ＝ stream.通用方法 (“Read”, stream.读数值属性 (“Size”, ))
    stream.方法 (“Close”, )
    线程_取消COM库 ()
    返回 (string.取字节集 ())

.子程序 编码_Utf8到Ansi, 文本型, 公开
    .参数 utf8字节集, 字节集
    .局部变量 局_长度, 整数型
    .局部变量 Length, 整数型
    .局部变量 Unicode, 字节集
    .局部变量 unicode_len, 整数型
    .局部变量 ansi_len, 整数型
    .局部变量 ansi, 文本型
    .局部变量 局_指针, 整数型

    .如果真 (utf8字节集 ＝ { })
        返回 (“”)
    .如果真结束
    局_长度 ＝ 取字节集长度 (utf8字节集)
    局_指针 ＝ 取指针_字节集型 (utf8字节集)
    Length ＝ MultiByteToWideChar (65001, 0, 局_指针, 局_长度, 0, 0) × 2
    Unicode ＝ 取空白字节集 (Length ＋ 2)
    MultiByteToWideChar (65001, 0, 局_指针, 局_长度, 取指针_字节集型 (Unicode), Length)
    局_指针 ＝ 取指针_字节集型 (Unicode)
    unicode_len ＝ 取字节集长度 (Unicode) ÷ 2
    ansi_len ＝ WideCharToMultiByte (936, 0, 局_指针, unicode_len, lstrlenW (局_指针), 0, 0, 0)
    ansi ＝ 取空白文本 (ansi_len)
    WideCharToMultiByte (936, 0, 局_指针, unicode_len, 取指针_文本型 (ansi), ansi_len, 0, 0)
    返回 (ansi)
    

.子程序 编码_Utf8到Ansi_对象, 文本型, 公开
    .参数 欲转换的文本, 字节集
    .局部变量 Dx, 对象
    .局部变量 Text, 文本型
    .局部变量 btx, 变体型
    .局部变量 type, 文本型

    CoInitialize (0)
    btx.赋值 (欲转换的文本, )
    .如果真 (Dx.创建 (“Adodb.Stream”, ) ＝ 假)
        返回 (“”)
    .如果真结束
    Dx.写属性 (“Type”, 1)
    Dx.写属性 (“Mode”, 3)
    Dx.方法 (“Open”, )
    Dx.方法 (“Write”, btx)
    Dx.写属性 (“Position”, 0)
    Dx.写属性 (“Type”, 2)
    Dx.写属性 (“Charset”, “UTF-8”)
    Text ＝ Dx.文本方法 (“ReadText”, )
    Dx.方法 (“Close”, )
    CoUninitialize ()
    返回 (Text)

.子程序 编码_BIG5到繁体, 文本型, 公开
    .参数 待转换文本, 文本型
    .局部变量 len, 整数型, , , 单位: Word
    .局部变量 Unicode字节集, 字节集
    .局部变量 unicode_len
    .局部变量 结果文本, 文本型

    len ＝ MultiByteToWideChar (950, 0, 取指针文本_ (待转换文本), -1, 0, 0)
    Unicode字节集 ＝ 字节集_取空白字节集 (len × 2)
    MultiByteToWideChar (950, 0, 取指针文本_ (待转换文本), -1, 取指针_字节集型 (Unicode字节集), len × 2)
    unicode_len ＝ 取字节集长度 (Unicode字节集) ÷ 2
    len ＝ WideCharToMultiByte (936, 0, 取指针_字节集型 (Unicode字节集), unicode_len, 取指针_文本型 (结果文本), 0, 0, 0)
    结果文本 ＝ 文本_取空白文本 (len)
    WideCharToMultiByte (936, 0, 取指针_字节集型 (Unicode字节集), unicode_len, 取指针_文本型 (结果文本), len, 0, 0)
    返回 (结果文本)

.子程序 编码_BIG5到简体, 文本型, 公开
    .参数 待转换文本, 文本型

    返回 (编码_繁体到简体 (编码_BIG5到繁体 (待转换文本)))

.子程序 编码_繁体到BIG5, 文本型, 公开
    .参数 待转换文本, 文本型
    .局部变量 len, 整数型, , , 单位: Word
    .局部变量 Unicode字节集, 字节集
    .局部变量 unicode_len
    .局部变量 结果文本, 文本型

    len ＝ MultiByteToWideChar (936, 0, 取指针文本_ (待转换文本), -1, 0, 0)
    Unicode字节集 ＝ 字节集_取空白字节集 (len × 2)
    MultiByteToWideChar (936, 0, 取指针文本_ (待转换文本), -1, 取指针_字节集型 (Unicode字节集), len × 2)
    ' ////////////////////
    unicode_len ＝ 取字节集长度 (Unicode字节集) ÷ 2
    len ＝ WideCharToMultiByte (950, 0, 取指针_字节集型 (Unicode字节集), unicode_len, 取指针_文本型 (结果文本), 0, 0, 0)
    结果文本 ＝ 文本_取空白文本 (len)
    WideCharToMultiByte (950, 0, 取指针_字节集型 (Unicode字节集), unicode_len, 取指针_文本型 (结果文本), len, 0, 0)
    返回 (结果文本)
    

.子程序 编码_简体到BIG5, 文本型, 公开
    .参数 待转换文本, 文本型

    返回 (编码_繁体到BIG5 (编码_简体到繁体 (待转换文本)))

.子程序 编码_Ansi到Unicode_JS, 文本型, 公开
    .参数 待转文本, 文本型
    .局部变量 script, 对象
    .局部变量 ret, 文本型
    .局部变量 str, 文本型

    ' https://bbs.125.la/thread-14448656-1-1.html
    CoInitialize (0)
    script.创建 (“scriptcontrol”, )
    script.写属性 (“Language”, “JScript”)
    str ＝ “var Unicode = function(str){return escape(str).replace(/%/g,” ＋ #引号 ＋ “\\” ＋ #引号 ＋ “).toLowerCase();}”
    script.文本方法 (“Eval”, str)
    ret ＝ script.文本方法 (“Run”, “Unicode”, 待转文本)
    CoUninitialize ()
    返回 (ret)

.子程序 编码_Unicode到Ansi_JS, 文本型, 公开
    .参数 待转文本, 文本型
    .局部变量 script, 对象
    .局部变量 ret, 文本型
    .局部变量 str, 文本型

    ' https://bbs.125.la/thread-14448656-1-1.html
    CoInitialize (0)
    script.创建 (“scriptcontrol”, )
    script.写属性 (“Language”, “JScript”)
    str ＝ “var unUnicode = function(str){return unescape(str.replace(/\\/g,” ＋ #引号 ＋ “%” ＋ #引号 ＋ “));}”
    script.文本方法 (“Eval”, str)
    ret ＝ script.文本方法 (“Run”, “unUnicode”, 待转文本)
    CoUninitialize ()
    返回 (ret)

.子程序 分隔子程序0, , , ●●●●●●●●●●●●●●●●●●进制转换●●●●●●●●●●●●●●●●●●
    

.子程序 进制_二到十, 整数型, 公开, 将二进制转换成十进制(返回十进制整数)
    .参数 二进制文本, 文本型, , 欲转换的二进制
    .局部变量 计次, 整数型
    .局部变量 结果, 整数型

    .计次循环首 (取文本长度 (二进制文本), 计次)
        .判断开始 (到数值 (取文本中间 (二进制文本, 计次, 1)) ＜ 10)
            结果 ＝ 结果 ＋ 到数值 (取文本中间 (二进制文本, 计次, 1)) × 求次方 (2, 取文本长度 (二进制文本) － 计次)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (结果)

.子程序 进制_十到二, 文本型, 公开, 支持负数，源码由论坛用户【藤未枯】修改
    .参数 十进制数, 整数型
    .局部变量 结果, 文本型
    .局部变量 余数, 整数型
    .局部变量 原码, 文本型
    .局部变量 长度, 整数型
    .局部变量 反码, 文本型
    .局部变量 i, 整数型
    .局部变量 转换, 文本型
    .局部变量 数组, 整数型, , "0"
    .局部变量 补位长度, 整数型
    .局部变量 补位, 文本型
    .局部变量 成员数, 整数型

    .如果真 (十进制数 ＜ 0)
        原码 ＝ 进制_十到二 (取绝对值 (十进制数))
        长度 ＝ 取文本长度 (原码)
        补位长度 ＝ 64 － 长度
        i ＝ 0
        .计次循环首 (补位长度, i)
            补位 ＝ 补位 ＋ “0”
        .计次循环尾 ()
        原码 ＝ 补位 ＋ 原码
        长度 ＝ 取文本长度 (原码)
        i ＝ 0
        .计次循环首 (长度, i)
            转换 ＝ 取文本中间 (原码, i, 1)
            .如果 (转换 ＝ “0”)
                转换 ＝ “1”
            .否则
                转换 ＝ “0”
            .如果结束
            反码 ＝ 反码 ＋ 转换
        .计次循环尾 ()
        长度 ＝ 取文本长度 (反码)
        i ＝ 0
        重定义数组 (数组, 假, 长度)
        .计次循环首 (长度, i)
            数组 [i] ＝ 到整数 (取文本中间 (反码, i, 1))
        .计次循环尾 ()
        i ＝ 0
        数组 [长度] ＝ 数组 [长度] ＋ 1
        .计次循环首 (长度, i)
            .如果真 (数组 [长度 － i ＋ 1] ＝ 2)
                数组 [长度 － i ＋ 1] ＝ 0
                数组 [长度 － i] ＝ 数组 [长度 － i] ＋ 1
            .如果真结束
            
        .计次循环尾 ()
        
        成员数 ＝ 取数组成员数 (数组)
        i ＝ 0
        .计次循环首 (成员数, i)
            结果 ＝ 结果 ＋ 到文本 (数组 [i])
        .计次循环尾 ()
        返回 (结果)
    .如果真结束
    
    
    .判断循环首 (十进制数 ＞ 1)
        余数 ＝ 十进制数 ％ 2
        十进制数 ＝ 十进制数 ÷ 2
        结果 ＝ 到文本 (余数) ＋ 结果
    .判断循环尾 ()
    结果 ＝ 到文本 (十进制数) ＋ 结果
    返回 (结果)

.子程序 进制_八到十, 整数型, 公开, 将八进制转换成十进制(返回十进制整数)
    .参数 八进制文本, 文本型, , 欲转换的八进制文本
    .局部变量 计次, 整数型
    .局部变量 结果, 整数型

    .计次循环首 (取文本长度 (八进制文本), 计次)
        结果 ＝ 结果 ＋ 到数值 (取文本中间 (八进制文本, 计次, 1)) × 求次方 (8, 取文本长度 (八进制文本) － 计次)
    .计次循环尾 ()
    返回 (结果)

.子程序 进制_十到八, 文本型, 公开, 将十进制转换成八进制(返回八进制文本)
    .参数 十进制数, 长整数型, , 欲转换的十进制数
    .局部变量 余数, 长整数型, , "0"
    .局部变量 八进制文本, 文本型
    .局部变量 计次, 整数型

    .循环判断首 ()
        加入成员 (余数, 十进制数 ％ 8)
        十进制数 ＝ 十进制数 ÷ 8
        .如果真 (十进制数 ＜ 8)
            加入成员 (余数, 取整 (十进制数))
            跳出循环 ()
        .如果真结束
        
    .循环判断尾 (真)
    .计次循环首 (取数组成员数 (余数), 计次)
        八进制文本 ＝ 八进制文本 ＋ 到文本 (余数 [取数组成员数 (余数) － 计次 ＋ 1])
    .计次循环尾 ()
    .如果真 (取文本左边 (八进制文本, 1) ＝ “0”)
        八进制文本 ＝ 转换去除首部零 (八进制文本)
    .如果真结束
    返回 (八进制文本)

.子程序 进制_十到十六, 文本型, 公开, 十进制到十六进制（支持负数）,源码作者：QQ418995189
    .参数 十进制长整数, 长整数型, , 不支持无符号长整数型，易BUG，超过15位长整数型，不能直接使用，必须 用 到长整数()转换
    .参数 是否在前端补零, 逻辑型, 可空, 如果为真，则自动在前面补0，补足位数。如果为假，则不补零；默认为假
    .局部变量 局部_低32位, 整数型, , , ebp-0x8
    .局部变量 局部_高32位, 整数型, , , ebp-0xc
    .局部变量 局部_结果, 文本型, , , ebp-0x4
    .局部变量 零的个数, 整数型
    .局部变量 i, 整数型
    .局部变量 是否为长整数, 逻辑型

    置入代码 ({ 139, 69, 8, 137, 69, 248, 139, 69, 12, 137, 69, 244 })
    ' mov eax,[ebp+0x08]
    ' mov [ebp-0x08],eax
    ' mov eax,[ebp+0x0c]
    ' mov [ebp-0x0c],eax
    局部_结果 ＝ _十进制 (局部_低32位)
    .如果真 (局部_高32位 ≠ 0)
        局部_结果 ＝ _十进制 (局部_高32位) ＋ 局部_结果
        是否为长整数 ＝ 真
    .如果真结束
    
    .如果 (是否在前端补零 ＝ 假)
        .计次循环首 (取文本长度 (局部_结果), i)
            .如果 (取文本中间 (局部_结果, i, 1) ＝ “0”)
                零的个数 ＝ 零的个数 ＋ 1
            .否则
                跳出循环 ()
            .如果结束
            
        .计次循环尾 ()
        局部_结果 ＝ 取文本右边 (局部_结果, 取文本长度 (局部_结果) － 零的个数)
        ' 去掉前面所有的0
    .否则
        .如果真 (是否为长整数 ＝ 真)
            局部_结果 ＝ 取重复文本 (16 － 取文本长度 (局部_结果), “0”) ＋ 局部_结果
        .如果真结束
        
    .如果结束
    
    返回 (局部_结果)

.子程序 进制_十六到十, 长整数型, 公开, 感谢【@haishifu 】优化
    .参数 参_十六进制文本, 文本型, , 字母不区分大小写
    .局部变量 局_十六进制文本字节集, 字节集
    .局部变量 局_十六进制缓冲, 字节集
    .局部变量 局_记录, 整数型
    .局部变量 局_长度, 整数型
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_高位, 整数型
    .局部变量 局_低位, 整数型
    .局部变量 局_结果, 长整数型

    局_十六进制文本字节集 ＝ 到字节集 (参_十六进制文本)
    局_长度 ＝ 取字节集长度 (局_十六进制文本字节集)
    
    局_十六进制缓冲 ＝ 取空白字节集 (16)
    局_记录 ＝ 16
    
    .计次循环首 (局_长度, i)
        局_字节 ＝ 局_十六进制文本字节集 [局_长度 － i ＋ 1]
        .判断开始 (局_字节 ＞ 47 且 局_字节 ＜ 58)
            局_十六进制缓冲 [局_记录] ＝ 局_字节 － 48
            局_记录 ＝ 局_记录 － 1
            
        .判断 (局_字节 ＞ 64 且 局_字节 ＜ 71)
            局_十六进制缓冲 [局_记录] ＝ 局_字节 － 55
            局_记录 ＝ 局_记录 － 1
            
        .判断 (局_字节 ＞ 96 且 局_字节 ＜ 103)
            局_十六进制缓冲 [局_记录] ＝ 局_字节 － 87
            局_记录 ＝ 局_记录 － 1
        .默认
            
        .判断结束
        
        .如果真 (局_记录 ＜ 1)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    
    局_低位 ＝ 局_十六进制缓冲 [9] × 268435456 ＋ 局_十六进制缓冲 [10] × 16777216 ＋ 局_十六进制缓冲 [11] × 1048576 ＋ 局_十六进制缓冲 [12] × 65536 ＋ 局_十六进制缓冲 [13] × 4096 ＋ 局_十六进制缓冲 [14] × 256 ＋ 局_十六进制缓冲 [15] × 16 ＋ 局_十六进制缓冲 [16]
    
    局_高位 ＝ 局_十六进制缓冲 [1] × 268435456 ＋ 局_十六进制缓冲 [2] × 16777216 ＋ 局_十六进制缓冲 [3] × 1048576 ＋ 局_十六进制缓冲 [4] × 65536 ＋ 局_十六进制缓冲 [5] × 4096 ＋ 局_十六进制缓冲 [6] × 256 ＋ 局_十六进制缓冲 [7] × 16 ＋ 局_十六进制缓冲 [8]
    
    内部_汇编复制内存 (取指针_通用型 (局_结果) ＋ 4, 取指针_通用型 (局_高位), 4)
    内部_汇编复制内存 (取指针_通用型 (局_结果), 取指针_通用型 (局_低位), 4)
    返回 (局_结果)
    

.子程序 进制_十六到十_汇编, 整数型, 公开, 遇到错误时终止；作者混沌（QQ 1339307648）
    .参数 十六进制, 文本型

    ' 该命令收录自：https://bbs.125.la/thread-14334303-1-1.html
    置入代码 ({ 49, 192, 139, 93, 8, 139, 27, 133, 219, 116, 55, 49, 210, 138, 19, 67, 128, 250, 57, 119, 10, 128, 250, 48, 114, 5, 128, 234, 48, 235, 28, 128, 250, 70, 119, 10, 128, 250, 65, 114, 5, 128, 234, 55, 235, 13, 128, 250, 102, 119, 15, 128, 250, 97, 114, 10, 128, 234, 87, 193, 224, 4, 1, 208, 235, 203, 93, 194, 4, 0 })
    返回 (0)

.子程序 内部_汇编复制内存
    .参数 目的地址, 整数型, , 缓冲区长度需大于或等于长度
    .参数 源地址, 整数型
    .参数 长度, 整数型

    置入代码 ({ 96, 139, 77, 16, 139, 125, 8, 139, 117, 12, 243, 164, 97 })
    

.子程序 _十进制, 文本型
    .参数 十进制整数, 整数型
    .局部变量 ret, 文本型

    ret ＝ 取空白文本 (8)
    置入代码 ({ 139, 69, 8, 87, 139, 125, 252, 49, 201, 177, 8, 80, 36, 15, 60, 9, 119, 4, 4, 48, 235, 2, 4, 55, 136, 68, 15, 255, 88, 193, 232, 4, 226, 233, 95 })
    ' mov eax,dword[ebp+0x8]
    ' push edi
    ' mov edi,dword[ebp-4]
    ' xor ecx,ecx
    ' mov cl ,byte 8
    ' a:
    ' push eax
    ' and al,0xf
    ' cmp al,byte 9
    ' ja b
    ' add al, 48 ;数字
    ' jmp short c
    ' b:
    ' add al,55 ;字母
    ' c:
    ' mov byte [edi+ecx-1], al
    ' pop eax
    ' shr eax,4 ;右移4位 相当于除以16
    ' loop a
    ' pop edi
    返回 (ret)

.子程序 _十六进制, 整数型
    .参数 十六进制文本, 文本型
    .局部变量 局部_十六进制, 字节集
    .局部变量 局部_计次, 整数型
    .局部变量 局部_十六进制数, 整数型
    .局部变量 局部_结果, 整数型

    局部_十六进制 ＝ 到字节集 (十六进制文本)
    .计次循环首 (取字节集长度 (局部_十六进制), 局部_计次)
        .判断开始 (局部_十六进制 [局部_计次] ≥ 97) ' 十六进制 [计次] ≤ 102
            局部_十六进制数 ＝ 局部_十六进制 [局部_计次] － 87 ' 小写
        .判断 (局部_十六进制 [局部_计次] ≥ 65) ' 十六进制 [计次] ≤ 70
            局部_十六进制数 ＝ 局部_十六进制 [局部_计次] － 55 ' 大写
        .默认
            局部_十六进制数 ＝ 局部_十六进制 [局部_计次] － 48 ' 数字
        .判断结束
        局部_结果 ＝ 左移 (局部_结果, 4) ＋ 局部_十六进制数 ' 左移4位 相当于乘以16
    .计次循环尾 ()
    返回 (局部_结果)

.子程序 转换去除首部零, 文本型
    .参数 文本, 文本型
    .局部变量 计次, 整数型

    .计次循环首 (取文本长度 (文本), 计次)
        .如果真 (取文本中间 (文本, 计次, 1) ≠ “0”)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (取文本右边 (文本, 取文本长度 (文本) － 计次 ＋ 1))

.子程序 进制_二八十六到十, 整数型, 公开, 将非十进制的标准格式文本转换成十进制整数值
    .参数 欲转换的值, 文本型, , 欲转换的值，文本型！
    .参数 数值类型, 整数型, 可空, 0，#十六进制；1，#十进制（默认）；2，#八进制；3，#二进制
    .局部变量 s, 整数型, , , 最终结果
    .局部变量 a, 整数型, , , 中间变量
    .局部变量 b, 整数型, , , 中间变量
    .局部变量 c, 文本型, , , 中间变量
    .局部变量 d, 整数型, , , 中间变量

    欲转换的值 ＝ 到小写 (欲转换的值)
    .如果真 (是否为空 (数值类型))
        数值类型 ＝ 1
    .如果真结束
    s ＝ 0
    .判断开始 (数值类型 ＝ 0)
        a ＝ 取文本长度 (欲转换的值)
        .变量循环首 (1, a, 1, b)
            c ＝ 取文本中间 (欲转换的值, a － b ＋ 1, 1)
            .如果真 (取代码 (c, ) ≤ 取代码 (“f”, ) 且 取代码 (c, ) ≥ 取代码 (“a”, ) 或 (取代码 (c, ) ≤ 取代码 (“F”, ) 且 取代码 (c, ) ≥ 取代码 (“A”, )))
                .如果真 (取代码 (c, ) ≥ 取代码 (“A”, ) 且 取代码 (c, ) ≤ 取代码 (“F”, ))
                    d ＝ 取代码 (c, ) － 取代码 (“A”, ) ＋ 10
                .如果真结束
                .如果真 (取代码 (c, ) ≥ 取代码 (“a”, ) 且 取代码 (c, ) ≤ 取代码 (“f”, ))
                    d ＝ 取代码 (c, ) － 取代码 (“a”, ) ＋ 10
                .如果真结束
                
            .如果真结束
            .如果真 (取代码 (c, ) ≤ 取代码 (“9”, ) 且 取代码 (c, ) ≥ 取代码 (“0”, ))
                d ＝ 到数值 (c)
            .如果真结束
            s ＝ s ＋ 求次方 (16, b － 1) × d
        .变量循环尾 ()
    .默认
        
    .判断结束
    .判断开始 (数值类型 ＝ 1)
        s ＝ 到数值 (欲转换的值)
    .默认
        
    .判断结束
    .判断开始 (数值类型 ＝ 2)
        a ＝ 取文本长度 (欲转换的值)
        .变量循环首 (1, a, 1, b)
            c ＝ 取文本中间 (欲转换的值, a － b ＋ 1, 1)
            .如果真 (取代码 (c, ) ≤ 取代码 (“7”, ) 且 取代码 (c, ) ≥ 取代码 (“0”, ))
                d ＝ 到数值 (c)
            .如果真结束
            s ＝ s ＋ 求次方 (8, b － 1) × d
        .变量循环尾 ()
    .默认
        
    .判断结束
    .判断开始 (数值类型 ＝ 3)
        a ＝ 取文本长度 (欲转换的值)
        .变量循环首 (1, a, 1, b)
            c ＝ 取文本中间 (欲转换的值, a － b ＋ 1, 1)
            .如果真 (取代码 (c, ) ≤ 取代码 (“1”, ) 且 取代码 (c, ) ≥ 取代码 (“0”, ))
                d ＝ 到数值 (c)
            .如果真结束
            s ＝ s ＋ 求次方 (2, b － 1) × d
        .变量循环尾 ()
    .默认
        
    .判断结束
    返回 (s)

.子程序 进制_十六进制转有符号的十进制, 整数型, 公开, D0 -> -48
    .参数 十六进制, 文本型

    返回 (位异或 (进制_十六到十 (十六进制), 128) － 128)

.子程序 进制_有符号的十进制转十六进制, 文本型, 公开, -48 -> D0
    .参数 有符号的十进制, 整数型

    返回 (进制_十到十六 (位或 (有符号的十进制 ＋ 128, 128)))

.子程序 分隔子程序1, , , ●●●●●●●●●●●●●●●●●●校验●●●●●●●●●●●●●●●●●●
    

.子程序 MD过程, 文本型
    .参数 x, 字节集
    .参数 种类, 整数型
    .参数 长度, 整数型
    .局部变量 hCryptProv, 整数型
    .局部变量 hKey, 整数型
    .局部变量 hHash, 整数型
    .局部变量 pbBuffer, 字节集
    .局部变量 cbHash, 整数型
    .局部变量 rgbHash, 字节集
    .局部变量 rgbDigits, 字节集
    .局部变量 局_MD5, 字节集
    .局部变量 b, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型

    .如果真 (CryptAcquireContextA (hCryptProv, “”, “”, 1, -268435456) ＝ 0)
        .如果真 (CryptAcquireContextA (hCryptProv, “”, “”, 1, 0) ＝ 0)
            返回 (“”)
        .如果真结束
        
    .如果真结束
    
    .如果 (CryptCreateHash (hCryptProv, 种类, hKey, 0, hHash) ＝ 0)
        CryptReleaseContext (hCryptProv, 0)
        返回 (“”)
    .否则
        pbBuffer ＝ x
        len ＝ 取字节集长度 (x)
        .如果 (CryptHashData (hHash, pbBuffer, len, 0) ＝ 0)
            CryptDestroyHash (hHash)
            CryptReleaseContext (hCryptProv, 0)
            返回 (“”)
            
        .否则
            rgbHash ＝ 取空白字节集 (长度)
            cbHash ＝ 长度
            .如果 (CryptGetHashParam (hHash, 2, rgbHash, cbHash, 0) ＝ 0)
                CryptDestroyHash (hHash)
                CryptReleaseContext (hCryptProv, 0)
                返回 (“”)
                
            .否则
                rgbDigits ＝ 到字节集 (“0123456789ABCDEF”)
                局_MD5 ＝ 取空白字节集 (长度 × 2)
                .变量循环首 (0, cbHash － 1, 1, i)
                    b ＝ rgbHash [i ＋ 1]
                    局_MD5 [i × 2 ＋ 1] ＝ rgbDigits [右移 (b, 4) ＋ 1]
                    局_MD5 [i × 2 ＋ 2] ＝ rgbDigits [位与 (b, 15) ＋ 1]
                .变量循环尾 ()
                CryptDestroyHash (hHash)
                CryptReleaseContext (hCryptProv, 0)
            .如果结束
            
        .如果结束
        
    .如果结束
    返回 (到文本 (局_MD5))

.子程序 校验_取hmac_md5, 文本型, 公开
    .参数 数据, 字节集
    .参数 密钥, 文本型

    返回 (bin2hex_ (HMAC_md5 (数据, 密钥), 真))

.子程序 校验_取md5, 文本型, 公开, 取数据MD5
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集
    .参数 返回值转成大写, 逻辑型, 可空, 可空，默认为假。假=小写  真=大写
    .参数 是否取16位, 逻辑型, 可空, 可空，默认为32位
    .局部变量 t, 文本型

    t ＝ MD过程 (字节集数据, 32771, 16)
    .如果真 (返回值转成大写 ＝ 假)
        t ＝ 到小写 (t)
    .如果真结束
    
    .判断开始 (是否取16位)
        返回 (取文本中间 (t, 9, 16))
    .默认
        返回 (t)
    .判断结束
    

.子程序 校验_取md5_进度, 文本型, 公开, 支持大文件获取，失败返回空文本。
    .参数 文件路径, 文本型
    .参数 进度回调, 子程序指针, 可空, 1个参数【进度】整数型。
    .局部变量 hFile, 整数型
    .局部变量 context, MD5_CTX
    .局部变量 Data, 字节集
    .局部变量 Length, 整数型
    .局部变量 Count, 长整数型
    .局部变量 FileLong, 长整数型
    .局部变量 Pos, 整数型
    .局部变量 i, 整数型
    .局部变量 strMD5, 文本型
    .局部变量 读写位置, 整数型

    .如果真 (文件是否存在 (文件路径))
        hFile ＝ CreateFileA (文件路径, #GENERIC_READ, 位或 (#FILE_SHARE_WRITE, #FILE_SHARE_READ), 0, #OPEN_EXISTING, 536870912, 0) ' FILE_FLAG_NO_BUFFERING = 536870912
        .如果真 (hFile ≠ 0)
            FileLong ＝ 内部_取文件长度 (hFile)
            ' 移到文件首 (hFile)
            ' SetFilePointerEx (hFile, －内部_取文件长度 (hFile), 读写位置, 2)
            MD5Init (context)
            .循环判断首 ()
                内部_读入字节集 (hFile, Data, 8 × 1024 × 1024)
                Length ＝ 取字节集长度 (Data)
                Count ＝ Length ＋ Count
                Pos ＝ Count ÷ FileLong × 100
                .如果真 (到整数 (进度回调) ＞ 0)
                    程序_Call (到整数 (进度回调), Pos, , , , )
                .如果真结束
                MD5Update_bin (context, Data, Length)
                处理事件 ()
            .循环判断尾 (Count ＜ FileLong)
            MD5Final (context)
            .计次循环首 (16, i)
                strMD5 ＝ strMD5 ＋ 取文本右边 (到文本 (0) ＋ 到小写 (取十六进制文本 (context.digest [i])), 2)
            .计次循环尾 ()
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (到大写 (strMD5))
    
    
    

.子程序 内部_读入字节集, 整数型, 公开, 成功返回 实际读入的字节数 ,失败返回 -1
    .参数 文件句柄, 整数型, , 该句柄由“打开文件”命令所返回。
    .参数 存放数据的变量, 字节集, 参考
    .参数 欲读入数据的长度, 整数型
    .局部变量 缓冲区, 字节集
    .局部变量 读入的字符数, 整数型

    .如果真 (欲读入数据的长度 ＝ 0)
        欲读入数据的长度 ＝ 内部_取文件长度 (文件句柄) － 取读写位置 (文件句柄)
    .如果真结束
    缓冲区 ＝ 取空白字节集 (欲读入数据的长度)
    ReadFile (文件句柄, 缓冲区, 欲读入数据的长度, 读入的字符数, 0)
    .判断开始 (欲读入数据的长度 ＝ 读入的字符数)
        存放数据的变量 ＝ 缓冲区
    .默认
        存放数据的变量 ＝ 取字节集左边 (缓冲区, 读入的字符数)
    .判断结束
    返回 (读入的字符数)

.子程序 内部_取文件长度, 长整数型, 公开, 成功返回文件长度 ,失败返回 -1
    .参数 文件句柄, 整数型, , 该句柄由“打开文件”命令所返回。
    .局部变量 长度, 长整数型

    .如果 (GetFileSizeEx (文件句柄, 长度) ＝ 0)
        返回 (-1)
    .否则
        返回 (长度)
    .如果结束
    

.子程序 校验_取md5_文本, 文本型, 公开, 取文本MD5，支持中文。
    .参数 欲取MD5的文本串, 文本型, , 要取数据摘要的字节集
    .参数 是否包含中文, 逻辑型, 可空, 如果“欲取MD5的文本”中包含有汉字，设置为空，返回的MD5将不一样。
    .参数 返回值转成大写, 逻辑型, 可空, 可空，默认为假。假=小写  真=大写
    .参数 是否取16位, 逻辑型, 可空, 可空，默认为32位
    .局部变量 局_MD5, 文本型

    .如果 (是否包含中文)
        局_MD5 ＝ 编码_gb2312到utf8 (欲取MD5的文本串)
    .否则
        局_MD5 ＝ 欲取MD5的文本串
    .如果结束
    返回 (校验_取md5 (到字节集 (局_MD5), 返回值转成大写, 是否取16位))

.子程序 校验_取md4, 文本型, 公开
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集

    返回 (到小写 (MD过程 (字节集数据, 32770, 16)))

.子程序 校验_取md2, 文本型, 公开
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集

    返回 (到小写 (MD过程 (字节集数据, 32769, 16)))

.子程序 校验_取rc4, 字节集, 公开, RC4校验，与易的输出形式一样，可能和其它校验程序输出形式不一样，可自行进行相应调整。
    .参数 原文, 字节集, , 需要加、解密的字节集
    .参数 密码, 文本型, , 输入相应的密码
    .局部变量 m, 字节型, , "256"
    .局部变量 i, 整数型
    .局部变量 j, 整数型
    .局部变量 key, 字节集
    .局部变量 密码长度, 整数型
    .局部变量 原文长度, 整数型
    .局部变量 结果, 字节集
    .局部变量 x, 整数型
    .局部变量 k, 字节型, , "256"
    .局部变量 temp, 字节型

    原文长度 ＝ 取字节集长度 (原文)
    .如果真 (原文长度 ＜ 1)
        返回 ({ })
    .如果真结束
    密码长度 ＝ 取文本长度 (密码)
    结果 ＝ 取空白字节集 (原文长度)
    .计次循环首 (256, i)
        m [i] ＝ i － 1
    .计次循环尾 ()
    .如果真 (密码长度 ＞ 0)
        key ＝ 到字节集 (密码)
        j ＝ 1
        .计次循环首 (256, i)
            k [i] ＝ key [j]
            j ＝ j ＋ 1
            .如果真 (j ＞ 密码长度)
                j ＝ 1
            .如果真结束
            
        .计次循环尾 ()
        j ＝ 0
        .计次循环首 (256, i)
            j ＝ 位与 (j ＋ m [i] ＋ k [i], 255)
            temp ＝ m [i]
            m [i] ＝ m [j ＋ 1]
            m [j ＋ 1] ＝ temp
        .计次循环尾 ()
    .如果真结束
    i ＝ 0
    j ＝ 0
    .计次循环首 (原文长度, x)
        i ＝ 位与 (i ＋ 1, 255)
        j ＝ 位与 (j ＋ m [i ＋ 1], 255)
        temp ＝ m [i ＋ 1]
        m [i ＋ 1] ＝ m [j ＋ 1]
        m [j ＋ 1] ＝ temp
        结果 [x] ＝ 位异或 (原文 [x], m [位与 (m [i ＋ 1] ＋ m [j ＋ 1], 255) ＋ 1])
    .计次循环尾 ()
    返回 (结果)

.子程序 校验_取sha1, 文本型, 公开, 返回40位的校验数据
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集

    返回 (到小写 (MD过程 (字节集数据, 32772, 20)))

.子程序 校验_取crc32, 文本型, 公开, 用于取crc32，结果为16进制文本
    .参数 字节集数据, 字节集, , 要取CRC32数据字节集
    .局部变量 crcval, 整数型
    .局部变量 长度, 整数型
    .局部变量 i, 整数型
    .局部变量 结果, 文本型
    .局部变量 位置, 整数型
    .局部变量 crc, 整数型
    .局部变量 table, 整数型, , "256"

    长度 ＝ 取字节集长度 (字节集数据)
    .如果真 (长度 ＜ 1)
        返回 (“”)
    .如果真结束
    .变量循环首 (0, 255, 1, i) ' 用来得到码表
        crc ＝ i
        .变量循环首 (1, 8, 1, )
            .如果 (位与 (crc, 1) ≠ 0)
                crc ＝ 位异或 (位与 (右移 (crc, 1), 2147483647), 3988292384) ' crc xor EDB88320
            .否则
                crc ＝ 位与 (右移 (crc, 1), 2147483647)
            .如果结束
            
        .变量循环尾 ()
        table [i ＋ 1] ＝ crc
    .变量循环尾 ()
    crcval ＝ 4294967295
    .计次循环首 (长度, i)
        位置 ＝ 位异或 (字节集数据 [i], 位与 (crcval, 255)) ＋ 1 ' 查表
        crcval ＝ 位异或 (位与 (右移 (crcval, 8), 16777215), table [位置])
    .计次循环尾 ()
    返回 (取十六进制文本 (位取反 (crcval)))

.子程序 校验_取sha512, 文本型, 公开
    .参数 数据, 字节集
    .局部变量 date, 字节集

    date ＝ Hash模板 (数据, #CALG_SHA_512)
    .如果 (date ＝ { })
        返回 (“”)
    .否则
        返回 (bin2hex_ (date, 真))
    .如果结束
    

.子程序 校验_取sha256, 文本型, 公开
    .参数 数据, 字节集
    .局部变量 date, 字节集

    date ＝ Hash模板 (数据, #CALG_SHA_256)
    .如果 (date ＝ { })
        返回 (“”)
    .否则
        返回 (bin2hex_ (date, 真))
    .如果结束
    

.子程序 bin2hex_, 文本型
    .参数 bin, 字节集
    .参数 转换为小写, 逻辑型, 可空
    .参数 填充空格, 逻辑型, 可空
    .局部变量 数组, 字节型, , "0"
    .局部变量 返回字节集, 字节集
    .局部变量 ki, 整数型
    .局部变量 i, 整数型
    .局部变量 高4位, 整数型
    .局部变量 低4位, 整数型

    .如果 (转换为小写)
        数组 ＝ { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102 }
    .否则
        数组 ＝ { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70 }
    .如果结束
    
    
    ki ＝ 取字节集长度 (bin)
    .如果 (填充空格)
        返回字节集 ＝ 取空白字节集 (ki × 3)
    .否则
        返回字节集 ＝ 取空白字节集 (ki × 2)
    .如果结束
    
    
    .计次循环首 (ki, i)
        高4位 ＝ bin [i] ÷ 16 ＋ 1
        低4位 ＝ bin [i] ％ 16 ＋ 1
        .如果 (填充空格)
            返回字节集 [i × 3 － 2] ＝ 32
            返回字节集 [i × 3 － 1] ＝ 数组 [高4位]
            返回字节集 [i × 3] ＝ 数组 [低4位]
        .否则
            返回字节集 [i × 2 － 1] ＝ 数组 [高4位]
            返回字节集 [i × 2] ＝ 数组 [低4位]
        .如果结束
        
    .计次循环尾 ()
    返回 (删首尾空 (到文本 (返回字节集)))

.子程序 HMAC_md5, 字节集, , 返回字节集结果，请自行用 bin2hex_ 或 base64_encode 转换为需要的格式
    .参数 数据, 字节集
    .参数 密钥, 文本型
    .局部变量 Hash类型, 整数型
    .局部变量 key, 字节集

    Hash类型 ＝ #CALG_MD5
    key ＝ 到字节集 (密钥)
    返回 (hmac模板 (数据, key, Hash类型))

.子程序 Hash模板, 字节集
    .参数 数据, 字节集
    .参数 Hash类型, 整数型
    .局部变量 phProv, 整数型
    .局部变量 计算结果, 字节集

    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    计算结果 ＝ 执行hash (phProv, Hash类型, 数据)
    CryptReleaseContext_x (phProv, 0)
    返回 (计算结果)

.子程序 hmac模板, 字节集
    .参数 数据, 字节集
    .参数 key, 字节集
    .参数 Hash类型, 整数型
    .局部变量 phProv, 整数型
    .局部变量 计算结果, 字节集
    .局部变量 区块长度, 整数型
    .局部变量 ipad, 字节集
    .局部变量 opad, 字节集
    .局部变量 实际key, 字节集
    .局部变量 i, 整数型
    .局部变量 字节集2, 字节集
    .局部变量 字节集1, 字节集

    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    .判断开始 (Hash类型 ＝ #CALG_SHA_384 或 Hash类型 ＝ #CALG_SHA_512)
        区块长度 ＝ 128
    .默认
        区块长度 ＝ 64
    .判断结束
    
    .如果 (取字节集长度 (key) ＞ 区块长度)
        计算结果 ＝ 执行hash (phProv, Hash类型, key)
        .如果真 (计算结果 ＝ { })
            CryptReleaseContext_x (phProv, 0)
            返回 ({ })
        .如果真结束
        实际key ＝ 计算结果
    .否则
        实际key ＝ key
    .如果结束
    
    实际key ＝ 实际key ＋ 取空白字节集 (区块长度 － 取字节集长度 (实际key))
    ipad ＝ 取空白字节集 (区块长度)
    opad ＝ 取空白字节集 (区块长度)
    .计次循环首 (区块长度, i)
        ipad [i] ＝ 位异或 (实际key [i], 54)
        opad [i] ＝ 位异或 (实际key [i], 92)
    .计次循环尾 ()
    
    ipad ＝ ipad ＋ 数据
    计算结果 ＝ 执行hash (phProv, Hash类型, ipad)
    .如果真 (计算结果 ＝ { })
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    opad ＝ opad ＋ 计算结果
    
    计算结果 ＝ 执行hash (phProv, Hash类型, opad)
    .如果真 (计算结果 ＝ { })
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    返回 (计算结果)

.子程序 执行hash, 字节集
    .参数 phProv, 整数型
    .参数 Hash类型, 整数型
    .参数 数据, 字节集
    .局部变量 pbBuffer, 字节集
    .局部变量 len, 整数型
    .局部变量 计算结果, 字节集
    .局部变量 散列长度, 整数型
    .局部变量 hhash, 整数型

    .如果真 (CryptCreateHash_x (phProv, Hash类型, 0, 0, hhash) ＝ 假)
        返回 ({ })
    .如果真结束
    pbBuffer ＝ 数据
    len ＝ 取字节集长度 (pbBuffer)
    .如果真 (CryptHashData_x (hhash, pbBuffer, len, 0) ＝ 假)
        CryptDestroyHash (hhash)
        返回 ({ })
    .如果真结束
    散列长度 ＝ 0
    .如果真 (CryptGetHashParam_x (hhash, #HP_HASHVAL, 0, 散列长度, 0) ＝ 假)
        CryptDestroyHash (hhash)
        返回 ({ })
    .如果真结束
    计算结果 ＝ 取空白字节集 (散列长度)
    .如果真 (CryptGetHashParam_x (hhash, #HP_HASHVAL, 取地址_字节集 (计算结果), 散列长度, 0) ＝ 假)
        CryptDestroyHash (hhash)
        返回 ({ })
    .如果真结束
    CryptDestroyHash (hhash)
    计算结果 ＝ 取字节集左边 (计算结果, 散列长度)
    返回 (计算结果)
    

.子程序 取地址_字节集, 整数型
    .参数 变量, 字节集, 参考

    ' mov eax, [ebp+8]
    ' mov eax, [eax]
    ' add eax, 8
    ' mov esp ,ebp
    ' pop ebp
    ' retn 4
    置入代码 ({ 139, 69, 8, 139, 0, 131, 192, 8, 139, 229, 93, 194, 4, 0 }) ' <!!!>
    返回 (0)

.子程序 get_BLOBHEADER, 字节集
    .参数 bType, 整数型
    .参数 bVersion, 整数型
    .参数 reserved, 整数型
    .参数 aiKeyAlg, 整数型
    .局部变量 字节集, 字节集
    .局部变量 全部字节集, 字节集

    字节集 ＝ 到字节集 (bType)
    全部字节集 ＝ 取字节集左边 (字节集, 1)
    字节集 ＝ 到字节集 (bVersion)
    全部字节集 ＝ 全部字节集 ＋ 取字节集左边 (字节集, 1)
    字节集 ＝ 到字节集 (reserved)
    全部字节集 ＝ 全部字节集 ＋ 取字节集左边 (字节集, 2)
    全部字节集 ＝ 全部字节集 ＋ 到字节集 (aiKeyAlg)
    返回 (全部字节集)

.子程序 _padding填充, 字节集
    .参数 数据, 字节集
    .参数 块大小, 整数型
    .参数 填充算法, 整数型
    .局部变量 补位全长度, 整数型
    .局部变量 最后字节, 字节集
    .局部变量 算法块大小, 整数型
    .局部变量 填充块数, 整数型
    .局部变量 第一块填充数, 整数型

    .如果真 (块大小 ＝ 0)
        返回 (数据)
    .如果真结束
    .如果真 (填充算法 ＝ 1)
        返回 (数据)
    .如果真结束
    
    .如果真 (填充算法 ＝ 2)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        返回 (数据 ＋ 取重复字节集 (补位全长度, { 0 }))
    .如果真结束
    
    .如果真 (填充算法 ＝ 3)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        最后字节 ＝ 到字节集 (到字节 (补位全长度))
        返回 (数据 ＋ 取重复字节集 (补位全长度 － 1, { 0 }) ＋ 最后字节)
    .如果真结束
    
    .如果真 (填充算法 ＝ 4)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        最后字节 ＝ 到字节集 (到字节 (补位全长度))
        返回 (数据 ＋ 取随机字节集 (补位全长度 － 1) ＋ 最后字节)
    .如果真结束
    
    
    .如果真 (填充算法 ＝ 7 或 填充算法 ＝ 5)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        返回 (数据 ＋ 取重复字节集 (补位全长度, 到字节集 (到字节 (补位全长度))))
    .如果真结束
    
    返回 (数据)

.子程序 数据分块, 整数型
    .参数 数据, 字节集
    .参数 块大小, 整数型
    .参数 返回数据块, 字节集, 数组
    .局部变量 当前位置, 整数型
    .局部变量 块数量, 整数型
    .局部变量 数据长度, 整数型
    .局部变量 i, 整数型
    .局部变量 当前数据, 字节集
    .局部变量 返回数组, 字节集, , "0"

    清除数组 (返回数据块)
    数据长度 ＝ 取字节集长度 (数据)
    块数量 ＝ 数据长度 ÷ 块大小
    .如果真 (数据长度 ％ 块大小 ≠ 0)
        块数量 ＝ 块数量 ＋ 1
    .如果真结束
    当前位置 ＝ 1
    .计次循环首 (块数量, i)
        当前数据 ＝ 取字节集中间 (数据, 当前位置, 块大小)
        当前位置 ＝ 当前位置 ＋ 块大小
        加入成员 (返回数组, 当前数据)
    .计次循环尾 ()
    返回数据块 ＝ 返回数组
    返回 (取数组成员数 (返回数据块))
    
    

.子程序 取随机字节集, 字节集
    .参数 长度, 整数型
    .局部变量 返回字节集, 字节集
    .局部变量 i, 整数型

    返回字节集 ＝ 取空白字节集 (长度)
    置随机数种子 ()
    .计次循环首 (长度, i)
        返回字节集 [i] ＝ 取随机数 (1, 255)
    .计次循环尾 ()
    返回 (返回字节集)
    
    

.子程序 _padding去填充, 字节集
    .参数 数据, 字节集
    .参数 填充算法, 整数型
    .局部变量 ki, 整数型
    .局部变量 i, 整数型
    .局部变量 当前位置, 整数型
    .局部变量 右边字节集, 字节集
    .局部变量 补位长度, 整数型
    .局部变量 总长度, 整数型
    .局部变量 实际长度, 整数型

    
    .如果真 (数据 ＝ { })
        返回 (数据)
    .如果真结束
    .如果真 (填充算法 ＝ 1)
        返回 (数据)
    .如果真结束
    .如果真 (填充算法 ＝ 2)
        ki ＝ 取字节集长度 (数据)
        当前位置 ＝ ki
        .计次循环首 (ki, )
            .如果真 (数据 [当前位置] ≠ 0)
                返回 (取字节集左边 (数据, 当前位置))
            .如果真结束
            当前位置 ＝ 当前位置 － 1
        .计次循环尾 ()
        返回 ({ })
    .如果真结束
    
    .如果真 (填充算法 ＝ 3 或 填充算法 ＝ 7 或 填充算法 ＝ 5)
        总长度 ＝ 取字节集长度 (数据)
        右边字节集 ＝ 取字节集右边 (数据, 1)
        补位长度 ＝ 到整数 (右边字节集 [1])
        实际长度 ＝ 总长度 － 补位长度
        返回 (取字节集左边 (数据, 实际长度))
    .如果真结束
    返回 (数据)

.子程序 取对称算法加密_块, 字节集, , AES和DES是块加密
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .参数 IV, 字节集, 可空
    .参数 填充方式, 整数型, 可空
    .参数 模式, 整数型, 可空
    .局部变量 phProv, 整数型
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 字节集密钥, 字节集
    .局部变量 hKey, 整数型
    .局部变量 明文块, 字节集, , "0"
    .局部变量 块大小, 整数型
    .局部变量 i, 整数型
    .局部变量 ki, 整数型
    .局部变量 待加密数据, 字节集
    .局部变量 参数字节集, 字节集
    .局部变量 参数长度, 整数型
    .局部变量 是否最后块, 逻辑型
    .局部变量 存储空间, 字节集
    .局部变量 存储空间大小, 整数型
    .局部变量 加密数据大小, 整数型
    .局部变量 全部密文, 字节集
    .局部变量 算法库, 整数型

    .如果真 (对称算法类型 ＝ #CALG_AES)
        对称算法类型 ＝ #CALG_AES_128
    .如果真结束
    
    .如果 (对称算法类型 ＝ #CALG_AES 或 对称算法类型 ＝ #CALG_AES_128 或 对称算法类型 ＝ #CALG_AES_192 或 对称算法类型 ＝ #CALG_AES_256)
        算法库 ＝ #PROV_RSA_AES
    .否则
        算法库 ＝ #PROV_RSA_FULL
    .如果结束
    
    
    .如果真 (模式 ＝ 0)
        模式 ＝ #CRYPT_MODE_CBC
    .如果真结束
    .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    字节集密钥 ＝ 密钥
    待加密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    参数字节集 ＝ 到字节集 (模式)
    参数长度 ＝ 4
    .如果真 (CryptSetKeyParam (hKey, #KP_MODE, 参数字节集, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    参数字节集 ＝ 取空白字节集 (4)
    参数长度 ＝ 4
    
    CryptGetKeyParam (hKey, #KP_BLOCKLEN, 参数字节集, 参数长度, 0)
    块大小 ＝ 取字节集数据 (参数字节集, #整数型, )
    块大小 ＝ 块大小 ÷ 8
    .如果真 (块大小 ＝ 0)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    待加密数据 ＝ _padding填充 (待加密数据, 块大小, 填充方式)
    
    .如果真 (IV ＝ { })
        IV ＝ 取空白字节集 (块大小)
    .如果真结束
    
    .如果真 (CryptSetKeyParam (hKey, #KP_IV, IV, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    
    
    数据分块 (待加密数据, 块大小, 明文块)
    ki ＝ 取数组成员数 (明文块)
    .计次循环首 (ki, i)
        .如果 (ki ＝ i)
            是否最后块 ＝ 真
        .否则
            是否最后块 ＝ 假
        .如果结束
        
        存储空间 ＝ 明文块 [i] ＋ 取空白字节集 (块大小)
        加密数据大小 ＝ 取字节集长度 (明文块 [i])
        存储空间大小 ＝ 取字节集长度 (存储空间)
        
        .如果真 (CryptEncrypt_x (hKey, 0, 是否最后块, 0, 存储空间, 加密数据大小, 存储空间大小) ＝ 假)
            CryptDestroyKey (hKey)
            CryptReleaseContext_x (phProv, 0)
            返回 ({ })
        .如果真结束
        
        存储空间 ＝ 取字节集左边 (存储空间, 加密数据大小)
        全部密文 ＝ 全部密文 ＋ 存储空间
    .计次循环尾 ()
    全部密文 ＝ 取字节集左边 (全部密文, 取字节集长度 (全部密文) － 块大小)
    CryptDestroyKey (hKey)
    CryptReleaseContext_x (phProv, 0)
    返回 (全部密文)

.子程序 取对称算法解密_块, 字节集
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .参数 IV, 字节集, 可空
    .参数 填充方式, 整数型, 可空
    .参数 模式, 整数型, 可空
    .局部变量 phProv, 整数型
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 字节集密钥, 字节集
    .局部变量 hKey, 整数型
    .局部变量 密文块, 字节集, , "0"
    .局部变量 块大小, 整数型
    .局部变量 i, 整数型
    .局部变量 ki, 整数型
    .局部变量 待解密数据, 字节集
    .局部变量 参数字节集, 字节集
    .局部变量 参数长度, 整数型
    .局部变量 是否最后块, 逻辑型
    .局部变量 存储空间, 字节集
    .局部变量 解密数据大小, 整数型
    .局部变量 全部明文, 字节集
    .局部变量 算法库, 整数型

    .如果真 (对称算法类型 ＝ #CALG_AES)
        对称算法类型 ＝ #CALG_AES_128
    .如果真结束
    
    .如果 (对称算法类型 ＝ #CALG_AES 或 对称算法类型 ＝ #CALG_AES_128 或 对称算法类型 ＝ #CALG_AES_192 或 对称算法类型 ＝ #CALG_AES_256)
        算法库 ＝ #PROV_RSA_AES
    .否则
        算法库 ＝ #PROV_RSA_FULL
    .如果结束
    
    
    
    .如果真 (填充方式 ＝ 0)
        填充方式 ＝ #PKCS5_PADDING
    .如果真结束
    .如果真 (模式 ＝ 0)
        模式 ＝ #CRYPT_MODE_CBC
    .如果真结束
    .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    字节集密钥 ＝ 密钥
    待解密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    参数字节集 ＝ 到字节集 (模式)
    参数长度 ＝ 4
    .如果真 (CryptSetKeyParam (hKey, #KP_MODE, 参数字节集, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    参数字节集 ＝ 取空白字节集 (4)
    参数长度 ＝ 4
    
    CryptGetKeyParam (hKey, #KP_BLOCKLEN, 参数字节集, 参数长度, 0)
    块大小 ＝ 取字节集数据 (参数字节集, #整数型, )
    块大小 ＝ 块大小 ÷ 8
    .如果真 (块大小 ＝ 0)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    .如果真 (IV ＝ { })
        IV ＝ 取空白字节集 (块大小)
    .如果真结束
    
    .如果真 (CryptSetKeyParam (hKey, #KP_IV, IV, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    数据分块 (待解密数据, 块大小, 密文块)
    ki ＝ 取数组成员数 (密文块)
    .计次循环首 (ki, i)
        存储空间 ＝ 密文块 [i]
        解密数据大小 ＝ 取字节集长度 (密文块 [i])
        
        .如果真 (CryptDecrypt_x (hKey, 0, 假, 0, 存储空间, 解密数据大小) ＝ 假)
            CryptDestroyKey (hKey)
            CryptReleaseContext_x (phProv, 0)
            返回 ({ })
        .如果真结束
        
        存储空间 ＝ 取字节集左边 (存储空间, 解密数据大小)
        全部明文 ＝ 全部明文 ＋ 存储空间
    .计次循环尾 ()
    CryptDestroyKey (hKey)
    CryptReleaseContext_x (phProv, 0)
    全部明文 ＝ _padding去填充 (全部明文, 填充方式)
    返回 (全部明文)
    

.子程序 取对称算法加密_流, 字节集, , RC2和RC4是流加密
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .局部变量 字节集密钥, 字节集
    .局部变量 待加密数据, 字节集
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 phProv, 整数型
    .局部变量 hKey, 整数型
    .局部变量 存储空间, 字节集
    .局部变量 存储空间长度, 整数型
    .局部变量 数据长度, 整数型

    
    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    
    字节集密钥 ＝ 密钥
    待加密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        
        返回 ({ })
    .如果真结束
    
    存储空间 ＝ 待加密数据 ＋ 待加密数据
    存储空间长度 ＝ 取字节集长度 (存储空间)
    数据长度 ＝ 取字节集长度 (待加密数据)
    .如果真 (CryptEncrypt_x (hKey, 0, 真, 0, 存储空间, 数据长度, 存储空间长度) ＝ 假)
        返回 ({ })
    .如果真结束
    存储空间 ＝ 取字节集左边 (存储空间, 数据长度)
    返回 (存储空间)
    
    
    

.子程序 取对称算法解密_流, 字节集
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .局部变量 字节集密钥, 字节集
    .局部变量 待解密数据, 字节集
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 phProv, 整数型
    .局部变量 hKey, 整数型
    .局部变量 存储空间, 字节集
    .局部变量 存储空间长度, 整数型
    .局部变量 数据长度, 整数型

    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    
    字节集密钥 ＝ 密钥
    待解密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    存储空间 ＝ 待解密数据 ＋ 待解密数据
    存储空间长度 ＝ 取字节集长度 (存储空间)
    数据长度 ＝ 取字节集长度 (待解密数据)
    .如果真 (CryptDecrypt_x (hKey, 0, 真, 0, 存储空间, 数据长度) ＝ 假)
        返回 ({ })
    .如果真结束
    存储空间 ＝ 取字节集左边 (存储空间, 数据长度)
    返回 (存储空间)
    
    

.子程序 对称加密, 字节集, 公开, 支持 RC2/4，AES，DES，3DES
    .参数 数据, 字节集
    .参数 密钥, 字节集, , 如果不是RC2和RC4，则密钥长度必须为块大小,否则会填充{0}或截取
    .参数 算法, 文本型, 可空
    .参数 填充, 整数型, 可空, 见：数据填充_*** 默认为 PKCS5_PADDING，如果是RC2和RC4，无需提供
    .参数 IV, 字节集, 可空, 如果是RC2和RC4，无需提供，否则默认为16个{0}字节
    .局部变量 数组, 文本型, , "0"
    .局部变量 密钥字节集, 字节集
    .局部变量 密钥长度, 整数型
    .局部变量 算法代码, 整数型
    .局部变量 模式代码, 整数型
    .局部变量 块大小, 整数型

    .判断开始 (算法 ＝ “RC2”)
        返回 (取对称算法加密_流 (数据, 密钥, #CALG_RC2))
    .判断 (算法 ＝ “RC4”)
        返回 (取对称算法加密_流 (数据, 密钥, #CALG_RC4))
    .默认
        
    .判断结束
    数组 ＝ 分割文本 (算法, “-”, )
    .如果真 (取数组成员数 (数组) ≠ 2)
        返回 ({ })
    .如果真结束
    
    .如果真 (IV ＝ { })
        IV ＝ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    .如果真结束
    
    .如果真 (填充 ＝ 0)
        填充 ＝ 5
    .如果真结束
    .如果真 (填充 ＜ 1 或 填充 ＞ 7)
        返回 ({ })
    .如果真结束
    
    
    .判断开始 (数组 [1] ＝ “AES”)
        算法代码 ＝ #CALG_AES_128
        块大小 ＝ 16
    .判断 (数组 [1] ＝ “AES192”)
        算法代码 ＝ #CALG_AES_192
        块大小 ＝ 24
    .判断 (数组 [1] ＝ “AES256”)
        算法代码 ＝ #CALG_AES_256
        块大小 ＝ 32
    .判断 (数组 [1] ＝ “DES”)
        算法代码 ＝ #CALG_DES
        块大小 ＝ 8
    .判断 (数组 [1] ＝ “3DES”)
        算法代码 ＝ #CALG_3DES
        块大小 ＝ 24
    .默认
        返回 ({ })
    .判断结束
    
    .判断开始 (数组 [2] ＝ “CBC”)
        模式代码 ＝ #CRYPT_MODE_CBC
    .判断 (数组 [2] ＝ “ECB”)
        模式代码 ＝ #CRYPT_MODE_ECB
    .判断 (数组 [2] ＝ “OFB”)
        模式代码 ＝ #CRYPT_MODE_OFB
    .判断 (数组 [2] ＝ “CFB”)
        模式代码 ＝ #CRYPT_MODE_CFB
    .判断 (数组 [2] ＝ “CTS”)
        模式代码 ＝ #CRYPT_MODE_CTS
    .默认
        返回 ({ })
    .判断结束
    
    密钥字节集 ＝ 密钥
    密钥长度 ＝ 取字节集长度 (密钥字节集)
    .如果真 (密钥长度 ≠ 块大小)
        .如果 (密钥长度 ＞ 块大小)
            密钥字节集 ＝ 取字节集左边 (密钥字节集, 块大小)
        .否则
            密钥字节集 ＝ 密钥字节集 ＋ 取空白字节集 (块大小 － 取字节集长度 (密钥字节集))
        .如果结束
        
    .如果真结束
    
    返回 (取对称算法加密_块 (数据, 密钥字节集, 算法代码, IV, 填充, 模式代码))
    

.子程序 对称解密, 字节集, 公开, 支持 RC2/4，AES，DES，3DES
    .参数 数据, 字节集
    .参数 密钥, 字节集, , 如果不是RC2和RC4，则密钥长度必须为块大小,否则会填充{0}或截取
    .参数 算法, 文本型, 可空
    .参数 填充, 整数型, 可空, 见：数据填充_*** 默认为 PKCS5_PADDING，如果是RC2和RC4，无需提供
    .参数 IV, 字节集, 可空, 如果是RC2和RC4，无需提供，否则默认为16个{0}字节
    .局部变量 数组, 文本型, , "0"
    .局部变量 密钥字节集, 字节集
    .局部变量 密钥长度, 整数型
    .局部变量 算法代码, 整数型
    .局部变量 模式代码, 整数型
    .局部变量 块大小, 整数型

    .判断开始 (算法 ＝ “RC2”)
        返回 (取对称算法解密_流 (数据, 密钥, #CALG_RC2))
    .判断 (算法 ＝ “RC4”)
        返回 (取对称算法解密_流 (数据, 密钥, #CALG_RC4))
    .默认
        
    .判断结束
    数组 ＝ 分割文本 (算法, “-”, )
    .如果真 (取数组成员数 (数组) ≠ 2)
        返回 ({ })
    .如果真结束
    
    .如果真 (IV ＝ { })
        IV ＝ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    .如果真结束
    
    .如果真 (填充 ＝ 0)
        填充 ＝ 5
    .如果真结束
    .如果真 (填充 ＜ 1 或 填充 ＞ 7)
        返回 ({ })
    .如果真结束
    
    
    .判断开始 (数组 [1] ＝ “AES”)
        算法代码 ＝ #CALG_AES_128
        块大小 ＝ 16
    .判断 (数组 [1] ＝ “AES192”)
        算法代码 ＝ #CALG_AES_192
        块大小 ＝ 24
    .判断 (数组 [1] ＝ “AES256”)
        算法代码 ＝ #CALG_AES_256
        块大小 ＝ 32
    .判断 (数组 [1] ＝ “DES”)
        算法代码 ＝ #CALG_DES
        块大小 ＝ 8
    .判断 (数组 [1] ＝ “3DES”)
        算法代码 ＝ #CALG_3DES
        块大小 ＝ 24
    .默认
        返回 ({ })
    .判断结束
    
    .判断开始 (数组 [2] ＝ “CBC”)
        模式代码 ＝ #CRYPT_MODE_CBC
    .判断 (数组 [2] ＝ “ECB”)
        模式代码 ＝ #CRYPT_MODE_ECB
    .判断 (数组 [2] ＝ “OFB”)
        模式代码 ＝ #CRYPT_MODE_OFB
    .判断 (数组 [2] ＝ “CFB”)
        模式代码 ＝ #CRYPT_MODE_CFB
    .判断 (数组 [2] ＝ “CTS”)
        模式代码 ＝ #CRYPT_MODE_CTS
    .默认
        返回 ({ })
    .判断结束
    
    
    
    
    
    密钥字节集 ＝ 密钥
    密钥长度 ＝ 取字节集长度 (密钥字节集)
    .如果真 (密钥长度 ≠ 块大小)
        .如果 (密钥长度 ＞ 块大小)
            密钥字节集 ＝ 取字节集左边 (密钥字节集, 块大小)
        .否则
            密钥字节集 ＝ 密钥字节集 ＋ 取空白字节集 (块大小 － 取字节集长度 (密钥字节集))
        .如果结束
        
    .如果真结束
    
    返回 (取对称算法解密_块 (数据, 密钥字节集, 算法代码, IV, 填充, 模式代码))
    

.子程序 AES_DES_算法, 字节集, 公开, 参考常量  #对称算法_
    .参数 对称算法, 文本型, , 参考常量  #对称算法_
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 是否加解, 逻辑型, , 真=加密
    .局部变量 填充方式, 整数型
    .局部变量 结果, 字节集

    填充方式 ＝ #数据填充_ZERO_PADDING
    
    .如果 (是否加解)
        结果 ＝ 对称加密 (数据, 密钥, 对称算法, 填充方式)
    .否则
        结果 ＝ 对称解密 (数据, 密钥, 对称算法, 填充方式)
    .如果结束
    返回 (结果)

