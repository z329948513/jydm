.版本 2

.程序集 注册表操作Ex, , 公开, 注册表操作,包括注册表的读,写.支持64位
.程序集变量 IsWow64, 逻辑型, , , 判断是否为64位系统,如果是则进行64位的读写操作
.程序集变量 m_Error, 整数型
.程序集变量 m_键句柄, 整数型, , , 记录句柄,在类销毁时释放
.程序集变量 m_是否已打开, 逻辑型
.程序集变量 m_当前键目录, 整数型
.程序集变量 m_当前键, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    m_当前键 ＝ “”
    IsWow64Process (-1, IsWow64)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    关闭键Ex ()

.子程序 方法_置为64位Ex_作废, , , 该方法只能在64位系统中调用,调用之后,将读取64位的注册表,否则默认为32位注册表
    m_当前键 ＝ “”
    IsWow64 ＝ 真

.子程序 方法_置为32位Ex_作废, , , 置为读写32位的注册表
    m_当前键 ＝ “”
    IsWow64 ＝ 假

.子程序 关闭键Ex, 整数型, 公开, 关闭一个已经打开的键句柄,关闭之后需要重新调用打开键Ex才能进行其他操作,如果已经关闭则返回-1
    .如果真 (m_是否已打开)
        m_Error ＝ RegCloseKey (m_键句柄)
        m_是否已打开 ＝ 假
        m_当前键 ＝ “”
        m_当前键目录 ＝ -1
        返回 (m_Error)
    .如果真结束
    返回 (-1)

.子程序 打开键Ex, 整数型, 公开, 如果键不存在,则失败.成功键的句柄,失败返回-1,通过取最后错误查看错误码;注意,使用该命令时,如果键已打开,则自动关闭键后在执行本操作
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 局部_标志位, 整数型
    .局部变量 临时_句柄, 整数型
    .局部变量 重定向键, 文本型

    .如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名 且 m_是否已打开)
        返回 (m_键句柄)
    .如果真结束
    
    关闭键Ex ()
    .如果 (IsWow64) ' ; 64位注册表
        局部_标志位 ＝ #KEY_WOW64_64KEY
    .否则
        局部_标志位 ＝ #KEY_WOW64_32KEY
    .如果结束
    局部_标志位 ＝ 位或 (局部_标志位, #KEY_ALL_ACCESS)
    ' 注意:这里的samDesired 采用的是  #KEY_ALL_ACCESS  全部权限
    
    .判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
        m_Error ＝ RegOpenCurrentUser (局部_标志位, 临时_句柄)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegOpenKeyExA (临时_句柄, 全路径注册项名, 0, 局部_标志位, m_键句柄)
            RegCloseKey (临时_句柄)
        .如果真结束
        
        
    .判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
        m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 局部_标志位, 临时_句柄)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegOpenKeyExA (临时_句柄, 全路径注册项名, 0, 局部_标志位, m_键句柄)
            RegCloseKey (临时_句柄)
        .如果真结束
        
        
    .默认
        m_Error ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 局部_标志位, m_键句柄)
    .判断结束
    
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_是否已打开 ＝ 真
        m_当前键目录 ＝ 键根目录
        m_当前键 ＝ 全路径注册项名
        返回 (m_键句柄)
    .如果真结束
    返回 (-1)
    

.子程序 创建并打开键Ex, 整数型, 公开, 如果键不存在,则创建一个键之后打开,如果键存在则直接打开;返回键的句柄,失败返回-1,通过取最后错误查看错误码;
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 局部_标志位, 整数型
    .局部变量 临时_句柄, 整数型

    ' REG_NONE                    ( 0 )   // No value type
    ' REG_SZ                      ( 1 )   // Unicode nul terminated string
    ' REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
    ' // (with environment variable references)
    ' REG_BINARY                  ( 3 )   // Free form binary
    ' REG_DWORD                   ( 4 )   // 32-bit number
    ' REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
    ' REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
    ' REG_LINK                    ( 6 )   // Symbolic Link (unicode)
    ' REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
    ' REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
    ' REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
    ' REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
    ' 上面这些信息是键的类型,暂时先留着备用.
    .如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名)
        返回 (m_键句柄)
    .如果真结束
    
    关闭键Ex ()
    局部_标志位 ＝ #KEY_ALL_ACCESS
    .如果 (IsWow64) ' ; 64位注册表
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_64KEY)
    .否则
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_32KEY)
    .如果结束
    
    ' 注意:这里的samDesired 采用的是  #KEY_ALL_ACCESS  全部权限
    .判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
        m_Error ＝ RegOpenCurrentUser (局部_标志位, 临时_句柄)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegCreateKeyExA (临时_句柄, 全路径注册项名, 0, 0, 1, 局部_标志位, #REG_OPTION_NON_VOLATILE, m_键句柄, 0) ' 忽略最后一项
            RegCloseKey (临时_句柄)
        .如果真结束
        
    .判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
        m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 局部_标志位, 临时_句柄)
        
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegCreateKeyExA (临时_句柄, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 局部_标志位, 0, m_键句柄, 0) ' 忽略最后一项
            RegCloseKey (临时_句柄)
        .如果真结束
        
    .默认
        
        m_Error ＝ RegCreateKeyExA (键根目录, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 局部_标志位, 0, m_键句柄, 0) ' 忽略最后一项
    .判断结束
    
    
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_是否已打开 ＝ 真
        m_当前键目录 ＝ 键根目录
        m_当前键 ＝ 全路径注册项名
        
        返回 (m_键句柄)
    .如果真结束
    
    返回 (-1)

.子程序 枚举子项Ex, 整数型, 公开, 枚举指定项名称下的子项(成功返回子项目数,失败返回-1);
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 子项, 文本型, 参考 可空 数组, 获取的子项数组
    .局部变量 局_计次, 整数型
    .局部变量 局_项名, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    清除数组 (子项)
    
    局_项名 ＝ 取空白文本 (256)
    m_Error ＝ RegEnumKeyA (m_键句柄, 局_计次, 局_项名, 256)
    .如果真 (m_Error ≠ 0 且 m_Error ≠ #ERROR_NO_MORE_ITEMS)
        返回 (m_Error)
    .如果真结束
    
    .判断循环首 (m_Error ＝ 0)
        加入成员 (子项, 局_项名)
        局_计次 ＝ 局_计次 ＋ 1
        m_Error ＝ RegEnumKeyA (m_键句柄, 局_计次, 局_项名, 256)
    .判断循环尾 ()
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        m_Error ＝ 0
    .如果真结束
    返回 (取数组成员数 (子项))

.子程序 方法_取最后错误代码Ex, 整数型, 公开, 取出这个值后,可以根据GetlastError获取错误信息
    返回 (m_Error)

.子程序 枚举键信息Ex, 整数型, 公开, 枚举指定项名称下的键信息(成功返回键名数,失败返回-1),需要先调用打开键Ex或打开键Ex2
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 注册表键信息, 注册表_键, 参考 数组, 作为返回值返回
    .局部变量 局_计次, 整数型
    .局部变量 局_键值缓冲区, 整数型
    .局部变量 局_句柄
    .局部变量 临时_注册表键信息, 注册表_键

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        局_句柄 ＝ 打开键Ex (键根目录, 全路径注册项名)
        .如果真 (局_句柄 ＝ -1)
            返回 (m_Error)
        .如果真结束
        清除数组 (注册表键信息)
    .如果真结束
    临时_注册表键信息.键名称 ＝ 取空白文本 (256)
    .判断循环首 (局_句柄 ≠ 0)
        RegEnumValueA (m_键句柄, 局_计次, 临时_注册表键信息.键名称, 256, 0, 临时_注册表键信息.类型, 临时_注册表键信息.键值, 局_键值缓冲区)
        临时_注册表键信息.键值 ＝ 取空白字节集 (局_键值缓冲区)
        m_Error ＝ RegEnumValueA (m_键句柄, 局_计次, 临时_注册表键信息.键名称, 256, 0, 临时_注册表键信息.类型, 临时_注册表键信息.键值, 局_键值缓冲区)
        .如果 (m_Error ＝ 0)
            加入成员 (注册表键信息, 临时_注册表键信息)
        .否则
            跳出循环 ()
        .如果结束
        局_计次 ＝ 局_计次 ＋ 1
    .判断循环尾 ()
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        m_Error ＝ 0
    .如果真结束
    返回 (取数组成员数 (注册表键信息))

.子程序 键是否存在Ex, 逻辑型, 公开, 判断键是否存在,亦可可以直接使用"打开键Ex"进行判断
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 局部_标志位, 整数型
    .局部变量 临时_句柄, 整数型
    .局部变量 状态, 整数型

    局部_标志位 ＝ #KEY_READ
    .如果 (IsWow64) ' ; 64位注册表
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_64KEY)
    .否则
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_32KEY)
    .如果结束
    
    ' 注意:这里的samDesired 采用的是  #KEY_READ  读取权限
    
    状态 ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 局部_标志位, 临时_句柄)
    RegCloseKey (临时_句柄)
    
    .如果真 (状态 ＝ #ERROR_SUCCESS)
        返回 (真)
    .如果真结束
    返回 (假)
    

.子程序 读取键值Ex, 整数型, 公开, 成功返回0,失败返回错误码.需要先调用打开键Ex或打开键Ex2
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 项目信息_out, 注册表_键, 参考, 用于返回的

    
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    项目信息_out.键值 ＝ 取空白字节集 (256)
    项目信息_out.键名称 ＝ 全路径注册项名
    m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, 项目信息_out.键值, 256)
    返回 (m_Error)

.子程序 写入键值Ex_文本, 整数型, 公开, 成功返回0,失败返回错误码；注意，该函数只能写入文本型的值
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 欲写入值, 字节集, , 使用 到字节集()
    .参数 写入类型, 整数型, , 只适用于：REG_SZ;REG_EXPAND_SZ;REG_MULTI_SZ;#REG_BINARY
    .参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
    .局部变量 bRet, 整数型

    .如果真 (写入类型 ≠ #REG_SZ 且 写入类型 ≠ #REG_EXPAND_SZ 且 写入类型 ≠ #REG_MULTI_SZ 且 写入类型 ≠ #REG_BINARY)
        输出调试文本 (“写入的类型不正确，如果需要写入数值型，请调用【写入键值Ex_数值】”)
        返回 (-1)
    .如果真结束
    .如果真 (是否自动创建)
        m_当前键 ＝ “1”
    .如果真结束
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .判断开始 (是否自动创建)
            bRet ＝ 创建并打开键Ex (键根目录, 全路径注册项名) ' 自动创建这个键
        .默认
            bRet ＝ 打开键Ex (键根目录, 全路径注册项名)
        .判断结束
        
        .如果真 (bRet ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    欲写入值 ＝ 欲写入值 ＋ { 0 }
    m_Error ＝ RegSetValueExA (m_键句柄, 键名称, 0, 写入类型, 欲写入值, 取字节集长度 (欲写入值))
    返回 (m_Error)
    
    

.子程序 写入键值Ex_数值, 整数型, 公开
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 欲写入值, 长整数型, , 注意。理论上：DWORD最大值为：4294967295  QWORD最大值为：18446744073709551615，但是QWORD最大值超过了整数型的最大长度，请谨慎使用
    .参数 写入类型, 整数型, , 只适用于：#REG_DWORD;#REG_DWORD_BIG_ENDIAN;
    .参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
    .局部变量 bRet, 整数型
    .局部变量 临时_写入数据, 字节集
    .局部变量 临时_数据长度, 整数型

    .如果真 (写入类型 ≠ #REG_DWORD 且 写入类型 ≠ #REG_DWORD_BIG_ENDIAN 且 写入类型 ≠ #REG_QWORD)
        输出调试文本 (“写入的类型不正确，如果需要写入文本值，请调用【写入键值Ex_文本】”)
        返回 (-1)
    .如果真结束
    
    .如果真 (是否自动创建)
        m_当前键 ＝ “1”
    .如果真结束
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .判断开始 (是否自动创建)
            bRet ＝ 创建并打开键Ex (键根目录, 全路径注册项名) ' 自动创建这个键
        .默认
            bRet ＝ 打开键Ex (键根目录, 全路径注册项名)
        .判断结束
        
        .如果真 (bRet ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    临时_写入数据 ＝ 到字节集 (欲写入值)
    临时_数据长度 ＝ 4
    .如果真 (写入类型 ＝ #REG_QWORD)
        补充字节集长度 (临时_写入数据, 8)
        临时_数据长度 ＝ 8
    .如果真结束
    
    m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, 写入类型, 临时_写入数据, 临时_数据长度)
    返回 (m_Error)

.子程序 写QWORD_64值, 逻辑型, 公开, 写入64位长整数值,成功返回真,失败返回假.源码由@pp25729391提供。
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 值_十六进制文本, 文本型
    .局部变量 欲写入值, 字节集
    .局部变量 i, 整数型

    .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
        创建并打开键Ex (键根目录, 全路径注册项名) ' 自动创建这个键
    .如果真结束
    .变量循环首 (取文本长度 (值_十六进制文本), 1, -2, i)
        .如果真 (i ≠ 1)
            欲写入值 ＝ 欲写入值 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, i － 1, 2))), 1)
        .如果真结束
        .如果真 (i ＝ 1)
            欲写入值 ＝ 欲写入值 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, i, 1))), 1)
        .如果真结束
        
    .变量循环尾 ()
    补充字节集长度 (欲写入值, 8)
    m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, #REG_QWORD, 欲写入值, 8)
    返回 (m_Error ＝ 0)

.子程序 补充字节集长度
    .参数 数据, 字节集
    .参数 字节集的总长, 整数型
    .局部变量 循环的次数, 整数型
    .局部变量 计次, 整数型

    .如果真 (字节集的总长 ＞ 取字节集长度 (数据))
        循环的次数 ＝ 字节集的总长 － 取字节集长度 (数据)
        .计次循环首 (循环的次数, 计次)
            数据 ＝ 数据 ＋ { 0 }
        .计次循环尾 ()
    .如果真结束
    返回 ()

.子程序 删除键值Ex, 整数型, 公开, 删除一个键值.
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    m_Error ＝ RegDeleteValueA (m_键句柄, 键名)
    返回 (m_Error)

.子程序 删除注册表项, 整数型, 公开, 删除整个项,项下面所有的键值将会被自动删除.
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 bRet, 整数型
    .局部变量 临时_项目, 文本型

    bRet ＝ 倒找文本 (全路径注册项名, “\”, , 假)
    临时_项目 ＝ 取文本左边 (全路径注册项名, bRet － 1)
    .如果真 (打开键Ex (键根目录, 临时_项目) ＝ -1)
        返回 (m_Error)
    .如果真结束
    
    临时_项目 ＝ 取文本右边 (全路径注册项名, 取文本长度 (全路径注册项名) － bRet)
    m_Error ＝ RegDeleteKeyA (m_键句柄, 临时_项目)
    返回 (m_Error)
    

.子程序 格式化键值类型, 文本型, 公开, 说明键值
    .参数 键值, 整数型, , REG_*

    .如果真 (键值 ＞ 11 或 键值 ≤ 0)
        返回 (“键值非法”)
    .如果真结束
    返回 (多项选择 (键值, “REG_SZ”, “REG_EXPAND_SZ”, “REG_BINARY”, “REG_DWORD”, “REG_DWORD_BIG_ENDIAN”, “REG_LINK”, “REG_MULTI_SZ”, “REG_RESOURCE_LIST”, “NULL”, “NULL”, “REG_QWORD”))
    

