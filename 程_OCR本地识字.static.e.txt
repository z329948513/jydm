.版本 2
.支持库 spec
.支持库 iconv

.程序集 程_OCR本地识字
.程序集变量 窗口句柄_模型指针, 窗口句柄_模型指针, , "20"

.子程序 初始化_载入OCR模型, 整数型, 公开, 成功返回大于0的模型指针地址。可以分别载入多个模型，不用时记得调用 RapidOCR_释放模型 释放内存 不然会造成内存泄漏
    .参数 t, 整数型
    .参数 窗口句柄, 整数型
    .参数 参_设置线程数量, 整数型, 可空, 默认4 不超过CPU核心数，设置太高不一定就快
    .局部变量 模型指针, 整数型
    .局部变量 k, 逻辑型
    .局部变量 压缩包路径, 文本型
    .局部变量 OCR目录, 文本型
    .局部变量 i, 整数型

    
    OCR目录 ＝ “C:\RapidOCR\”
    
    .如果真 (文件是否存在 (OCR目录 ＋ “RapidOCR.dll”) ＝ 假)
        
        压缩包路径 ＝ “C:\RapidOCR.7z”
        写到文件 (压缩包路径, #RapidOCR)
        
        k ＝ 解压_7z_加载 ()
        .如果 (k ＝ 假)
            提示框J (“解压OCR识别DLL失败，请联系客服QQ562991312”)
        .否则
            i ＝ 解压_7z_解压 (0, 压缩包路径, OCR目录, , , &回调)
            .判断开始 (i ＝ 0)
                调试输出 (“解压成功”)
            .判断 (i ＝ 1)
                调试输出 (“解压错误”)
            .默认
                调试输出 (“解压取消”)
            .判断结束
            
        .如果结束
        
        解压_7z_卸载 ()
        
        ' 解压_7z_zip_老 (“C:\RapidOCR.7z”, “C:\RapidOCR.dll”)
        
        
        
    .如果真结束
    
    
    
    置DLL装载目录 (OCR目录)
    
    .如果真 (文件是否存在 (OCR目录 ＋ “RapidOCR.dll”) ＝ 假)
        信息框 (“载入模型失败！请联系客服QQ562991312”, #错误图标, , )
        返回 (0)
    .如果真结束
    
    .如果真 (是否为调试版 ())
        .如果真 (文件是否存在 (读环境变量 (“Temp”) ＋ “\e_debug\RapidOCR.dll”) ＝ 假) ' 对于某些调试特殊情况下无法加载DLL办法
            复制文件 (OCR目录 ＋ “RapidOCR.dll”, 读环境变量 (“Temp”) ＋ “\e_debug\RapidOCR.dll”)
        .如果真结束
        
    .如果真结束
    .如果真 (参_设置线程数量 ＜ 1)
        参_设置线程数量 ＝ 4
    .如果真结束
    
    模型指针 ＝ model (#模型_det, 取字节集长度 (#模型_det), #模型_cl, 取字节集长度 (#模型_cl), #模型_rec, 取字节集长度 (#模型_rec), #模型_字典_简体中文, 参_设置线程数量)
    .如果真 (模型指针 ＞ 0)
        窗口句柄_模型指针 [t].窗口句柄 ＝ 窗口句柄
        窗口句柄_模型指针 [t].模型指针 ＝ 模型指针
        
    .如果真结束
    
    返回 (模型指针)

.子程序 卸载_OCR模型, , 公开
    .参数 t, 整数型
    .局部变量 参_模型指针, 整数型

    .如果真 (窗口句柄_模型指针 [t].模型指针 ＞ 0)
        delmodel (窗口句柄_模型指针 [t].模型指针)
        窗口句柄_模型指针 [t].模型指针 ＝ 0
    .如果真结束
    

.子程序 截图_窗口截图, 字节集, 公开
    .参数 句柄, 整数型
    .参数 区域左边, 整数型
    .参数 区域顶边, 整数型
    .参数 区域右边, 整数型
    .参数 区域底边, 整数型
    .参数 是否带鼠标, 逻辑型, 可空
    .局部变量 宽度_, 整数型
    .局部变量 高度_, 整数型
    .局部变量 点阵大小, 整数型
    .局部变量 新位图数据, 字节集
    .局部变量 位图指针, 整数型
    .局部变量 设备场景, 整数型
    .局部变量 内存场景, 整数型
    .局部变量 对象句柄, 整数型
    .局部变量 点阵指针, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 临时变量_1, 整数型
    .局部变量 临时变量_2, 整数型
    .局部变量 矩形1, 矩形_
    .局部变量 pci, CURSORINFO
    .局部变量 iconinfo, ICONINFO
    .局部变量 鼠标绘制X, 整数型
    .局部变量 鼠标绘制Y, 整数型
    .局部变量 窗口左边, 整数型
    .局部变量 窗口顶边, 整数型

    .如果真 (区域左边 ＞ 区域右边)
        临时变量_1 ＝ 区域左边
        临时变量_2 ＝ 区域右边
        区域左边 ＝ 临时变量_2
        区域右边 ＝ 临时变量_1
    .如果真结束
    .如果真 (区域顶边 ＞ 区域底边)
        临时变量_1 ＝ 区域顶边
        临时变量_2 ＝ 区域底边
        区域顶边 ＝ 临时变量_2
        区域底边 ＝ 临时变量_1
    .如果真结束
    
    
    
    .如果真 (句柄 ＞ 0)
        取窗口矩形_ (句柄, 矩形1)
        .如果真 (区域右边 ＞ 矩形1.右边 － 矩形1.左边)
            区域右边 ＝ 矩形1.右边 － 矩形1.左边
        .如果真结束
        .如果真 (区域底边 ＞ 矩形1.底边 － 矩形1.顶边)
            区域底边 ＝ 矩形1.底边 － 矩形1.顶边
        .如果真结束
        
        .如果真 (区域左边 ＞ 区域右边)
            临时变量_1 ＝ 区域左边
            临时变量_2 ＝ 区域右边
            区域左边 ＝ 临时变量_2
            区域右边 ＝ 临时变量_1
        .如果真结束
        .如果真 (区域顶边 ＞ 区域底边)
            临时变量_1 ＝ 区域顶边
            临时变量_2 ＝ 区域底边
            区域顶边 ＝ 临时变量_2
            区域底边 ＝ 临时变量_1
        .如果真结束
        
    .如果真结束
    
    宽度_ ＝ 区域右边 － 区域左边 ＋ 1
    高度_ ＝ 区域底边 － 区域顶边 ＋ 1
    点阵大小 ＝ (宽度_ × 3 ＋ (4 － 宽度_ × 3 ％ 4) ％ 4) × 高度_
    新位图数据 ＝ { 66, 77 } ＋ 到字节集 (取整 (点阵大小 ＋ 54)) ＋ { 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (宽度_) ＋ 到字节集 (高度_) ＋ { 1, 0, 24, 0, 0, 0, 0, 0 } ＋ 到字节集 (点阵大小) ＋ 取空白字节集 (16 ＋ 点阵大小)
    位图指针 ＝ 取变量数据地址 (新位图数据)
    .如果 (句柄 ＞ 0)
        设备场景 ＝ 取设备场景_ (句柄)
    .否则
        设备场景 ＝ 取窗口全部设备场景_ (句柄)
    .如果结束
    
    内存场景 ＝ 创建内存场景_ (设备场景)
    对象句柄 ＝ 创建GDI对象_ (设备场景, 位图指针 ＋ 14, 0, 点阵指针, 0, 0)
    
    
    
    
    ' ... (前面的代码保持不变) ...
    
    位图句柄 ＝ 选入设备场景_ (内存场景, 对象句柄) ' 注意：这里返回的是旧位图
    pci.cbSize ＝ 20
    .判断开始 (是否带鼠标)
        取鼠标信息_ (pci)
        取得图标信息_ (pci.hCursor, iconinfo)
        
        ' === [修正1：坐标计算] ===
        
        .如果 (句柄 ＞ 0)
            取窗口矩形_ (句柄, 矩形1)
            窗口左边 ＝ 矩形1.左边
            窗口顶边 ＝ 矩形1.顶边
        .否则
            窗口左边 ＝ 0
            窗口顶边 ＝ 0
        .如果结束
        
        ' 鼠标屏幕坐标 - 窗口在屏幕位置 - 截图区域在窗口内的偏移 - 图标热点偏移
        鼠标绘制X ＝ pci.ptScreenPos.X － 窗口左边 － 区域左边 － iconinfo.xHotspot
        鼠标绘制Y ＝ pci.ptScreenPos.Y － 窗口顶边 － 区域顶边 － iconinfo.yHotspot
        ' =======================
        
    .默认
        
    .判断结束
    
    复制场景位图_ (内存场景, 0, 0, 宽度_, 高度_, 设备场景, 区域左边, 区域顶边, 13369376)
    
    .判断开始 (是否带鼠标)
        ' 只有当鼠标在截图区域内时才绘制（可选判断，GDI会自动裁剪，但这能优化性能）
        画图标_ (内存场景, 鼠标绘制X, 鼠标绘制Y, pci.hCursor)
        
        ' === [修正2：内存泄露修复] ===
        .如果真 (iconinfo.hbmMask ≠ 0)
            删除对象_ (iconinfo.hbmMask)
        .如果真结束
        .如果真 (iconinfo.hbmColor ≠ 0)
            删除对象_ (iconinfo.hbmColor)
        .如果真结束
        ' ==========================
    .默认
        
    .判断结束
    
    
    _复制内存 (位图指针 ＋ 54, 点阵指针, 点阵大小)
    释放设备场景_ (句柄, 设备场景)
    
    ' === [修正3：删除对象顺序] ===
    ' 最好先恢复旧对象，再删除创建的对象。或者直接删除创建的对象，不要删除“位图句柄”(旧对象)
    选入设备场景_ (内存场景, 位图句柄) ' 恢复旧对象(可选，规范做法)
    删除对象_ (对象句柄) ' 删除我们创建的 DIBSection
    ' 删除对象_ (位图句柄)  <-- 这行代码应该删掉，不要删除系统旧位图
    ' ==========================
    
    删除设备场景_ (内存场景)
    返回 (新位图数据)
    
    
    
    
    

.子程序 原OCR_识字_限中文, 文本型, , 成功返回识别到的文字内容   这个函数仅支持中文，多语言请使用：RapidOCR_图片文字识别W
    .参数 t, 整数型, , 初始化_载入模型 返回的模型指针
    .参数 参_图片数据, 字节集
    .参数 参_识别类型, 整数型, 可空, 0单行文字识别   1多行文字识别   2多行文字识别并返回位置可信度（文本|#|位置|#|可信度|#|单字信息）    默认2
    .参数 padding, 整数型, 可空, 60 图像预处理，在图片外周添加白边，用于提升识别率，文字框没有正确框住所有文字时，增加此值
    .参数 maxSideLen, 整数型, 可空, 1024 按图片最长边的长度，此值为0代表不缩放，例：1024，如果图片长边大于1024则把图像整体缩小到1024再进行图像分割计算，如果图片长边小于1024则不缩放，如果图片长边小于32，则缩放到32
    .参数 boxScoreThresh, 小数型, 可空, 0.5 文字框置信度门限，文字框没有正确框住所有文字时，减小此值
    .参数 boxThresh, 小数型, 可空, 0.3 文本框置信度
    .参数 unClipRatio, 小数型, 可空, 1.5 单个文字框大小倍率，越大时单个文字框越大。此项与图片的大小相关，越大的图片此值应该越大
    .参数 doAngle, 逻辑型, 可空, 假 文字方向分类，只有图片倒置的情况下(旋转90~270度的图片)，才需要启用文字方向分类
    .参数 mostangle, 逻辑型, 可空, 假 角度投票(整张图片以最大可能文字方向来识别)，当禁用文字方向检测时，此项也不起作用
    .参数 返回_返回信息, OCR_返回信息EX, 参考 可空 数组
    .局部变量 局_结果数据, 字节集

    
    
    .如果真 (参_图片数据 ＝ { } 或 t ＜ 1)
        .如果真 (参_图片数据 ＝ { })
            调试输出 (“图片数据未空，可能截图失败”)
        .如果真结束
        返回 (“”)
    .如果真结束
    .如果真 (是否为空 (参_识别类型) 或 参_识别类型 ＜ 0 或 参_识别类型 ＞ 2)
        参_识别类型 ＝ 2
    .如果真结束
    .如果真 (是否为空 (padding))
        padding ＝ 60
    .如果真结束
    局_结果数据 ＝ 原OCR_识字W (t, 参_图片数据, 参_识别类型, padding, maxSideLen, boxScoreThresh, boxThresh, unClipRatio, doAngle, mostangle)
    
    
    返回 (处理返回信息_识别 (局_结果数据, 返回_返回信息, 真))

.子程序 原OCR_识字_单行, 文本型, , 成功返回识别到的文字内容
    .参数 t, 整数型
    .参数 参_图片数据, 字节集
    .参数 参_中文解码, 逻辑型, 可空, utf8togb18030
    .局部变量 局_指针, 整数型
    .局部变量 局_长度, 整数型
    .局部变量 局_结果数据, 字节集

    .如果真 (参_图片数据 ＝ { } 或 t ＜ 1)
        .如果真 (参_图片数据 ＝ { })
            调试输出 (“图片数据未空，可能截图失败”)
        .如果真结束
        .如果真 (t ＜ 1)
            调试输出 (“参_模型指针无效”, t)
            
        .如果真结束
        返回 (“”)
    .如果真结束
    ocrlite (窗口句柄_模型指针 [t].模型指针, 参_图片数据, 取字节集长度 (参_图片数据), 局_指针, 局_长度)
    局_结果数据 ＝ 指针到字节集 (局_指针, 局_长度)
    del (局_指针)
    返回 (到文本 (选择 (参_中文解码, 编码转换 (局_结果数据, #编码_UTF_8, #编码_GB18030, ), 局_结果数据)))

.子程序 原OCR_识字W, 字节集, , 返回字节集数据  需要自行解码
    .参数 t, 整数型, , 初始化_载入模型 返回的模型指针
    .参数 参_图片数据, 字节集
    .参数 参_识别类型, 整数型, 可空, 0单行文字识别   1多行文字识别   2多行文字识别并返回位置可信度（文本|#|位置|#|可信度|#|单字信息） 6多行文字格式JSON   7多行文字格式JSON(不转义)  默认2
    .参数 padding, 整数型, 可空, 60 图像预处理，在图片外周添加白边，用于提升识别率，文字框没有正确框住所有文字时，增加此值
    .参数 maxSideLen, 整数型, 可空, 1024 按图片最长边的长度，此值为0代表不缩放，例：1024，如果图片长边大于1024则把图像整体缩小到1024再进行图像分割计算，如果图片长边小于1024则不缩放，如果图片长边小于32，则缩放到32
    .参数 boxScoreThresh, 小数型, 可空, 0.5 文字框置信度门限，文字框没有正确框住所有文字时，减小此值
    .参数 boxThresh, 小数型, 可空, 0.3 文本框置信度
    .参数 unClipRatio, 小数型, 可空, 1.5 单个文字框大小倍率，越大时单个文字框越大。此项与图片的大小相关，越大的图片此值应该越大
    .参数 doAngle, 逻辑型, 可空, 假 文字方向分类，只有图片倒置的情况下(旋转90~270度的图片)，才需要启用文字方向分类
    .参数 mostangle, 逻辑型, 可空, 假 角度投票(整张图片以最大可能文字方向来识别)，当禁用文字方向检测时，此项也不起作用
    .局部变量 局_返回内容指针, 整数型
    .局部变量 局_返回内容长度, 整数型
    .局部变量 局_结果数据, 字节集

    .如果真 (参_图片数据 ＝ { } 或 窗口句柄_模型指针 [t].模型指针 ＜ 1)
        .如果真 (参_图片数据 ＝ { })
            调试输出 (“图片数据未空，可能截图失败”)
        .如果真结束
        .如果真 (窗口句柄_模型指针 [t].模型指针 ＜ 1)
            调试输出 (“参_模型指针无效”, 窗口句柄_模型指针 [t].模型指针)
        .如果真结束
        
        返回 ({ })
    .如果真结束
    .如果真 (参_识别类型 ≠ 6 且 参_识别类型 ≠ 7)
        .如果真 (是否为空 (参_识别类型) 或 参_识别类型 ＜ 0 或 参_识别类型 ＞ 2)
            参_识别类型 ＝ 2
        .如果真结束
        
    .如果真结束
    .如果真 (是否为空 (padding))
        padding ＝ 60
    .如果真结束
    .如果真 (maxSideLen ＝ 0)
        maxSideLen ＝ 1024
    .如果真结束
    .如果真 (boxScoreThresh ＝ 0)
        boxScoreThresh ＝ 0.5
    .如果真结束
    .如果真 (boxThresh ＝ 0)
        boxThresh ＝ 0.3
    .如果真结束
    .如果真 (unClipRatio ＝ 0)
        unClipRatio ＝ 1.5
    .如果真结束
    .如果真 (是否为空 (doAngle))
        doAngle ＝ 假
    .如果真结束
    .如果真 (是否为空 (mostangle))
        mostangle ＝ 假
    .如果真结束
    
    ocr (窗口句柄_模型指针 [t].模型指针, 参_图片数据, 取字节集长度 (参_图片数据), 参_识别类型, padding, maxSideLen, boxScoreThresh, boxThresh, unClipRatio, doAngle, mostangle, 局_返回内容指针, 局_返回内容长度)
    局_结果数据 ＝ 指针到字节集 (局_返回内容指针, 局_返回内容长度)
    del (局_返回内容指针)
    返回 (局_结果数据)

.子程序 原OCR_找字_限中文, 逻辑型, , 找到返回真   这个函数仅支持中文，多语言请使用：RapidOCR_找字W 
    .参数 t, 整数型, , 初始化载入模型 返回的模型指针
    .参数 参_图片数据, 字节集
    .参数 参_找字内容, 文本型, , 找多个请用|隔开，比如： 李逍遥|赵灵儿  注意：字典编码必须是utf8；还有如果一行字存在间隔和大小相差较大的情况下，坐标也会有较大的偏移
    .参数 返_找到信息, 单字信息, 参考 可空 数组, 找到返回>=1的单字信息的数据类的数组。返回是逻辑性判断，可信度无效。x y是图片的坐标
    .参数 padding, 整数型, 可空, 60 图像预处理，在图片外周添加白边，用于提升识别率，文字框没有正确框住所有文字时，增加此值
    .参数 maxSideLen, 整数型, 可空, 1024 按图片最长边的长度，此值为0代表不缩放，例：1024，如果图片长边大于1024则把图像整体缩小到1024再进行图像分割计算，如果图片长边小于1024则不缩放，如果图片长边小于32，则缩放到32
    .参数 boxScoreThresh, 小数型, 可空, 0.5 文字框置信度门限，文字框没有正确框住所有文字时，减小此值
    .参数 boxThresh, 小数型, 可空, 0.3 文本框置信度
    .参数 unClipRatio, 小数型, 可空, 1.5 单个文字框大小倍率，越大时单个文字框越大。此项与图片的大小相关，越大的图片此值应该越大
    .参数 doAngle, 逻辑型, 可空, 假 文字方向分类，只有图片倒置的情况下(旋转90~270度的图片)，才需要启用文字方向分类
    .参数 mostangle, 逻辑型, 可空, 假 角度投票(整张图片以最大可能文字方向来识别)，当禁用文字方向检测时，此项也不起作用
    .局部变量 局_结果数据, 字节集
    .局部变量 局_成员数, 整数型
    .局部变量 计次, 整数型
    .局部变量 找到信息

    .如果真 (参_图片数据 ＝ { } 或 窗口句柄_模型指针 [t].模型指针 ＜ 1 或 参_找字内容 ＝ “”)
        .如果真 (参_图片数据 ＝ { })
            调试输出 (“图片数据未空，可能截图失败”)
        .如果真结束
        .如果真 (参_找字内容 ＝ “”)
            调试输出 (“参_找字内容内容为空”)
            
        .如果真结束
        返回 (假)
    .如果真结束
    局_结果数据 ＝ 原OCR_找字W_返回字节集 (t, 参_图片数据, 编码转换 (到字节集 (参_找字内容), #编码_GB18030, #编码_UTF_8, ), padding, maxSideLen, boxScoreThresh, boxThresh, unClipRatio, doAngle, mostangle)
    调试输出 (“局_结果数据”, 局_结果数据)
    
    处理返回信息_找字 (局_结果数据, 返_找到信息, 真)
    局_成员数 ＝ 取数组成员数 (返_找到信息)
    .如果真 (局_成员数 ＞ 0)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 原OCR_找字W_返回字节集, 字节集, , 返回字节集数据   找到返回： 文字1,x,y|文字2,x,y  找不到返回-1
    .参数 t, 整数型, , 初始化载入模型 返回的模型指针
    .参数 参_图片数据, 字节集
    .参数 参_找字数据, 字节集, , 找多个请用|隔开，比如： 李逍遥|赵灵儿  注意：为了仅支持多语言使用，字典和要找的文字必须都是utf8编码的；还有如果一行字存在间隔和大小相差较大的情况下，坐标也会有较大的偏移
    .参数 padding, 整数型, 可空, 60 图像预处理，在图片外周添加白边，用于提升识别率，文字框没有正确框住所有文字时，增加此值
    .参数 maxSideLen, 整数型, 可空, 1024 按图片最长边的长度，此值为0代表不缩放，例：1024，如果图片长边大于1024则把图像整体缩小到1024再进行图像分割计算，如果图片长边小于1024则不缩放，如果图片长边小于32，则缩放到32
    .参数 boxScoreThresh, 小数型, 可空, 0.5 文字框置信度门限，文字框没有正确框住所有文字时，减小此值
    .参数 boxThresh, 小数型, 可空, 0.3 文本框置信度
    .参数 unClipRatio, 小数型, 可空, 1.5 单个文字框大小倍率，越大时单个文字框越大。此项与图片的大小相关，越大的图片此值应该越大
    .参数 doAngle, 逻辑型, 可空, 假 文字方向分类，只有图片倒置的情况下(旋转90~270度的图片)，才需要启用文字方向分类
    .参数 mostangle, 逻辑型, 可空, 假 角度投票(整张图片以最大可能文字方向来识别)，当禁用文字方向检测时，此项也不起作用
    .局部变量 局_返回内容指针, 整数型
    .局部变量 局_返回内容长度, 整数型
    .局部变量 局_结果数据, 字节集
    .局部变量 局_识别全部内容, 文本型

    .如果真 (参_图片数据 ＝ { } 或 窗口句柄_模型指针 [t].模型指针 ＜ 1 或 参_找字数据 ＝ { })
        .如果真 (参_图片数据 ＝ { })
            调试输出 (“图片数据未空，可能截图失败”)
        .如果真结束
        
        返回 ({ })
    .如果真结束
    
    ' 不要传空进去
    .如果真 (是否为空 (padding))
        padding ＝ 60
    .如果真结束
    .如果真 (maxSideLen ＝ 0)
        maxSideLen ＝ 1024
    .如果真结束
    .如果真 (boxScoreThresh ＝ 0)
        boxScoreThresh ＝ 0.5
    .如果真结束
    .如果真 (boxThresh ＝ 0)
        boxThresh ＝ 0.3
    .如果真结束
    .如果真 (unClipRatio ＝ 0)
        unClipRatio ＝ 1.5
    .如果真结束
    .如果真 (是否为空 (doAngle))
        doAngle ＝ 假
    .如果真结束
    .如果真 (是否为空 (mostangle))
        mostangle ＝ 假
    .如果真结束
    
    findtext (窗口句柄_模型指针 [t].模型指针, 参_图片数据, 取字节集长度 (参_图片数据), 参_找字数据 ＋ { 124 }, padding, maxSideLen, boxScoreThresh, boxThresh, unClipRatio, doAngle, mostangle, 局_返回内容指针, 局_返回内容长度)
    局_结果数据 ＝ 指针到字节集 (局_返回内容指针, 局_返回内容长度)
    del (局_返回内容指针)
    返回 (局_结果数据)

.子程序 处理返回信息_识别, 文本型, 公开
    .参数 参_结果数据, 字节集
    .参数 返回_返回信息, OCR_返回信息EX, 参考 可空 数组
    .参数 参_中文解码, 逻辑型, 可空, utf8togb18030
    .局部变量 局_结果信息, OCR_返回信息EX
    .局部变量 局_数组1, 字节集, , "0"
    .局部变量 局_数组2, 字节集, , "0"
    .局部变量 局_数组3, 字节集, , "0"
    .局部变量 局_数组4, 字节集, , "0"
    .局部变量 i, 整数型
    .局部变量 j, 整数型
    .局部变量 n, 整数型
    .局部变量 局_识别全部内容, 文本型
    .局部变量 局_行数, 整数型
    .局部变量 启动时间, 整数型

    清除数组 (返回_返回信息)
    
    .如果真 (参_结果数据 ＝ { })
        返回 (“”)
    .如果真结束
    
    ' 如果直接用文本分割国外文字可能会出现乱码，所以转到字节分割
    局_数组1 ＝ 分割字节集 (参_结果数据, { 13, 10 }, ) ' 换行
    局_行数 ＝ 取数组成员数 (局_数组1)
    .计次循环首 (局_行数, i)
        局_结果信息.可信度 ＝ 0
        局_结果信息.位置_矩形 ＝ { 0, 0, 0, 0 }
        局_结果信息.位置_直线 ＝ { 0, 0, 0, 0, 0, 0, 0, 0 }
        清除数组 (局_结果信息.单字可信度与坐标)
        
        局_数组2 ＝ 分割字节集 (局_数组1 [i], { 124, 35, 124 }, ) ' |#|
        .如果真 (取数组成员数 (局_数组2) ≥ 4)
            
            
            
            局_结果信息.内容 ＝ 到文本 (选择 (参_中文解码, 编码转换 (局_数组2 [1], #编码_UTF_8, #编码_GB18030, ), 局_数组2 [1]))
            局_结果信息.可信度 ＝ 到小数 (到文本 (局_数组2 [3]))
            局_数组3 ＝ 分割字节集 (局_数组2 [2], { 44 }, ) ' ,
            .如果真 (取数组成员数 (局_数组3) ≥ 12)
                .计次循环首 (4, j)
                    局_结果信息.位置_矩形 [j] ＝ 到整数 (到文本 (局_数组3 [j]))
                .计次循环尾 ()
                j ＝ 4
                .计次循环首 (8, n)
                    局_结果信息.位置_直线 [n] ＝ 到整数 (到文本 (局_数组3 [n ＋ j]))
                .计次循环尾 ()
            .如果真结束
            
            局_数组3 ＝ 分割字节集 (局_数组2 [4], { 124 }, ) ' |
            重定义数组 (局_结果信息.单字可信度与坐标, 假, 取数组成员数 (局_数组3))
            .计次循环首 (取数组成员数 (局_数组3), j)
                局_数组4 ＝ 分割字节集 (局_数组3 [j], { 44 }, ) ' ,
                .如果真 (取数组成员数 (局_数组4) ≥ 4)
                    局_结果信息.单字可信度与坐标 [j].文字 ＝ 到文本 (选择 (参_中文解码, 编码转换 (局_数组4 [1], #编码_UTF_8, #编码_GB18030, ), 局_数组4 [1]))
                    局_结果信息.单字可信度与坐标 [j].可信度 ＝ 到小数 (到文本 (局_数组4 [2]))
                    局_结果信息.单字可信度与坐标 [j].x ＝ 到整数 (到文本 (局_数组4 [3]))
                    局_结果信息.单字可信度与坐标 [j].y ＝ 到整数 (到文本 (局_数组4 [4]))
                .如果真结束
                
            .计次循环尾 ()
            
            .如果 (局_行数 ＝ i) ' 不要最后的换行
                局_识别全部内容 ＝ 局_识别全部内容 ＋ 局_结果信息.内容
            .否则
                局_识别全部内容 ＝ 局_识别全部内容 ＋ 局_结果信息.内容 ＋ #换行符
            .如果结束
            加入成员 (返回_返回信息, 局_结果信息)
            到循环尾 ()
        .如果真结束
        
        ' 单行/多行
        .如果真 (局_数组1 [i] ≠ { })
            局_结果信息.内容 ＝ 到文本 (选择 (参_中文解码, 编码转换 (局_数组2 [1], #编码_UTF_8, #编码_GB18030, ), 局_数组2 [1]))
            .如果 (局_行数 ＝ i) ' 不要最后的换行
                局_识别全部内容 ＝ 局_识别全部内容 ＋ 局_结果信息.内容
            .否则
                局_识别全部内容 ＝ 局_识别全部内容 ＋ 局_结果信息.内容 ＋ #换行符
            .如果结束
            加入成员 (返回_返回信息, 局_结果信息)
            到循环尾 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (局_识别全部内容)

.子程序 处理返回信息_找字, 逻辑型, 公开
    .参数 参_结果数据, 字节集
    .参数 返回_找字结果, 单字信息, 参考 数组
    .参数 参_中文解码, 逻辑型, , utf8togb18030。真
    .局部变量 局_结果信息, 单字信息
    .局部变量 局_数组1, 字节集, , "0"
    .局部变量 局_数组2, 字节集, , "0"
    .局部变量 i
    .局部变量 局_成员, 整数型
    .局部变量 j

    清除数组 (返回_找字结果)
    .如果真 (参_结果数据 ＝ { } 或 参_结果数据 ＝ { 45, 49 }) ' -1
        返回 (假)
    .如果真结束
    局_数组1 ＝ 分割字节集 (参_结果数据 ＋ { 124 }, { 124 }, ) ' |
    .计次循环首 (取数组成员数 (局_数组1), i)
        局_数组2 ＝ 分割字节集 (局_数组1 [i], { 44 }, ) ' ,
        局_成员 ＝ 取数组成员数 (局_数组2)
        .如果真 (局_成员 ＜ 3)
            到循环尾 ()
        .如果真结束
        局_结果信息.文字 ＝ “”
        .计次循环首 (局_成员 － 2, j) ' 防止多个逗号没有返回全部内容
            局_结果信息.文字 ＝ 局_结果信息.文字 ＋ 到文本 (选择 (参_中文解码, 编码转换 (局_数组2 [j], #编码_UTF_8, #编码_GB18030, ), 局_数组2 [j]))
        .计次循环尾 ()
        局_结果信息.x ＝ 到整数 (到文本 (局_数组2 [局_成员 － 1]))
        局_结果信息.y ＝ 到整数 (到文本 (局_数组2 [局_成员]))
        加入成员 (返回_找字结果, 局_结果信息)
    .计次循环尾 ()
    .如果真 (取数组成员数 (局_结果信息) ＞ 0)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 OCR_识字_多行, 文本型, 公开, 自己封装的 窗口截图 + OCR_图片文字识别
    .参数 t, 整数型
    .参数 x1, 整数型
    .参数 y1, 整数型
    .参数 x2, 整数型
    .参数 y2, 整数型
    .局部变量 截到的图片, 字节集
    .局部变量 识别类型, 整数型, , , 0单行文字识别   1多行文字识别   2多行文字识别并返回位置可信度（文本|#|位置|#|可信度|#|单字信息）    默认2
    .局部变量 返回信息, OCR_返回信息EX, 数组, "0", 数组变量接收，取数组成员数 在计次循环里输出，识别单行字可直接输出 [1].可信度 [1].x [1].y
    .局部变量 返回识别文字, 文本型

    截到的图片 ＝ 截图_窗口截图 (窗口句柄_模型指针 [t].窗口句柄, x1, y1, x2, y2, )
    识别类型 ＝ 2 ' 多行
    
    返回识别文字 ＝ 原OCR_识字_限中文 (t, 截到的图片, 识别类型, , , , , , , , 返回信息)
    返回 (返回识别文字)

.子程序 OCR_识字_单行, 文本型, 公开, 自己封装的 窗口截图 + OCR_图片文字识别_单行
    .参数 t, 整数型
    .参数 x1, 整数型
    .参数 y1, 整数型
    .参数 x2, 整数型
    .参数 y2, 整数型
    .局部变量 中文解码, 逻辑型, , , 真=文字，假=乱码
    .局部变量 截到的图片, 字节集
    .局部变量 返回识别文字, 文本型

    截到的图片 ＝ 截图_窗口截图 (窗口句柄_模型指针 [t].窗口句柄, x1, y1, x2, y2, )
    中文解码 ＝ 真
    返回识别文字 ＝ 原OCR_识字_单行 (t, 截到的图片, 中文解码)
    返回 (返回识别文字)

.子程序 OCR__找字, 逻辑型, 公开, 自己封装的 窗口截图 + OCR_找字
    .参数 t, 整数型
    .参数 x1, 整数型
    .参数 y1, 整数型
    .参数 x2, 整数型
    .参数 y2, 整数型
    .参数 找字内容, 文本型, , 找多个请用|隔开，比如： 李逍遥|赵灵儿  注意：字典编码必须是utf8；还有如果一行字存在间隔和大小相差较大的情况下，坐标也会有较大的偏移
    .参数 xx, 整数型, 参考 可空
    .参数 yy, 整数型, 参考 可空
    .局部变量 截到的图片, 字节集
    .局部变量 返回结果, 逻辑型
    .局部变量 找到信息, 单字信息, , "0"

    截到的图片 ＝ 截图_窗口截图 (窗口句柄_模型指针 [t].窗口句柄, x1, y1, x2, y2, )
    
    返回结果 ＝ 原OCR_找字_限中文 (t, 截到的图片, 找字内容, 找到信息, , , , , , , )
    
    .如果真 (返回结果 ＝ 真 且 取数组成员数 (找到信息) ＞ 0)
        xx ＝ 找到信息 [1].x ＋ x1
        yy ＝ 找到信息 [1].y ＋ y1
    .如果真结束
    返回 (返回结果)

.子程序 qszc
    

