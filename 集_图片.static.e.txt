.版本 2

.程序集 集_图片
.程序集变量 集_转换错误, 文本型

.子程序 图片_平铺拉伸, 字节集, 公开, 按指定宽高  平铺/拉伸  成功返回图片字节集  失败返回空字节集
    .参数 参_原图片, 字节集
    .参数 参_设定宽度, 整数型, 可空, 默认：1920
    .参数 参_设定高度, 整数型, 可空, 默认：1080
    .参数 参_处理类型, 整数型, 可空, 可空，默认0=平铺  1=拉伸
    .局部变量 底位图, 类_位图操作
    .局部变量 层位图, 类_位图操作
    .局部变量 局_原宽度, 整数型
    .局部变量 局_原高度, 整数型
    .局部变量 局_相差宽度, 整数型
    .局部变量 局_相差高度, 整数型
    .局部变量 局_原图, 字节集
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_剩余宽度, 整数型
    .局部变量 局_剩余高度, 整数型
    .局部变量 局_顶边, 整数型
    .局部变量 局_循环_横向, 整数型
    .局部变量 局_循环_纵向, 整数型
    .局部变量 局_新图片, 字节集
    .局部变量 i, 整数型

    .如果真 (图片_转换 (参_原图片, 1, , 局_原图, ) ＝ 假)
        输出调试文本 (“转换图片失败”)
        返回 ({ })
    .如果真结束
    
    
    .如果真 (参_设定宽度 ＝ 0)
        参_设定宽度 ＝ 1920
    .如果真结束
    
    .如果真 (参_设定高度 ＝ 0)
        参_设定高度 ＝ 1080
    .如果真结束
    
    
    
    .如果真 (层位图.从数据创建 (局_原图) ＝ 假)
        输出调试文本 (“创建创建层位图失败”)
        返回 ({ })
    .如果真结束
    
    局_原宽度 ＝ 层位图.取宽度 ()
    局_原高度 ＝ 层位图.取高度 ()
    
    .如果真 (参_处理类型 ＝ 0)
        .如果真 (参_设定宽度 ≤ 局_原宽度 或 参_设定高度 ≤ 局_原高度)
            输出调试文本 (“平铺模式下，设定的宽高需要大于原图片的宽高”)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    
    .如果真 (底位图.创建空白位图 (参_设定宽度, 参_设定高度, 24) ＝ 假)
        输出调试文本 (“创建空白底位图失败”)
        返回 ({ })
    .如果真结束
    
    .判断开始 (参_处理类型 ＝ 0)
        局_相差宽度 ＝ 参_设定宽度 － 局_原宽度
        局_相差高度 ＝ 参_设定高度 － 局_原高度
        
        局_剩余宽度 ＝ 参_设定宽度 ％ 局_原宽度
        局_循环_横向 ＝ (参_设定宽度 － 局_剩余宽度) ÷ 局_原宽度
        
        局_剩余高度 ＝ 参_设定高度 ％ 局_原高度
        局_循环_纵向 ＝ (参_设定高度 － 局_剩余高度) ÷ 局_原高度
        
        
        局_左边 ＝ －局_原宽度
        .计次循环首 (局_循环_横向, a)
            局_左边 ＝ 局_左边 ＋ 局_原宽度
            层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_原高度, 局_左边, 0) ' 横向平铺一张
            局_顶边 ＝ －局_原高度
            .计次循环首 (局_循环_纵向, a)
                局_顶边 ＝ 局_顶边 ＋ 局_原高度
                层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_原高度, 局_左边, 局_顶边) ' 纵向平铺一张
                系统_处理事件 ()
            .计次循环尾 ()
            .如果真 (局_剩余高度 ≠ 0)
                层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_剩余高度, 局_左边, 局_顶边 ＋ 局_原高度) ' 纵向剩余高度 再平铺一张
            .如果真结束
            
            系统_处理事件 ()
        .计次循环尾 ()
        
        .如果真 (局_剩余宽度 ≠ 0)
            局_顶边 ＝ －局_原高度
            .计次循环首 (局_循环_纵向, i)
                局_顶边 ＝ 局_顶边 ＋ 局_原高度
                层位图.复制到 (底位图, 0, 0, 局_剩余宽度, 局_原高度, 局_左边 ＋ 局_原宽度, 局_顶边) ' 补全剩余宽度的纵向一列
                系统_处理事件 ()
            .计次循环尾 ()
            .如果真 (局_剩余高度 ≠ 0)
                层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_剩余高度, 局_左边 ＋ 局_原宽度, 局_顶边 ＋ 局_原高度) ' 纵向剩余高度 再平铺一张
            .如果真结束
            
        .如果真结束
        
        局_新图片 ＝ 底位图.取出位图数据 ()
    .默认
        局_新图片 ＝ 图片_缩放 (局_原图, 参_设定宽度, 参_设定高度, 真)
    .判断结束
    返回 (局_新图片)

.子程序 图片_到24位图, 字节集, 公开, 把非24位BMP、JPG、GIF的图片转化为24位图
    .参数 参_原图片, 字节集
    .局部变量 局_图片对象, 对象
    .局部变量 局_图片, 字节集

    ' 例程收录自：https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=13978978&pid=10764012
    .如果真 (取字节集左边 (参_原图片, 2) ≠ { 66, 77 } 或 取字节集数据 (参_原图片, #短整数型, 29) ≠ 24)
        .如果真 (局_图片对象.创建图片对象 (参_原图片) ＝ 假)
            返回 ({ })
        .如果真结束
        局_图片 ＝ 局_图片对象.取回图片 ()
        局_图片对象.清除 ()
        返回 (局_图片)
    .如果真结束
    返回 ({ })

.子程序 图片_分割, 逻辑型, 公开
    .参数 参_原图片, 字节集
    .参数 参_横向分割数量, 整数型, 可空, 默认：2
    .参数 参_纵向分割数量, 整数型, 可空, 默认：2
    .参数 参_图片数组, 字节集, 数组
    .局部变量 局_总位图, 类_位图操作
    .局部变量 局_单位图, 类_位图操作
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型
    .局部变量 局_单宽度, 整数型
    .局部变量 局_单高度, 整数型
    .局部变量 局_纵向计次, 整数型
    .局部变量 局_横向计次, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_顶边, 整数型
    .局部变量 局_单图片, 字节集
    .局部变量 局_原图, 字节集

    图片_转换 (参_原图片, 1, , 局_原图, )
    .如果真 (局_总位图.从数据创建 (局_原图) ＝ 假)
        返回 (假)
    .如果真结束
    
    .如果真 (是否为空 (参_横向分割数量))
        参_横向分割数量 ＝ 2
    .如果真结束
    
    .如果真 (是否为空 (参_纵向分割数量))
        参_纵向分割数量 ＝ 2
    .如果真结束
    
    
    局_宽度 ＝ 局_总位图.取宽度 ()
    局_高度 ＝ 局_总位图.取高度 ()
    
    局_单宽度 ＝ 局_宽度 ÷ 参_横向分割数量
    局_单高度 ＝ 局_高度 ÷ 参_纵向分割数量
    
    局_单位图.创建空白位图 (局_单宽度, 局_单高度, 32)
    局_顶边 ＝ 0 － 局_单高度
    .计次循环首 (参_纵向分割数量, 局_纵向计次)
        局_顶边 ＝ 局_顶边 ＋ 局_单高度
        局_左边 ＝ 0 － 局_单宽度
        .计次循环首 (参_横向分割数量, 局_横向计次)
            局_左边 ＝ 局_左边 ＋ 局_单宽度
            局_总位图.复制到 (局_单位图, 局_左边, 局_顶边, 局_单宽度, 局_单高度, 0, 0)
            局_单图片 ＝ 局_单位图.取出位图数据 ()
            加入成员 (参_图片数组, 局_单图片)
        .计次循环尾 ()
        局_左边 ＝ 0 － 局_单宽度
    .计次循环尾 ()
    返回 (真)
    

.子程序 图片_取照片拍摄日期, 逻辑型, 公开
    .参数 参数_文件名, 文本型
    .参数 参_拍摄时间, 文本型, 参考
    .局部变量 StartupInput, GdiplusStartupInput
    .局部变量 token, 整数型
    .局部变量 局_size, 整数型
    .局部变量 局_缓冲区, 字节集
    .局部变量 局_Image, 整数型
    .局部变量 局_位置, 整数型
    .局部变量 局_返回码, 整数型
    .局部变量 i, 整数型

    StartupInput.GdiplusVersion ＝ 1
    GdiplusStartup (token, StartupInput, 0)
    局_返回码 ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (参数_文件名, ), 局_Image)
    .如果真 (局_返回码 ≠ 0)
        返回 (假)
    .如果真结束
    
    局_返回码 ＝ GdipGetPropertyItemSize (局_Image, 36867, 局_size) ' PropertyTagExifDTOrig
    .如果真 (局_返回码 ≠ 0)
        返回 (假)
    .如果真结束
    局_缓冲区 ＝ 取空白字节集 (局_size)
    局_返回码 ＝ GdipGetPropertyItem (局_Image, 36867, 局_size, 局_缓冲区)
    参_拍摄时间 ＝ 到文本 (取字节集中间 (局_缓冲区, 17, 20))
    .如果真 (局_Image ＝ 0)
        返回 (假)
    .如果真结束
    局_返回码 ＝ GdipDisposeImage (局_Image)
    .如果真 (局_返回码 ≠ 0)
        返回 (假)
    .如果真结束
    GdiplusShutdown (token)
    返回 (token ≠ 0)

.子程序 图片_缩放, 字节集, 公开
    .参数 图片, 字节集
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 无损, 逻辑型, 可空, 假为快速 真为无损，默认为假
    .局部变量 对象, 对象
    .局部变量 数据1, 整数型, , "0"
    .局部变量 数据2, 整数型, , "0"
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 位图, 类_位图操作
    .局部变量 c, 整数型
    .局部变量 d, 整数型
    .局部变量 图片缩放, 类_像素组

    ' 命令收集地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14182970
    CoInitialize (0)
    对象.创建图片对象 (图片)
    位图.从数据创建 (对象.取回图片 ())
    CoUninitialize ()
    图片缩放.位图_转_像素组 (位图, 数据1)
    a ＝ 位图.取宽度 ()
    b ＝ 位图.取高度 ()
    c ＝ 宽度
    d ＝ 高度
    .判断开始 (无损 ＝ 假)
        图片缩放.像素组_缩放图片_快速 (数据1, a, b, c, d, 数据2)
    .默认
        图片缩放.像素组_缩放图片_无损 (数据1, a, b, c, d, 数据2)
    .判断结束
    位图.创建空白位图 (1, 1, 24)
    图片缩放.像素组_转_位图 (位图, 数据2, c, d)
    返回 (位图.取出位图数据 ())

.子程序 图片_缩放_透明, 字节集, 公开, @大司命
    .参数 参_图片, 字节集
    .参数 参_宽度, 整数型, 可空, 留空或小于1默认取原来宽度
    .参数 参_高度, 整数型, 可空, 留空或小于1默认取原来高度
    .局部变量 Startup, GdiplusStartupInput
    .局部变量 hMem, 整数型
    .局部变量 nSize, 整数型
    .局部变量 lpStr, 整数型
    .局部变量 ipStr, 整数型
    .局部变量 bitmap, 整数型
    .局部变量 token, 整数型
    .局部变量 bpStr, 整数型
    .局部变量 xpStr, 字节集

    ' 该命令来自：https://bbs.125.la/thread-14322627-1-1.html
    Startup.GdiplusVersion ＝ 1
    GdiplusStartup (token, Startup, 0)
    nSize ＝ 取字节集长度 (参_图片)
    hMem ＝ GlobalAlloc (#GMEM_MOVEABLE, nSize)
    lpStr ＝ GlobalLock (hMem)
    CreateStreamOnHGlobal (hMem, 假, ipStr)
    RtlMoveMemory_字节集 (lpStr, 参_图片, nSize)
    GlobalUnlock (hMem)
    GdipLoadImageFromStream (ipStr, bitmap)
    .如果真 (参_宽度 ＜ 1)
        GdipGetImageWidth (bitmap, 参_宽度)
    .如果真结束
    .如果真 (参_高度 ＜ 1)
        GdipGetImageHeight (bitmap, 参_高度)
    .如果真结束
    GdipGetImageThumbnail (bitmap, 参_宽度, 参_高度, bpStr, 0, 0)
    GdipDisposeImage (bitmap)
    GlobalFree (hMem)
    hMem ＝ GlobalAlloc (位或 (#GMEM_ZEROINIT, #GMEM_MOVEABLE), 0)
    CreateStreamOnHGlobal (hMem, 假, ipStr)
    xpStr ＝ 取空白字节集 (16)
    CLSIDFromString_字节集传址2 ({ 123, 0, 53, 0, 53, 0, 55, 0, 67, 0, 70, 0, 52, 0, 48, 0, 54, 0, 45, 0, 49, 0, 65, 0, 48, 0, 52, 0, 45, 0, 49, 0, 49, 0, 68, 0, 51, 0, 45, 0, 57, 0, 65, 0, 55, 0, 51, 0, 45, 0, 48, 0, 48, 0, 48, 0, 48, 0, 70, 0, 56, 0, 49, 0, 69, 0, 70, 0, 51, 0, 50, 0, 69, 0, 125, 0, 0, 0 }, xpStr)
    GdipSaveImageToStream_字节集 (bpStr, ipStr, xpStr, 0)
    lpStr ＝ GlobalLock (hMem)
    nSize ＝ GlobalSize (hMem)
    xpStr ＝ 指针到字节集 (lpStr, nSize)
    GlobalUnlock (hMem)
    GlobalFree (hMem)
    GdipDisposeImage (bpStr)
    GdiplusShutdown (token)
    返回 (xpStr)

.子程序 加入_RGB
    .参数 颜色, 整数型
    .参数 R, 整数型, 参考
    .参数 G, 整数型, 参考
    .参数 B, 整数型, 参考
    .参数 N, 整数型, 参考
    .局部变量 ls_zjj, 字节集

    ls_zjj ＝ 到字节集 (颜色)
    R ＝ R ＋ ls_zjj [1]
    G ＝ G ＋ ls_zjj [2]
    B ＝ B ＋ ls_zjj [3]
    N ＝ N ＋ 1

.子程序 RGB_整数, 整数型
    .参数 r, 整数型
    .参数 g, 整数型
    .参数 b, 整数型
    .局部变量 shu_, 整数型
    .局部变量 ls_zjj, 字节集

    ls_zjj ＝ 取空白字节集 (4)
    ls_zjj [1] ＝ r
    ls_zjj [2] ＝ g
    ls_zjj [3] ＝ b
    写到内存 (ls_zjj, 取变量地址_字节 (shu_), 4)
    返回 (shu_)

.子程序 图片_拼接, 字节集, 公开, 仅支持bmp格式的图片拼接，如需其他格式的图片请先转换
    .参数 参_图片数组, 文本型, 数组, 图片文件的路径数组
    .参数 参_行总数, 整数型
    .参数 参_列总数, 整数型
    .参数 参_图片宽度, 整数型
    .参数 参_图片高度, 整数型
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 局_单图片, 字节集
    .局部变量 局_总位图, 类_位图操作
    .局部变量 局_单位图, 类_位图操作
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型
    .局部变量 局_位深, 短整数型
    .局部变量 局_目标左, 整数型
    .局部变量 局_目标顶, 整数型
    .局部变量 局_拼接结果, 字节集
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_索引, 整数型

    局_宽度 ＝ 参_图片宽度 × 参_行总数
    局_高度 ＝ 参_图片高度 × 参_列总数
    局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
    .计次循环首 (参_行总数, a)
        局_目标左 ＝ (a － 1) × 参_图片宽度
        .计次循环首 (参_列总数, b)
            局_目标顶 ＝ (b － 1) × 参_图片高度
            局_索引 ＝ 局_索引 ＋ 1
            .如果真 (局_索引 ＞ 取数组成员数 (参_图片数组))
                返回 ({ })
            .如果真结束
            局_单图片 ＝ 读入文件 (参_图片数组 [局_索引])
            局_单图片 ＝ 图片_缩放 (局_单图片, 参_图片宽度, 参_图片高度, 真)
            局_单位图.从数据创建 (局_单图片)
            局_单位图.复制到 (局_总位图, 0, 0, 参_图片宽度, 参_图片高度, 局_目标左, 局_目标顶)
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    局_拼接结果 ＝ 局_总位图.取出位图数据 ()
    返回 (局_拼接结果)

.子程序 图片_拼接1, 字节集, 公开, 两张图片拼接为一张，支持上下拼接和左右拼接，图片自动居中
    .参数 图片1, 字节集
    .参数 图片2, 字节集
    .参数 拼接方式, 逻辑型, , 上下拼接传入：真 左右拼接传入：假
    .参数 合成底色, 整数型, 可空, 默认白底
    .局部变量 _图片1, 字节集
    .局部变量 _图片2, 字节集
    .局部变量 局_总位图, 类_位图操作
    .局部变量 局_单位图, 类_位图操作
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型
    .局部变量 局_拼接结果, 字节集
    .局部变量 y, 整数型
    .局部变量 x, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_顶边, 整数型

    ' 源码收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14339636
    图片_转换 (图片1, 1, , _图片1, )
    图片_转换 (图片2, 1, , _图片2, )
    .如果真 (合成底色 ＝ 0)
        合成底色 ＝ #白色
    .如果真结束
    .如果 (拼接方式)
        ' 上下拼接取最宽宽度
        局_宽度 ＝ 图片_取宽度 (_图片1)
        .如果真 (局_宽度 ＜ 图片_取宽度 (_图片2))
            局_宽度 ＝ 图片_取宽度 (_图片2)
        .如果真结束
        ' 上下拼接取两张图片高度和
        局_高度 ＝ 图片_取高度 (_图片1) ＋ 图片_取高度 (_图片2)
        
        局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
        
        .计次循环首 (局_宽度, x)
            .计次循环首 (局_高度, y)
                局_总位图.置某点颜色 (x － 1, y － 1, 合成底色)
            .计次循环尾 ()
        .计次循环尾 ()
        
        局_左边 ＝ 0
        .如果真 (图片_取宽度 (_图片1) ≠ 局_宽度)
            局_左边 ＝ 到整数 ((局_宽度 － 图片_取宽度 (_图片1)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片1)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片1), 图片_取高度 (_图片1), 局_左边, 0)
        处理事件 ()
        局_左边 ＝ 0
        .如果真 (图片_取宽度 (_图片2) ≠ 局_宽度)
            局_左边 ＝ 到整数 ((局_宽度 － 图片_取宽度 (_图片2)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片2)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片2), 图片_取高度 (_图片2), 局_左边, 图片_取高度 (_图片1))
        处理事件 ()
        
    .否则
        
        ' 左右拼接取最高高度
        局_高度 ＝ 图片_取高度 (_图片1)
        .如果真 (局_高度 ＜ 图片_取高度 (_图片2))
            局_高度 ＝ 图片_取高度 (_图片2)
        .如果真结束
        ' 左右拼接取两张图片宽度和
        局_宽度 ＝ 图片_取宽度 (_图片1) ＋ 图片_取宽度 (_图片2)
        
        局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
        
        .计次循环首 (局_宽度, x)
            .计次循环首 (局_高度, y)
                局_总位图.置某点颜色 (x － 1, y － 1, 合成底色)
            .计次循环尾 ()
        .计次循环尾 ()
        
        局_顶边 ＝ 0
        .如果真 (图片_取高度 (_图片1) ≠ 局_高度)
            局_顶边 ＝ 到整数 ((局_高度 － 图片_取高度 (_图片1)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片1)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片1), 图片_取高度 (_图片1), 0, 局_顶边)
        处理事件 ()
        局_顶边 ＝ 0
        .如果真 (图片_取高度 (_图片2) ≠ 局_高度)
            局_顶边 ＝ 到整数 ((局_高度 － 图片_取高度 (_图片2)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片2)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片2), 图片_取高度 (_图片2), 图片_取宽度 (_图片1), 局_顶边)
        处理事件 ()
    .如果结束
    局_拼接结果 ＝ 局_总位图.取出位图数据 ()
    返回 (局_拼接结果)

.子程序 RGB2ARGB, 整数型
    .参数 RGB颜色, 整数型
    .参数 透明度, 整数型, 可空, 0-255
    .局部变量 Color, 字节集

    .如果真 (是否为空 (透明度))
        透明度 ＝ 255
    .如果真结束
    Color ＝ 到字节集 (RGB颜色)
    RGB颜色 ＝ 位或 (Color [3] ＋ Color [2] × 256 ＋ Color [1] × 65536, 左移 (透明度, 24)) ' 转换成GDI+的颜色值
    返回 (RGB颜色)

.子程序 图片_高斯模糊, 字节集, 公开, BMP
    .参数 参_BMP图片, 字节集
    .参数 参_衰减, 整数型, 可空
    .局部变量 BMP图片宽度, 整数型
    .局部变量 BMP图片高度, 整数型
    .局部变量 BMP起始位置, 整数型
    .局部变量 i, 整数型
    .局部变量 BMPY, 整数型
    .局部变量 BMPX, 整数型
    .局部变量 当前x, 整数型
    .局部变量 当前y, 整数型
    .局部变量 平均R, 整数型
    .局部变量 平均B, 整数型
    .局部变量 平均G, 整数型
    .局部变量 当前R, 整数型
    .局部变量 当前G, 整数型
    .局部变量 当前B, 整数型
    .局部变量 当前N, 整数型
    .局部变量 Y, 整数型
    .局部变量 输出BMP, 字节集
    .局部变量 衰减_整数, 整数型

    输出BMP ＝ 参_BMP图片
    BMP起始位置 ＝ 参_BMP图片 [3]
    BMP图片宽度 ＝ 参_BMP图片 [19] ＋ 参_BMP图片 [20] × 256
    BMP图片高度 ＝ 参_BMP图片 [23] ＋ 参_BMP图片 [24] × 256
    衰减_整数 ＝ 0
    .如果真 (是否为空 (参_衰减) ＝ 假)
        衰减_整数 ＝ 参_衰减
    .如果真结束
    .变量循环首 (0, BMP图片高度 － 1, 1, BMPY)
        .变量循环首 (0, BMP图片宽度 － 1, 1, BMPX)
            平均R ＝ 0
            平均G ＝ 0
            平均B ＝ 0
            当前N ＝ 0
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX － 1, BMPY, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX ＋ 1, BMPY, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX, BMPY ＋ 1, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX, BMPY － 1, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            平均B ＝ 取整 (平均B ÷ 当前N) － 衰减_整数
            平均G ＝ 取整 (平均G ÷ 当前N) － 衰减_整数
            平均R ＝ 取整 (平均R ÷ 当前N) － 衰减_整数
            .如果真 (平均B ＜ 0)
                平均B ＝ 0
            .如果真结束
            .如果真 (平均G ＜ 0)
                平均G ＝ 0
            .如果真结束
            .如果真 (平均R ＜ 0)
                平均R ＝ 0
            .如果真结束
            输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 1] ＝ 平均B
            输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 2] ＝ 平均G
            输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 3] ＝ 平均R
        .变量循环尾 ()
    .变量循环尾 ()
    返回 (输出BMP)

.子程序 图片_取像素RGB, 逻辑型, 公开
    .参数 BMP图片, 字节集
    .参数 图片X, 整数型
    .参数 图片Y, 整数型
    .参数 图片R, 整数型, 参考
    .参数 图片G, 整数型, 参考
    .参数 图片B, 整数型, 参考
    .局部变量 BMP图片宽度, 整数型
    .局部变量 BMP图片高度, 整数型
    .局部变量 BMP起始位置, 整数型

    BMP起始位置 ＝ BMP图片 [3]
    BMP图片宽度 ＝ BMP图片 [19] ＋ BMP图片 [20] × 256
    BMP图片高度 ＝ BMP图片 [23] ＋ BMP图片 [24] × 256
    .如果真 (图片X ＜ 0 或 图片X ≥ BMP图片宽度)
        返回 (假)
    .如果真结束
    .如果真 (图片Y ＜ 0 或 图片Y ≥ BMP图片高度)
        返回 (假)
    .如果真结束
    图片B ＝ BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 1]
    图片G ＝ BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 2]
    图片R ＝ BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 3]
    返回 (真)

.子程序 图片_置像素RGB, 逻辑型, 公开
    .参数 BMP图片, 字节集
    .参数 图片X, 整数型
    .参数 图片Y, 整数型
    .参数 图片R, 整数型
    .参数 图片G, 整数型
    .参数 图片B, 整数型
    .局部变量 BMP图片宽度, 整数型
    .局部变量 BMP图片高度, 整数型
    .局部变量 BMP起始位置, 整数型

    BMP起始位置 ＝ BMP图片 [3]
    BMP图片宽度 ＝ BMP图片 [19] ＋ BMP图片 [20] × 256
    BMP图片高度 ＝ BMP图片 [23] ＋ BMP图片 [24] × 256
    .如果真 (图片X ＜ 0 或 图片X ≥ BMP图片宽度)
        返回 (假)
    .如果真结束
    .如果真 (图片Y ＜ 0 或 图片Y ≥ BMP图片高度)
        返回 (假)
    .如果真结束
    BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 1] ＝ 图片B
    BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 2] ＝ 图片G
    BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 3] ＝ 图片R
    返回 (真)

.子程序 图片_加水印, 字节集, 公开, 给24位图加水印,如不是24位图请先转换
    .参数 源图_图数据, 字节集
    .参数 水印_图数据, 字节集
    .参数 水印图_左边, 整数型, 可空, 默认：水印右边空白留20，水印左边程序自动计算
    .参数 水印图_顶边, 整数型, 可空, 默认：水印底边空白留20，水印顶边程序自动计算
    .参数 透明颜色, 整数型, 可空, 默认：白色
    .局部变量 图数据, 字节集
    .局部变量 原图_头长
    .局部变量 原图_宽
    .局部变量 原图_高
    .局部变量 原图_纠正位
    .局部变量 原图_图数宽
    .局部变量 原图_图数长
    .局部变量 原图_大小
    .局部变量 水印_图头长
    .局部变量 水印_宽
    .局部变量 水印_高
    .局部变量 水印_纠正位
    .局部变量 水印_图数宽
    .局部变量 水印_图数长
    .局部变量 水印_大小
    .局部变量 加左边
    .局部变量 加顶边
    .局部变量 首点1
    .局部变量 首点2
    .局部变量 计次1
    .局部变量 局_偏移

    .如果真 (取字节集数据 (源图_图数据, #短整数型, 29) ≠ 24 或 取字节集数据 (水印_图数据, #短整数型, 29) ≠ 24)
        返回 ({ })
    .如果真结束
    透明颜色 ＝ 选择 (是否为空 (透明颜色), 16777215, 透明颜色)
    原图_头长 ＝ 取字节集数据 (源图_图数据, #短整数型, 11)
    原图_宽 ＝ 取字节集数据 (源图_图数据, #整数型, 19)
    原图_高 ＝ 取字节集数据 (源图_图数据, #整数型, 23)
    原图_纠正位 ＝ 位与 (原图_宽, 3)
    原图_图数宽 ＝ 原图_宽 × 3 ＋ 原图_纠正位
    原图_图数长 ＝ 原图_图数宽 × 原图_高
    原图_大小 ＝ 原图_图数长 ＋ 原图_头长
    水印_图头长 ＝ 取字节集数据 (水印_图数据, #短整数型, 11)
    水印_宽 ＝ 取字节集数据 (水印_图数据, #整数型, 19)
    水印_高 ＝ 取字节集数据 (水印_图数据, #整数型, 23)
    水印_纠正位 ＝ 位与 (水印_宽, 3)
    水印_图数宽 ＝ 水印_宽 × 3 ＋ 水印_纠正位
    水印_图数长 ＝ 水印_图数宽 × 水印_高
    水印_大小 ＝ 水印_图数长 ＋ 水印_图头长
    .如果真 (是否为空 (水印图_左边))
        水印图_左边 ＝ 原图_宽 － 水印_宽 － 20
    .如果真结束
    .如果真 (是否为空 (水印图_顶边))
        水印图_顶边 ＝ 原图_高 － 水印_高 － 20
    .如果真结束
    .如果真 (水印图_左边 ＜ 0)
        水印图_左边 ＝ 0
    .如果真结束
    .如果真 (水印图_顶边 ＜ 0)
        水印图_顶边 ＝ 0
    .如果真结束
    .如果真 (原图_高 ＜ 水印_高)
        水印_高 ＝ 原图_高
    .如果真结束
    .如果真 (原图_宽 ＜ 水印_宽)
        水印_宽 ＝ 原图_宽
    .如果真结束
    .如果真 (原图_宽 － 水印图_左边 － 水印_宽 ＜ 0)
        水印_宽 ＝ 原图_宽 － 水印图_左边
    .如果真结束
    .如果真 (原图_高 － 水印图_顶边 － 水印_高 ＜ 0)
        水印_高 ＝ 原图_高 － 水印图_顶边
    .如果真结束
    图数据 ＝ 源图_图数据
    .计次循环首 (水印_高, 计次1)
        首点1 ＝ 原图_大小 － (水印图_顶边 ＋ 计次1) × 原图_图数宽 ＋ 水印图_左边 × 3
        首点2 ＝ 水印_大小 － 计次1 × 水印_图数宽
        .计次循环首 (水印_宽, )
            .如果真 (取颜色值 (水印_图数据 [首点2 ＋ 3], 水印_图数据 [首点2 ＋ 2], 水印_图数据 [首点2 ＋ 1]) ≠ 透明颜色)
                图数据 [首点1 ＋ 1] ＝ 水印_图数据 [首点2 ＋ 1]
                图数据 [首点1 ＋ 2] ＝ 水印_图数据 [首点2 ＋ 2]
                图数据 [首点1 ＋ 3] ＝ 水印_图数据 [首点2 ＋ 3]
            .如果真结束
            首点1 ＝ 首点1 ＋ 3
            首点2 ＝ 首点2 ＋ 3
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (图数据)

.子程序 图片_转换, 逻辑型, 公开, 支持bmp、jpg、gif、tiff、png互转；成功返回转换好的图片数据，失败返回空字节集；
    .参数 图像数据, 字节集, , 被转换的图像数据；
    .参数 转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；
    .参数 保存路径, 文本型, 可空, 把转换后的图像保存到指定位置；
    .参数 返回数据, 字节集, 参考 可空, 变量储存返回数据.
    .参数 含透明色, 逻辑型, 可空, 转换PNG图片时是否需要处理透明色，可为空，默认不处理。
    .局部变量 新图像, 字节集, , , 用于保存新图像的变量
    .局部变量 Clsid, GUID
    .局部变量 pStr, 文本型
    .局部变量 hMem, 整数型
    .局部变量 Stream
    .局部变量 lpvoid, 整数型
    .局部变量 pStream, 整数型
    .局部变量 bitmap, 整数型
    .局部变量 DataStream
    .局部变量 hMemDataStream, 整数型
    .局部变量 pDataStream, 整数型
    .局部变量 nStreamSize, 整数型
    .局部变量 bRet, 逻辑型
    .局部变量 GpInput, GdiplusStartupInput
    .局部变量 局_Token, 整数型
    .局部变量 局_hBitMap, 整数型
    .局部变量 局_后缀名, 文本型

    .如果真 (取字节集长度 (图像数据) ＜ 3)
        返回 (假)
    .如果真结束
    GpInput.GdiplusVersion ＝ 1
    GdiplusStartup (局_Token, GpInput, 0) ' 启动GDI+
    .判断开始 (转换格式 ＝ 1) ' bmp
        pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.bmp”
    .判断 (转换格式 ＝ 2) ' jpg
        pStr ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.jpg”
    .判断 (转换格式 ＝ 3) ' gif
        pStr ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.gif”
    .判断 (转换格式 ＝ 4) ' tiff
        pStr ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.tiff”
    .判断 (转换格式 ＝ 5) ' png
        pStr ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.png”
    .默认
        
    .判断结束
    
    
    Clsid ＝ COM_StringToCLSID (pStr)
    hMem ＝ GlobalAlloc (2, 取字节集长度 (图像数据)) ' 分配内存
    CreateStreamOnHGlobal (hMem, 假, Stream)
    
    lpvoid ＝ GlobalLock (hMem)
    写到内存 (图像数据, lpvoid, 取字节集长度 (图像数据))
    GlobalUnlock (hMem)
    
    pStream ＝ lstrcpyn_整数型 (Stream, Stream, 0)
    GDIpCreateBitmapFromStream (取字节集数据 (指针到字节集 (pStream, 4), #整数型, ), bitmap)
    .如果真 (含透明色)
        GdipCreateHBITMAPFromBitmap (bitmap, 局_hBitMap, #白色)
        GdipCreateBitmapFromHBITMAP (局_hBitMap, 0, bitmap)
    .如果真结束
    
    CreateStreamOnHGlobal (0, 真, DataStream)
    pStream ＝ lstrcpyn_整数型 (DataStream, DataStream, 0)
    pStream ＝ 取字节集数据 (指针到字节集 (pStream, 4), #整数型, )
    
    GDIpSaveImageToStream_GUID (bitmap, pStream, Clsid, 0)
    GetHGlobalFromStream (pStream, hMemDataStream)
    pDataStream ＝ GlobalLock (hMemDataStream)
    nStreamSize ＝ GlobalSize (hMemDataStream)
    .如果真 (pDataStream ≠ 0)
        新图像 ＝ 取空白字节集 (nStreamSize)
        RtlMoveMemory_int2Bytes (新图像, pDataStream, nStreamSize)
        .如果真 (删首尾空 (保存路径) ≠ “”)
            写到文件 (选择 (到小写 (取文本右边 (保存路径, 取文本长度 (局_后缀名))) ≠ 到小写 (局_后缀名), 保存路径 ＋ 局_后缀名, 保存路径), 新图像)
        .如果真结束
        返回数据 ＝ 新图像
        bRet ＝ 真
    .如果真结束
    COM_Release (Stream)
    COM_Release (DataStream)
    GlobalUnlock (hMemDataStream)
    GlobalFree (hMemDataStream)
    GdipDisposeImage (bitmap)
    GlobalFree (hMem)
    GdiplusShutdown (局_Token) ' GDI关闭 +
    返回 (bRet)

.子程序 图片_转换1, 字节集, 公开
    .参数 参_原始图片, 字节集
    .参数 参_转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；
    .参数 参_输出质量, 整数型, , 0-100
    .局部变量 局_图像转换, 类_图像格式转换类
    .局部变量 局_转换结果, 字节集

    .如果真 (局_图像转换.载入图像 (参_原始图片) ＝ 假)
        返回 ({ })
    .如果真结束
    局_转换结果 ＝ 局_图像转换.转换到字节集 (参_转换格式, 参_输出质量)
    返回 (局_转换结果)

.子程序 图片_转换Ex, 字节集, 公开, 支持bmp、jpg、gif、tiff、png互转；成功返回转换好的图片数据，失败返回空字节集；
    .参数 图像数据, 字节集, , 被转换的图像数据；
    .参数 转换格式, 整数型, 可空, 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；其他=png；
    .参数 保存路径, 文本型, 可空, 把转换后的图像保存到指定位置；
    .参数 含透明色, 逻辑型, 可空, 转换PNG图片时是否需要处理透明色，可为空，默认不处理。
    .局部变量 Clsid, 字节集, , , 转换标志
    .局部变量 szText, 文本型, , , gdi+图片转换标志
    .局部变量 hMem, 整数型, , , 原图片存放的内存句柄
    .局部变量 hMemData, 整数型, , , 转换后的图片内存句柄
    .局部变量 hBmp, 整数型, , , 从流指针里创建的位图句柄
    .局部变量 hBmp1, 整数型, , , 位图
    .局部变量 pStream, 整数型, , , 原图片流对象指针
    .局部变量 pAddrStream, 整数型, , , 原图片内存地址,图片数据写入这里
    .局部变量 pDataStream, 整数型, , , 转换后图片流对象指针
    .局部变量 pAddrDataStream, 整数型, , , 图片转换后的内存地址
    .局部变量 dwLen, 整数型, , , 转换后图片的大小
    .局部变量 Ret, 字节集, , , 返回值
    .局部变量 Token, 整数型, , , gdi+token
    .局部变量 扩展名, 文本型
    .局部变量 Error, 整数型, , , gdi+错误代码
    .局部变量 input, GdiplusStartupInput
    .局部变量 wzText, 字节集

    .如果真 (取字节集长度 (图像数据) ＜ 3)
        返回 ({ })
    .如果真结束
    ' Clsid ＝ 取空白字节集 (16)  ' 临时借用一下这个变量做缓冲区,相当于 GdiplusStartupInput 这个数据结构,4个成员
    ' __set (取指针_字节集型 (Clsid), 0, 1)  ' 设置 第一个成员 GdiplusVersion 为1
    ' Error ＝ GdiplusStartupA (Token, 取指针_字节集型 (Clsid), 0)  ' 启动GDI+
    input.GdiplusVersion ＝ 1
    Error ＝ GdiplusStartup (Token, input, 0) ' 启动GDI+
    .如果真 (Error ≠ 0)
        返回 ({ })
    .如果真结束
    .判断开始 (转换格式 ＝ 1) ' bmp
        szText ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.bmp”
    .判断 (转换格式 ＝ 2) ' jpg
        szText ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.jpg”
    .判断 (转换格式 ＝ 3) ' gif
        szText ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.gif”
    .判断 (转换格式 ＝ 4) ' tiff
        szText ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.tiff”
    .默认
        szText ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.png”
    .判断结束
    
    
    Clsid ＝ 取空白字节集 (16)
    wzText ＝ A2W (szText, )
    CLSIDFromString (取指针_字节集型 (wzText), Clsid)
    
    
    hMem ＝ GlobalAlloc (66, 取字节集长度 (图像数据)) ' 申请内存
    pAddrStream ＝ GlobalLock (hMem) ' 锁定内存,返回这个内存句柄的内存首地址
    RtlMoveMemory_整数型 (pAddrStream, 取指针_字节集型 (图像数据), 取字节集长度 (图像数据)) ' 把图片数据写入这个内存
    .如果真 (GlobalUnlock (hMem) ≠ 0) ' 解锁内存
        集_转换错误 ＝ “解锁原图片内存失败”
    .如果真结束
    
    CreateStreamOnHGlobal_整数型 (hMem, 0, pStream) ' 创建流对象
    Error ＝ GDIpCreateBitmapFromStream (pStream, hBmp) ' 从流里创建位图
    .如果真 (Error ≠ 0)
        SafeRelease (pStream) ' 释放流对象
        .如果真 (GlobalFree (hMem) ≠ 0) ' 释放内存
            集_转换错误 ＝ “从流里创建位图失败,并且释放内存失败”
        .如果真结束
        返回 ({ })
    .如果真结束
    
    .如果真 (含透明色)
        GdipCreateHBITMAPFromBitmap (hBmp, hBmp1, #白色) ' 返回位图句柄。需要调用 DeleteObject 释放
        GdipCreateBitmapFromHBITMAP (hBmp1, 0, hBmp)
    .如果真结束
    
    CreateStreamOnHGlobal_整数型 (0, 0, pDataStream) ' 创建流,从这个流里取转换后的数据
    GdipSaveImageToStream_字节集 (hBmp, pDataStream, Clsid, 0) ' 转换图片
    GetHGlobalFromStream (pDataStream, hMemData) ' 从流里获取内存句柄
    
    pAddrDataStream ＝ GlobalLock (hMemData) ' 锁定内存句柄
    dwLen ＝ GlobalSize (hMemData) ' 取转换后内存大小
    .如果真 (pAddrDataStream ≠ 0)
        Ret ＝ 取空白字节集 (dwLen) ' 缓冲区
        RtlMoveMemory_整数型 (取指针_字节集型 (Ret), pAddrDataStream, dwLen) ' 把转换后的图片数据写入到缓冲区
        .如果真 (删首尾空 (保存路径) ≠ “”)
            写到文件 (选择 (到小写 (取文本右边 (保存路径, 取文本长度 (扩展名))) ≠ 到小写 (扩展名), 保存路径 ＋ 扩展名, 保存路径), Ret)
        .如果真结束
        
    .如果真结束
    SafeRelease (pStream) ' 释放原图片流对象
    SafeRelease (pDataStream) ' 释放转换后流对象
    .如果真 (GlobalUnlock (hMemData) ≠ 0) ' 解锁转换后的内存
        集_转换错误 ＝ “解锁转换后的内存失败”
    .如果真结束
    
    .如果真 (GlobalFree (hMemData) ≠ 0) ' 释放转换后的内存
        集_转换错误 ＝ “释放转换后的内存失败”
    .如果真结束
    
    .如果真 (hBmp1 ≠ 0)
        .如果真 (DeleteObject (hBmp1) ＝ 0) ' 删除位图
            集_转换错误 ＝ “删除位图失败”
        .如果真结束
        
    .如果真结束
    Error ＝ GdipDisposeImage (hBmp) ' 释放gdi+位图
    .如果真 (Error ≠ 0)
        集_转换错误 ＝ “释放gdi+位图失败”
    .如果真结束
    .如果真 (GlobalFree (hMem) ≠ 0) ' 释放第一个申请的内存
        集_转换错误 ＝ “释放原图片内存失败”
    .如果真结束
    GdiplusShutdown (Token) ' 关闭 gdi+
    返回 (Ret)

.子程序 图片_转换Ex_取最后错误, 文本型, 公开
    返回 (集_转换错误)

.子程序 图标_取数量, 整数型, 公开, 取出文件的图标数量
    .参数 文件路径, 文本型

    返回 (ExtractIconA (0, 文件路径, -1))

.子程序 图片_取句柄, 整数型, 公开, 取图片句柄,成功返回图片句柄,失败返回0
    .参数 参_图片, 字节集, , 欲添加为菜单图片的资源
    .局部变量 局_对象, 对象, 静态, "0"
    .局部变量 局_句柄, 整数型
    .局部变量 局_成员数, 整数型

    局_成员数 ＝ 取数组成员数 (局_对象) ＋ 1
    重定义数组 (局_对象, 真, 局_成员数)
    CoInitialize (0)
    .如果真 (局_对象 [局_成员数].创建图片对象 (参_图片))
        CoUninitialize ()
        返回 (局_对象 [局_成员数].读数值属性 (“handle”, ))
    .如果真结束
    CoUninitialize ()
    返回 (0)

.子程序 图标_取句柄, 整数型, 公开, 取“位图 鼠标图片 图标“句柄,成功返回句柄,失败返回0
    .参数 图片路径, 文本型
    .参数 图像类型, 整数型, 可空, IMAGE_ 开头的常量  默认为 #IMAGE_ICON 图标
    .局部变量 局_图片高度, 整数型
    .局部变量 局_图片宽度, 整数型

    局_图片宽度 ＝ GetSystemMetrics (71)
    局_图片高度 ＝ GetSystemMetrics (72) ' SM_CYMENUCHECK 获取菜单复选号位图的大小
    .如果真 (是否为空 (图像类型))
        图像类型 ＝ #IMAGE_ICON
    .如果真结束
    返回 (LoadImage (0, 图片路径, 图像类型, 局_图片宽度, 局_图片高度, 16))

.子程序 颜色_取反色, 整数型, 公开, 取一个颜色的反色
    .参数 要取反色的10进程颜色, 整数型
    .局部变量 bin, 字节集

    bin ＝ 到字节集 (要取反色的10进程颜色)
    bin [1] ＝ 255 － bin [1]
    bin [2] ＝ 255 － bin [2]
    bin [3] ＝ 255 － bin [3]
    返回 (取字节集数据 (bin, #整数型, ))

.子程序 图片_后台截图, 字节集, 公开
    .参数 窗口句柄, 整数型, , 要截取的图片的窗口句柄
    .局部变量 矩形区域, 精易_矩形J
    .局部变量 屏幕设备上下文句柄, 整数型
    .局部变量 内存设备上下文句柄, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 旧位图句柄, 整数型
    .局部变量 位图, BITMAP
    .局部变量 位图像素点阵, 字节集
    .局部变量 位图文件头, BITMAPFILEHEADER
    .局部变量 位图文件头字节集, 字节集
    .局部变量 位图信息, BITMAPINFO
    .局部变量 位图信息字节集, 字节集

    .如果真 (取反 (窗口_句柄是否有效 (窗口句柄)))
        返回 ({ })
    .如果真结束
    GetWindowRect (窗口句柄, 矩形区域)
    屏幕设备上下文句柄 ＝ GetDC (0)
    内存设备上下文句柄 ＝ CreateCompatibleDC (屏幕设备上下文句柄)
    位图句柄 ＝ CreateCompatibleBitmap (屏幕设备上下文句柄, 矩形区域.右边 － 矩形区域.左边, 矩形区域.底边 － 矩形区域.顶边)
    旧位图句柄 ＝ SelectObject (内存设备上下文句柄, 位图句柄)
    .如果真 (取反 (PrintWindow (窗口句柄, 内存设备上下文句柄, 0)))
        SelectObject (内存设备上下文句柄, 旧位图句柄)
        DeleteObject (位图句柄)
        DeleteDC (内存设备上下文句柄)
        ReleaseDC (0, 屏幕设备上下文句柄)
        返回 ({ })
    .如果真结束
    GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
    位图信息.BITMAPINFOHEADER.biSize ＝ 4 × 11
    GetDIBits1 (内存设备上下文句柄, 位图句柄, 0, 0, 0, 位图信息, 0)
    位图像素点阵 ＝ 取空白字节集 (位图信息.BITMAPINFOHEADER.biSizeImage)
    位图信息.BITMAPINFOHEADER.biCompression ＝ 0
    GetDIBits (内存设备上下文句柄, 位图句柄, 0, 位图.bmHeight, 位图像素点阵, 位图信息, 0)
    ' 构造位图信息
    位图信息字节集 ＝ 取空白字节集 (位图信息.BITMAPINFOHEADER.biSize)
    RtlMoveMemory_BITMAPINFO (位图信息字节集, 位图信息, 位图信息.BITMAPINFOHEADER.biSize)
    ' 构造位图文件头
    位图文件头.bfType ＝ 19778
    位图文件头.bfOffBits ＝ 2 × 4 ＋ 3 × 2 ＋ 位图信息.BITMAPINFOHEADER.biSize
    位图文件头.bfSize ＝ 位图文件头.bfOffBits ＋ 位图信息.BITMAPINFOHEADER.biSizeImage
    位图文件头.bfReserved1 ＝ 0
    位图文件头.bfReserved2 ＝ 0
    位图文件头字节集 ＝ 取空白字节集 (14)
    RtlMoveMemory_BITMAPFILEHEADER (位图文件头字节集, 位图文件头, 14)
    SelectObject (内存设备上下文句柄, 旧位图句柄)
    DeleteObject (位图句柄)
    DeleteDC (内存设备上下文句柄)
    ReleaseDC (0, 屏幕设备上下文句柄)
    返回 (位图文件头字节集 ＋ 位图信息字节集 ＋ 位图像素点阵)

.子程序 图片_后台区域截图, 字节集, 公开, 可后台截取指定位置大小的图片。窗口不能最小化，否则会导致截取失败。
    .参数 窗口句柄, 整数型, , 要截取的图片的窗口句柄
    .参数 欲截取的左边, 整数型
    .参数 欲截取的顶边, 整数型
    .参数 欲截取的宽度, 整数型
    .参数 欲截取的高度, 整数型

    返回 (图片_取图片区域 (图片_后台截图 (窗口句柄), 欲截取的左边, 欲截取的顶边, 欲截取的宽度, 欲截取的高度))

.子程序 图片_取图片区域, 字节集, 公开, 提供一张图片，取出指定位置大小的图片。
    .参数 原位图, 字节集, , 24位BMP位图
    .参数 图片左边, 整数型, , 欲取出的图片左边
    .参数 图片顶边, 整数型, , 欲取出的图片顶边
    .参数 图片宽度, 整数型, , 欲取出的图片宽度
    .参数 图片高度, 整数型, , 欲取出的图片高度
    .局部变量 图像宽度, 整数型
    .局部变量 图像高度, 整数型
    .局部变量 图像位数, 整数型
    .局部变量 图像压缩, 整数型
    .局部变量 新位图, 字节集
    .局部变量 新位图信息头, BITMAPINFOHEADER
    .局部变量 新位图文件头, BITMAPFILEHEADER
    .局部变量 文件长度, 整数型
    .局部变量 i, 整数型
    .局部变量 颜色点阵偏移量, 整数型
    .局部变量 点的大小, 整数型
    .局部变量 颜色表, 字节集
    .局部变量 总数据偏移, 整数型
    .局部变量 新行宽, 整数型
    .局部变量 原行宽, 整数型
    .局部变量 时间, 整数型

    图像宽度 ＝ 取字节集数据 (取字节集中间 (原位图, 19, 4), #整数型, )
    图像高度 ＝ 取字节集数据 (取字节集中间 (原位图, 23, 4), #整数型, )
    图像位数 ＝ 取字节集数据 (取字节集中间 (原位图, 29, 2), #短整数型, )
    图像压缩 ＝ 取字节集数据 (取字节集中间 (原位图, 31, 4), #整数型, )
    .如果真 (图像压缩 ≠ 0)
        返回 ({ })
    .如果真结束
    .如果真 (图像位数 ＝ 32)
        颜色点阵偏移量 ＝ 54
        点的大小 ＝ 4
    .如果真结束
    .如果真 (图像位数 ＝ 24)
        颜色点阵偏移量 ＝ 54
        点的大小 ＝ 3
    .如果真结束
    .如果真 (图像位数 ＝ 16)
        颜色点阵偏移量 ＝ 54
        点的大小 ＝ 2
    .如果真结束
    .如果真 (图像位数 ＝ 8)
        颜色点阵偏移量 ＝ 1078
        点的大小 ＝ 1
        颜色表 ＝ 取字节集中间 (原位图, 55, 1024)
    .如果真结束
    .如果真 (图像位数 ＜ 8)
        输出调试文本 (“错误！ 图像位深小于8！”)
        返回 ({ })
    .如果真结束
    ' 输出调试文本 (“参数错误！请检查输入的参数！”)
    ' 返回 ({  })
    
    .如果真 (图片左边 ＜ 0)
        图片左边 ＝ 0
    .如果真结束
    .如果真 (图片顶边 ＜ 0)
        图片顶边 ＝ 0
    .如果真结束
    .如果真 (图片左边 ＞ 图像宽度 或 图片顶边 ＞ 图像高度)
        输出调试文本 (“参数错误，错误原因：图片左边或图片顶边小于截取出来图片的宽度或高度”)
        返回 ({ })
    .如果真结束
    .如果真 (图片宽度 ≤ 0 或 图片高度 ≤ 0)
        输出调试文本 (“参数错误，错误原因：图片宽度或图片高度小于等于0”)
        返回 ({ })
    .如果真结束
    .如果真 (图片左边 ＋ 图片宽度 ＞ 图像宽度)
        图片宽度 ＝ 图像宽度 － 图片左边
    .如果真结束
    .如果真 (图片顶边 ＋ 图片高度 ＞ 图像高度)
        图片高度 ＝ 图像高度 － 图片顶边
    .如果真结束
    
    原行宽 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2)
    新行宽 ＝ 左移 (右移 (图片宽度 × 图像位数 ＋ 31, 5), 2)
    文件长度 ＝ 新行宽 × 图片高度
    新位图 ＝ 取空白字节集 (文件长度 ＋ 54 ＋ 取字节集长度 (颜色表))
    新位图文件头.bfType ＝ 19778
    新位图文件头.bfOffBits ＝ 颜色点阵偏移量
    新位图文件头.bfSize ＝ 颜色点阵偏移量 ＋ 文件长度
    RtlMoveMemory_BITMAPFILEHEADER_字节型 (新位图 [1], 新位图文件头, 14)
    新位图信息头.biSize ＝ 40
    新位图信息头.biWidth ＝ 图片宽度
    新位图信息头.biHeight ＝ 图片高度
    新位图信息头.biPlanes ＝ 1
    新位图信息头.biBitCount ＝ 图像位数
    RtlMoveMemory_BITMAPINFOHEADER (新位图 [15], 新位图信息头, 40)
    .如果真 (图像位数 ＝ 8)
        RtlMoveMemory_字节型 (新位图 [55], 颜色表 [1], 1024)
    .如果真结束
    总数据偏移 ＝ 原行宽 × (图像高度 － 图片高度 － 图片顶边) ＋ 图片左边 × 点的大小 ' 总偏移=高偏移+宽偏移
    .计次循环首 (图片高度, i)
        RtlMoveMemory_字节型 (新位图 [(i － 1) × 新行宽 ＋ 颜色点阵偏移量 ＋ 1], 原位图 [颜色点阵偏移量 ＋ 总数据偏移 ＋ (i － 1) × 原行宽 ＋ 1], 新行宽)
    .计次循环尾 ()
    返回 (新位图)

.子程序 图片_屏幕截图, 字节集, 公开, 截取桌面指定大小的图片
    .参数 屏幕宽度, 整数型
    .参数 屏幕高度, 整数型
    .参数 图片位数, 整数型, 可空, 这里支持 4 8 24 32 默认是24位图!
    .局部变量 桌面句柄, 整数型
    .局部变量 源场景, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 位图像素点阵, 字节集
    .局部变量 位图文件头, BITMAPFILEHEADER
    .局部变量 位图文件头字节集, 字节集
    .局部变量 位图信息, 位图信息_
    .局部变量 位图信息字节集, 字节集
    .局部变量 颜色表, 字节集
    .局部变量 颜色表大小, 整数型

    .判断开始 (图片位数 ＝ 0)
        位图信息.位深度 ＝ 24
    .默认
        位图信息.位深度 ＝ 图片位数
    .判断结束
    位图信息.位图位面数 ＝ 1
    位图信息.位图宽度 ＝ 屏幕宽度
    位图信息.位图高度 ＝ 屏幕高度
    位图信息.位图大小 ＝ 位图信息.位图宽度 × 位图信息.位图高度 × 位图信息.位深度 ÷ 8
    位图信息.结果大小 ＝ 40
    位图信息.压缩率 ＝ 0
    
    颜色表大小 ＝ 取位图深度 (位图信息.位深度)
    位图像素点阵 ＝ 取空白字节集 (位图信息.位图大小)
    颜色表 ＝ 取空白字节集 (颜色表大小)
    桌面句柄 ＝ GetDC (0)
    源场景 ＝ CreateCompatibleDC (桌面句柄)
    位图句柄 ＝ CreateDIBSection (源场景, 位图信息, 1, 0, 0, 0) ' 不知是不是这里后面的三个参数导致的这些原因,但不知要如何弄这里的参数
    SelectObject (源场景, 位图句柄)
    GetDIBColorTable (源场景, 0, 颜色表大小, 颜色表) ' 是不是不能这样取颜色表?虽然能出图了,但颜色好象还是不正常,是这里取出的颜色表有问题?
    
    StretchBlt (源场景, 0, 0, 位图信息.位图宽度, 位图信息.位图高度, 桌面句柄, 0, 位图信息.位图高度, 位图信息.位图宽度, －位图信息.位图高度, 13369376)
    GetBitmapBits (位图句柄, 位图信息.位图大小, 位图像素点阵)
    
    ' 取位图二进制位_ (源场景, 位图句柄, 0, 位图信息.位图高度, 位图像素点阵 [1], 位图信息, #DIB_PAL_COLORS)
    
    ' 不知道为什么不能用这个(取位图二进制位_)API,而用(复制位图_)API却不会出错
    
    位图信息字节集 ＝ 取空白字节集 (位图信息.结果大小)
    RtlMoveMemory_位图信息 (位图信息字节集, 位图信息, 位图信息.结果大小)
    位图文件头.bfType ＝ 19778
    位图文件头.bfOffBits ＝ 颜色表大小 ＋ 54
    位图文件头.bfSize ＝ 54 ＋ 位图信息.位图大小
    位图文件头字节集 ＝ 取空白字节集 (14)
    RtlMoveMemory_BITMAPFILEHEADER (位图文件头字节集, 位图文件头, 14)
    DeleteObject (位图句柄)
    DeleteDC (源场景)
    ReleaseDC (0, 桌面句柄)
    返回 (位图文件头字节集 ＋ 位图信息字节集 ＋ 颜色表 ＋ 位图像素点阵)

.子程序 图片_屏幕区域截图, 字节集, 公开, 截取桌面指定位置和大小的图片
    .参数 欲截取的左边, 整数型
    .参数 欲截取的顶边, 整数型
    .参数 欲截取的宽度, 整数型
    .参数 欲截取的高度, 整数型
    .局部变量 行宽, 整数型
    .局部变量 文件长度, 整数型
    .局部变量 Head, 字节集
    .局部变量 Data, 字节集
    .局部变量 BitmapHead, BITMAPINFOHEADER
    .局部变量 源场景, 整数型
    .局部变量 色深, 整数型
    .局部变量 目标场景, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 原位图句柄, 整数型

    源场景 ＝ GetDC (0)
    色深 ＝ GetDeviceCaps (源场景, 12)
    目标场景 ＝ CreateCompatibleDC (源场景)
    位图句柄 ＝ CreateCompatibleBitmap (源场景, 欲截取的宽度, 欲截取的高度)
    原位图句柄 ＝ SelectObject (目标场景, 位图句柄)
    BitBlt (目标场景, 0, 0, 欲截取的宽度, 欲截取的高度, 源场景, 欲截取的左边, 欲截取的顶边, 13369376) ' #SRCCOPY＝13369376
    ReleaseDC (0, 源场景)
    SelectObject (目标场景, 原位图句柄)
    BitmapHead.biSize ＝ 40
    BitmapHead.biWidth ＝ 欲截取的宽度
    BitmapHead.biHeight ＝ 欲截取的高度
    BitmapHead.biPlanes ＝ 1
    BitmapHead.biBitCount ＝ 到短整数 (色深)
    行宽 ＝ 左移 (右移 (欲截取的宽度 × 色深 ＋ 31, 5), 2)
    Data ＝ 取空白字节集 (BitmapHead.biSize ＋ 行宽 × 欲截取的高度)
    .如果真 (Data ＝ { })
        返回 ({ })
    .如果真结束
    RtlMoveMemory_BITMAPINFOHEADER (Data [1], BitmapHead, BitmapHead.biSize)
    .如果 (GetDIBits2 (目标场景, 位图句柄, 0, 欲截取的高度, Data [BitmapHead.biSize ＋ 1], Data [1], 0) ≠ 0)
        文件长度 ＝ 14 ＋ 行宽 × 欲截取的高度
        Data ＝ 到字节集 (“BM”) ＋ 到字节集 (文件长度) ＋ { 0, 0, 0, 0, 54, 0, 0, 0 } ＋ Data
    .否则
        Data ＝ { }
    .如果结束
    DeleteObject (位图句柄)
    DeleteDC (目标场景)
    返回 (Data)

.子程序 取位图深度, 整数型
    .参数 位深, 整数型

    .判断开始 (位深 ＝ 1)
        返回 (8)
    .判断 (位深 ＝ 4)
        返回 (64)
    .判断 (位深 ＝ 8)
        返回 (1024)
    .默认
        返回 (0)
    .判断结束
    

.子程序 图片_通过句柄取图标, 字节集, 公开
    .参数 窗口句柄, 整数型, , 当前窗口句柄
    .参数 图标句柄, 整数型
    .参数 图标宽度, 整数型, 可空
    .参数 图标高度, 整数型, 可空
    .参数 背景颜色, 整数型, 可空
    .局部变量 sRect, 精易_矩形J
    .局部变量 sIco, 字节集
    .局部变量 位图操作, 类_位图操作
    .局部变量 SrchDC, 整数型
    .局部变量 newDC, 整数型
    .局部变量 hwnd, 整数型
    .局部变量 hBmp, 整数型
    .局部变量 hBmpPrev, 整数型
    .局部变量 mBrush, 整数型

    .如果真 (是否为空 (图标宽度))
        图标宽度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (图标高度))
        图标高度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (背景颜色))
        背景颜色 ＝ #白色
    .如果真结束
    sRect.顶边 ＝ 0
    sRect.左边 ＝ 0
    sRect.右边 ＝ 图标宽度
    sRect.底边 ＝ 图标高度
    SrchDC ＝ GetDC (窗口句柄)
    newDC ＝ CreateCompatibleDC (SrchDC)
    ' 验证 (newDC)
    hBmp ＝ CreateCompatibleBitmap (SrchDC, 48, 48)
    ' 验证 (hBmp)
    hBmpPrev ＝ SelectObject (newDC, hBmp)
    ' 验证 (hBmpPrev)
    mBrush ＝ CreateSolidBrush (背景颜色)
    FillRect (newDC, sRect, mBrush)
    DrawIconEx (newDC, 0, 0, 图标句柄, 图标宽度, 图标高度, 0, 0, 3)
    位图操作.从场景创建 (newDC, sRect, 32)
    sIco ＝ 位图操作.取出位图数据 ()
    ReleaseDC (hwnd, SrchDC)
    DeleteDC (newDC)
    DeleteObject (hBmpPrev)
    DeleteObject (hBmp)
    DeleteObject (mBrush)
    返回 (sIco)

.子程序 图片_取宽度, 整数型, 公开, 快速读取图片宽度，失败返回零。
    .参数 参_图片数据, 字节集, , 支持文件路径与图片内容，路径非unicode编码，可用 到字节集()转换
    .局部变量 gdip_Image
    .局部变量 Wid, 整数型
    .局部变量 Hgt, 整数型
    .局部变量 hresult
    .局部变量 GpInput, GdiplusStartupInput
    .局部变量 gdip_Token, 整数型
    .局部变量 FileName, 文本型
    .局部变量 FileExists, 逻辑型
    .局部变量 dwFileSize, 整数型
    .局部变量 hImageMemory, 整数型
    .局部变量 pImageMemory, 整数型
    .局部变量 pIStream, 整数型

    FileName ＝ 到文本 (参_图片数据)
    FileExists ＝ 文件_是否存在 (FileName)
    GpInput.GdiplusVersion ＝ 1
    hresult ＝ GdiplusStartup (gdip_Token, GpInput, 0) ' 启动GDI+
    .如果真 (hresult ＝ 0)
        .如果 (FileExists)
            hresult ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (FileName, ), gdip_Image)
        .否则
            dwFileSize ＝ 取字节集长度 (参_图片数据)
            hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize) ' ; //给图片分配全局内存
            pImageMemory ＝ GlobalLock (hImageMemory) ' ; //锁定内存
            CopyMemory_Bytes2int (pImageMemory, 参_图片数据, dwFileSize)
            hresult ＝ CreateStreamOnHGlobal (hImageMemory, 假, pIStream) ' //用全局内存初使化IStream接口指针
            GdipLoadImageFromStream (pIStream, gdip_Image)
            .如果真 (hresult ＝ 0)
                COM_Release (pIStream)
            .如果真结束
            GlobalUnlock (pImageMemory) ' ; //解锁内存
            GlobalFree (hImageMemory)
        .如果结束
        GdipGetImageWidth (gdip_Image, Wid)
        GdipDisposeImage (gdip_Image)
        GdiplusShutdown (gdip_Token) ' GDI关闭 +
    .如果真结束
    返回 (Wid)

.子程序 图片_取高度, 整数型, 公开, 快速读取图片高度，失败返回零。
    .参数 参_图片数据, 字节集, , 支持文件路径与图片内容，路径非unicode编码，可用 到字节集()转换
    .局部变量 gdip_Image
    .局部变量 Wid, 整数型
    .局部变量 Hgt, 整数型
    .局部变量 hresult
    .局部变量 GpInput, GdiplusStartupInput
    .局部变量 gdip_Token, 整数型
    .局部变量 FileName, 文本型
    .局部变量 FileExists, 逻辑型
    .局部变量 dwFileSize, 整数型
    .局部变量 hImageMemory, 整数型
    .局部变量 pImageMemory, 整数型
    .局部变量 pIStream, 整数型

    FileName ＝ 到文本 (参_图片数据)
    FileExists ＝ 文件_是否存在 (FileName)
    GpInput.GdiplusVersion ＝ 1
    hresult ＝ GdiplusStartup (gdip_Token, GpInput, 0) ' 启动GDI+
    .如果真 (hresult ＝ 0)
        .如果 (FileExists)
            hresult ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (FileName, ), gdip_Image)
        .否则
            dwFileSize ＝ 取字节集长度 (参_图片数据)
            hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize) ' ; //给图片分配全局内存
            pImageMemory ＝ GlobalLock (hImageMemory) ' ; //锁定内存
            CopyMemory_Bytes2int (pImageMemory, 参_图片数据, dwFileSize)
            CreateStreamOnHGlobal (hImageMemory, 假, pIStream) ' //用全局内存初使化IStream接口指针
            GdipLoadImageFromStream (pIStream, gdip_Image)
            .如果真 (hresult ＝ 0)
                COM_Release (pIStream)
            .如果真结束
            GlobalUnlock (pImageMemory) ' ; //解锁内存
            GlobalFree (hImageMemory)
        .如果结束
        GdipGetImageHeight (gdip_Image, Hgt)
        GdipDisposeImage (gdip_Image)
        GdiplusShutdown (gdip_Token) ' GDI关闭 +
    .如果真结束
    返回 (Hgt)

