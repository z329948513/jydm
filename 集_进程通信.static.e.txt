.版本 2

.程序集 集_进程通信
.程序集变量 集_oldlong, 整数型
.程序集变量 集_标志文本数组, 文本型, , "0"
.程序集变量 集_消息编号数组, 整数型, , "0"
.程序集变量 集_数据数组, 字节集, , "0"
.程序集变量 集_指针数组, 整数型, , "0"
.程序集变量 集_窗口句柄, 整数型

.子程序 进程通信_接收端_初始化, , 公开, 监听前必需调用此子程序，只需使用一次，停止监听前不能再使用此子程序，否则会出错。
    .参数 参数_窗口句柄, 整数型, , 当前窗口句柄，可用 取窗口句柄() 得到。

    集_窗口句柄 ＝ 参数_窗口句柄
    集_oldlong ＝ SetWindowLongA (参数_窗口句柄, -4, 到整数 (&接收端_读数据))

.子程序 进程通信_接收端_开始监听, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 参数_标志文本, 文本型, , 可以为任意文本(不能为空文本)，但是不要和系统中已有的冲突。设置不同的标志文本，可绑定不同的子程序。
    .参数 参数_回调函数, 子程序指针, 可空, 接收到信息后要触发的子程序，不可多个标志文本绑定同个子程序，不需要可不填。
    .局部变量 局_计次, 整数型

    .如果真 (参数_标志文本 ＝ “”)
        返回 (假)
    .如果真结束
    .计次循环首 (取数组成员数 (集_标志文本数组), 局_计次) ' 判断是否有相同的标识文件存在
        .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标志文本)
            返回 (假)
        .如果真结束
        
    .计次循环尾 () ' 判断是否有相同的标识文件存在
    
    加入成员 (集_消息编号数组, RegisterWindowMessageA (参数_标志文本))
    加入成员 (集_标志文本数组, 参数_标志文本)
    
    .如果真 (集_消息编号数组 [取数组成员数 (集_消息编号数组)] ＝ 0) ' 如果获取的消息编号为0,将其删除;
        删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
        删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
        返回 (假)
    .如果真结束
    
    .计次循环首 (取数组成员数 (集_消息编号数组) － 1, 局_计次) ' 判断 集_消息编号数组 是否有重复
        .如果真 (集_消息编号数组 [局_计次] ＝ 集_消息编号数组 [取数组成员数 (集_消息编号数组)])
            删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
            删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    
    .计次循环首 (取数组成员数 (集_指针数组), 局_计次)
        .如果真 (集_指针数组 [局_计次] ＝ 到整数 (参数_回调函数))
            删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
            删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    
    加入成员 (集_指针数组, 到整数 (参数_回调函数))
    加入成员 (集_数据数组, 到字节集 (“”))
    返回 (真)

.子程序 进程通信_接收端_关闭监听, , 公开, 关闭某监听，要恢复请直接开始(不用重新初始化)。
    .参数 参数_标志文本, 文本型
    .局部变量 计次, 整数型

    .计次循环首 (取数组成员数 (集_标志文本数组), 计次)
        .如果真 (集_标志文本数组 [计次] ＝ 参数_标志文本)
            删除成员 (集_消息编号数组, 计次, )
            删除成员 (集_标志文本数组, 计次, )
            删除成员 (集_数据数组, 计次, )
            删除成员 (集_指针数组, 计次, )
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()

.子程序 进程通信_接收端_停止监听, , 公开, 关闭所有监听，要恢复请重新初始化。
    SetWindowLongA (集_窗口句柄, -4, 集_oldlong)
    清除数组 (集_标志文本数组)
    清除数组 (集_消息编号数组)
    清除数组 (集_数据数组)
    清除数组 (集_指针数组)

.子程序 进程通信_接收端_取出数据, 字节集, 公开, 回调函数或其它子程序可用此子程序取出接收到的数据。
    .参数 参数_标识文本, 文本型, , 接收端监听时设置的文本。
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)
        .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标识文本)
            返回 (集_数据数组 [局_计次])
        .如果真结束
        
    .计次循环尾 ()
    返回 ({ })

.子程序 进程通信_接收端_清除数据, , 公开, 清除某监听得到的数据(其它数据不变)，释放该数据所占的内存。
    .参数 参数_标志文本, 文本型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)
        .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标志文本)
            集_数据数组 [局_计次] ＝ { }
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()

.子程序 进程通信_接收端_清空数据, , 公开, 清空所有监听得到的所有数据，释放内存。
    重定义数组 (集_数据数组, 假, 取数组成员数 (集_数据数组))

.子程序 进程通信_发送端_发送数据, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 参数_窗口句柄, 整数型, , 接收端的窗口句柄。
    .参数 参数_标志文本, 文本型, , 接收端监听时设置的文本。
    .参数 参数_欲发送的数据, 字节集, , 要发送的数据。
    .局部变量 局_消息文本, 字节集
    .局部变量 局_标识文本, 字节集
    .局部变量 局_进程ID, 文本型, 静态
    .局部变量 局_消息号, 整数型
    .局部变量 局_PIDlen, 文本型

    局_消息号 ＝ RegisterWindowMessageA (参数_标志文本)
    .如果真 (局_进程ID ＝ “” 或 局_进程ID ＝ “0”)
        局_进程ID ＝ 到文本 (GetCurrentProcessId ())
    .如果真结束
    .如果真 (IsWindow (参数_窗口句柄) ≠ 0)
        局_标识文本 ＝ { 1 }
        局_消息文本 ＝ 到字节集 (到文本 (lstrcpynA_字节集 (局_标识文本, 局_标识文本, 0)) ＋ “$” ＋ 到文本 (取字节集长度 (参数_欲发送的数据)) ＋ “&” ＋ 到文本 (lstrcpynA_字节集 (参数_欲发送的数据, 参数_欲发送的数据, 0)))
        局_PIDlen ＝ 到文本 (取文本长度 (局_进程ID))
        SendMessageA (参数_窗口句柄, 局_消息号, 到整数 (局_PIDlen ＋ 局_进程ID ＋ 到文本 (取字节集长度 (局_消息文本))), lstrcpynA_字节集 (局_消息文本, 局_消息文本, 0))
        .如果真 (局_标识文本 ＝ { 2 })
            返回 (真)
        .如果真结束
        返回 (假)
    .如果真结束
    返回 (假)

.子程序 接收端_读数据, 整数型
    .参数 参数_窗口句柄, 整数型
    .参数 参数_消息号, 整数型
    .参数 参数_参数1, 整数型
    .参数 参数_参数2, 整数型
    .局部变量 局_消息文本, 文本型
    .局部变量 局_标识地址, 整数型
    .局部变量 局_len, 整数型
    .局部变量 局_drlen, 整数型
    .局部变量 局_hProcess, 整数型
    .局部变量 局_lpBuffer, 字节集
    .局部变量 局_计次, 整数型
    .局部变量 bin, 字节集

    .计次循环首 (取数组成员数 (集_消息编号数组), 局_计次)
        .如果真 (集_消息编号数组 [局_计次] ＝ 参数_消息号)
            局_消息文本 ＝ 到文本 (参数_参数1)
            局_len ＝ 到整数 (取文本左边 (局_消息文本, 1))
            局_消息文本 ＝ 取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 1)
            局_hProcess ＝ OpenProcess (2035711, 0, 到整数 (取文本左边 (局_消息文本, 局_len)))
            局_drlen ＝ 到整数 (取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 局_len))
            局_lpBuffer ＝ 取空白字节集 (局_drlen)
            ReadProcessMemory_字节集 (局_hProcess, 参数_参数2, 局_lpBuffer, 局_drlen, 0)
            局_消息文本 ＝ 到文本 (局_lpBuffer)
            局_标识地址 ＝ 到整数 (取文本左边 (局_消息文本, 寻找文本 (局_消息文本, “$”, , 假) － 1))
            WriteProcessMemory_字节集 (局_hProcess, 局_标识地址, { 2 }, 1, 0)
            局_消息文本 ＝ 取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 寻找文本 (局_消息文本, “$”, , 假))
            局_drlen ＝ 到整数 (取文本左边 (局_消息文本, 寻找文本 (局_消息文本, “&”, , 假) － 1))
            局_len ＝ 到整数 (取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 寻找文本 (局_消息文本, “&”, , 假)))
            局_lpBuffer ＝ 取空白字节集 (局_drlen)
            ReadProcessMemory_字节集 (局_hProcess, 局_len, 局_lpBuffer, 局_drlen, 0)
            集_数据数组 [局_计次] ＝ 局_lpBuffer
            CloseHandle (局_hProcess)
            .如果真 (到整数 (集_指针数组 [局_计次]) ≠ 0)
                ' bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
                ' CallWindowProcA (取指针_字节集型 (bin), 集_指针数组 [局_计次], 0, 0, 0)
                CallWindowProcA (取指针_字节集型 ({ 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }), 集_指针数组 [局_计次], 0, 0, 0)
            .如果真结束
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (CallWindowProcA (集_oldlong, 参数_窗口句柄, 参数_消息号, 参数_参数1, 参数_参数2))

.子程序 子程序1, , , '''分割线
    

.子程序 内存_远程创建内存_文本, 整数型, 公开, 创建成功后返回远程文本内存地址。可用来远程调用
    .参数 进程句柄, 整数型
    .参数 文本内容, 文本型

    返回 (内存_远程创建内存_字节集 (进程句柄, 到字节集 (文本内容) ＋ { 0 })) ' 0是文本终止符

.子程序 内存_远程创建内存_字节集, 整数型, 公开, 创建成功后返回远程字节集内存地址。可用来远程调用
    .参数 进程句柄, 整数型
    .参数 字节集内容, 字节集
    .局部变量 内存地址, 整数型

    内存地址 ＝ VirtualAllocEx (进程句柄, 0, 取字节集长度 (字节集内容), #MEM_COMMIT, #PAGE_EXECUTE_READWRITE)
    
    .如果真 (内存地址 ＝ 0)
        输出调试文本 (“内存申请失败”)
        返回 (0)
    .如果真结束
    ' 写远程内存。
    .如果真 (WriteProcessMemory_字节集 (进程句柄, 内存地址, 字节集内容, 取字节集长度 (字节集内容), 0) ＝ 假)
        输出调试文本 (“写内存失败”)
        返回 (0)
    .如果真结束
    ' 释放进程句柄并返回内存地址
    返回 (内存地址)

.子程序 内存_远程调用子程序, 逻辑型, 公开, 在远程进程创建一条线程，成功返回真，失败返回假。会导致少数进程崩溃，暂未找到原因   调用实例：https://bbs.125.la/thread-14193109-1-1.html  
    .参数 进程句柄, 整数型
    .参数 远程子程序地址, 整数型
    .参数 参数, 整数型, 可空 数组, 只接受整数型数据，如需传递文本请自行创建远程文本内存，传入内存地址
    .参数 是否C调用, 逻辑型, 可空, 默认为APICALL(即_stdcall)，如果本函数为真则使用C调用(_cdcel)
    .参数 是否等待远程线程, 逻辑型, 可空, 如果为真，则等待远程线程执行完毕后才会返回。否则创建后立即返回(异步)
    .局部变量 远程函数字节集, 字节集
    .局部变量 数组成员数, 整数型
    .局部变量 j, 整数型
    .局部变量 内存地址, 整数型
    .局部变量 远程线程句柄, 整数型

    .如果真 (远程子程序地址 ＝ 0)
        返回 (假)
    .如果真结束
    ' 首先整理出远程内存call的字节集
    ' 思路如下, 倒序push参数, 将需要call的地址放入eax, 然后call eax。最后根据调用约定, 决定是否平衡堆栈
    ' 倒序遍历数组
    远程函数字节集 ＝ { }
    数组成员数 ＝ 取数组成员数 (参数)
    .如果真 (数组成员数 ＞ 63)
        ' 参数过多。后面有解释原因。虽然我觉得没必要解释什么← ←
        返回 (假)
    .如果真结束
    .计次循环首 (数组成员数, j)
        .如果 (参数 [数组成员数 － j ＋ 1] ＜ 255)
            ' 小于255(一个字节)的时候可以使用{106,内容}的方法push, 节约内存
            远程函数字节集 ＝ 远程函数字节集 ＋ { 106 } ＋ 到字节集 (到字节 (参数 [数组成员数 － j ＋ 1]))
        .否则
            ' 大于255(一个字节)的时候可以用{104,0,0,0,0}的方法push四字节内容
            远程函数字节集 ＝ 远程函数字节集 ＋ { 104 } ＋ 到字节集 (参数 [数组成员数 － j ＋ 1])
        .如果结束
        
    .计次循环尾 ()
    ' 然后应当将函数地址传入eax，方法为 {184,0,0,0,0,255,208}(0,0,0,0是远程子程序地址，255，208是call eax的意思)
    远程函数字节集 ＝ 远程函数字节集 ＋ { 184 } ＋ 到字节集 (远程子程序地址) ＋ { 255, 208 }
    ' 判断是否为C调用。如果是C调用, 根据_cdcel调用约定, 应当在call调用完毕后手动平衡堆栈
    .如果真 (是否C调用 ＝ 真)
        ' 平衡堆栈说明。使用 add esp,数量 来平衡堆栈。字节集为131,196,0，0是数量，不能超过255(PS:255相当于63个参数....一般人真不会超过255吧QwQ 所以上面加了个判断)
        远程函数字节集 ＝ 远程函数字节集 ＋ { 131, 196 } ＋ 到字节集 (到字节 (数组成员数 × 4))
    .如果真结束
    ' 最后添加返回的字节集机器码 ,ret{195}返回
    远程函数字节集 ＝ 远程函数字节集 ＋ { 195 }
    ' 接下来将字节集写到远程内存
    内存地址 ＝ 内存_远程创建内存_字节集 (进程句柄, 远程函数字节集)
    .如果真 (内存地址 ＝ 0)
        返回 (假)
    .如果真结束
    ' 创建远程线程
    远程线程句柄 ＝ CreateRemoteThread (进程句柄, 0, 0, 内存地址, 0, 0, 0)
    .如果真 (远程线程句柄 ＝ 0)
        输出调试文本 (“远程线程创建失败”)
        返回 (假)
    .如果真结束
    .如果 (是否等待远程线程 ＝ 真)
        WaitForSingleObject (远程线程句柄, -1)
        CloseHandle (远程线程句柄)
        内存_释放远程内存 (进程句柄, 内存地址)
        输出调试文本 (“远程资源已自动释放”)
        返回 (真)
    .否则
        ' 创建线程, 在线程等待。最后销毁相关数据
        ' 关于线程参数的一点说明
        ' 为了等待，需要传递三个参数：远程线程句柄，释放内存地址，进程PID
        ' 将通过一个长度为12的字节集来传递数据
        j ＝ VirtualAlloc (0, 12, #MEM_COMMIT, #PAGE_READWRITE)
        ' j是之前循环变量, 已经不需要了, 这里就直接拿来用
        写到内存 (到字节集 (远程线程句柄) ＋ 到字节集 (内存地址) ＋ 到字节集 (进程句柄), j, 12)
        CloseHandle (CreateThread (0, 0, 到整数 (&内部等待线程), j, 0, 0))
        ' 因为并不需要对线程做后续操作，所以直接关闭线程句柄，让线程自行运行完毕自动销毁即可。
    .如果结束
    返回 (真)

.子程序 内存_释放远程内存, 逻辑型, 公开, 释放在远程创建的内存，可以释放本模块创建的远程文本/字节集内存。
    .参数 进程句柄, 整数型
    .参数 远程内存地址, 整数型

    ' 释放内存
    .如果真 (VirtualFreeEx (进程句柄, 远程内存地址, 0, #MEM_RELEASE) ＝ 0)
        输出调试文本 (“释放内存失败”)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 内部等待线程
    .参数 参数地址, 整数型
    .局部变量 字节集, 字节集
    .局部变量 远程线程句柄, 整数型
    .局部变量 内存地址, 整数型
    .局部变量 进程PID, 整数型

    字节集 ＝ 指针到字节集 (参数地址, 12)
    ' 释放参数地址内存, 避免内存泄漏
    VirtualFree (参数地址, 0, #MEM_RELEASE)
    远程线程句柄 ＝ 取字节集数据 (字节集, #整数型, )
    内存地址 ＝ 取字节集数据 (字节集, #整数型, 5)
    进程PID ＝ 取字节集数据 (字节集, #整数型, 9)
    WaitForSingleObject (远程线程句柄, -1)
    CloseHandle (远程线程句柄)
    内存_释放远程内存 (进程PID, 内存地址)
    输出调试文本 (“远程资源已自动释放”)

