.版本 2

.程序集 集_文本
.程序集变量 集_计次, 整数型

.子程序 数组_去重复_整数型, 整数型, 公开, 返回剩余不重复数组的成员数量
    .参数 整数数组, 整数型, 数组, 要去重复的 整数数组
    .局部变量 成员数, 整数型
    .局部变量 i, 长整数型
    .局部变量 a, 整数型

    ' 该历程收录自：https://bbs.125.la/thread-14402954-1-1.html
    数组排序 (整数数组, 真)
    成员数 ＝ 取数组成员数 (整数数组)
    i ＝ 0
    a ＝ 1
    .判断循环首 (a ≤ 成员数)
        i ＝ i ＋ 1
        整数数组 [i] ＝ 整数数组 [a]
        .循环判断首 ()
            a ＝ a ＋ 1
            .如果真 (a ＞ 成员数)
                跳出循环 ()
            .如果真结束
            
        .循环判断尾 (整数数组 [i] ＝ 整数数组 [a])
    .判断循环尾 ()
    重定义数组 (整数数组, 真, i)
    返回 (i)

.子程序 文本_取长度ex, 整数型, 公开, 全角汉字字符算一个长度
    .参数 参数_被计算文本, 文本型

    ' 命令出自：https://bbs.125.la/thread-14326444-1-1.html
    返回 (MultiByteToWideChar (0, 0, 取指针文本_ (参数_被计算文本), 文本_取长度 (参数_被计算文本), 0, 0))

.子程序 文本_分割文本, 整数型, 公开, 能够将连续的分隔符视为一个分隔符 返回成员数
    .参数 待分割文本, 文本型
    .参数 分隔符, 文本型, 可空
    .参数 返回子文本数目, 整数型, 可空
    .参数 返回数组, 文本型, 参考 数组
    .局部变量 i, 整数型
    .局部变量 临时数组, 文本型, , "0"

    重定义数组 (返回数组, 假, 0)
    .如果真 (分隔符 ＝ “”)
        分隔符 ＝ “,”
    .如果真结束
    .如果 (返回子文本数目 ＝ 0)
        临时数组 ＝ 分割文本 (待分割文本, 分隔符, )
    .否则
        临时数组 ＝ 分割文本 (待分割文本, 分隔符, 返回子文本数目)
    .如果结束
    
    .计次循环首 (取数组成员数 (临时数组), i)
        .如果真 (临时数组 [i] ≠ “”)
            加入成员 (返回数组, 临时数组 [i])
        .如果真结束
        
    .计次循环尾 ()
    返回 (取数组成员数 (返回数组))
    

.子程序 文本_寻找文本, 整数型, 公开, 成功找到返回位置索引，未找到返回-1。调用Ntdll命令，比核心库快三倍以上
    .参数 参_原始文本, 文本型
    .参数 参_查找文本, 文本型
    .参数 参_搜寻位置, 整数型, 可空, 可以被省略。位置值从 1 开始。如果本参数被省略，默认为 1
    .参数 参_不分大写, 逻辑型, 可空, 初始值为“假”。为真不区分大小写，为假区分。
    .局部变量 局_原始文本, 文本型
    .局部变量 局_查找文本, 文本型

    .如果真 (参_搜寻位置 ＝ 0)
        参_搜寻位置 ＝ 1
    .如果真结束
    
    .如果真 (取文本长度 (参_原始文本) ＝ 0 或 取文本长度 (参_查找文本) ＝ 0)
        返回 (-1)
    .如果真结束
    
    
    .判断开始 (参_不分大写)
        局_原始文本 ＝ 参_原始文本
        局_查找文本 ＝ 参_查找文本
        返回 (_寻找文本 (API_文本小写 (局_原始文本), API_文本小写 (局_查找文本), 参_搜寻位置))
    .默认
        返回 (_寻找文本 (参_原始文本, 参_查找文本, 参_搜寻位置))
    .判断结束
    

.子程序 _寻找文本, 整数型
    .参数 原始文本, 文本型
    .参数 查找文本, 文本型
    .参数 搜寻位置, 整数型
    .局部变量 查找索引, 整数型
    .局部变量 文本地址, 整数型

    .如果真 (原始文本 ＝ “”)
        返回 (-1)
    .如果真结束
    文本地址 ＝ 取指针文本_ (原始文本)
    搜寻位置 ＝ 搜寻位置 － 1
    查找索引 ＝ API_查找文本 (文本地址 ＋ 搜寻位置, 查找文本)
    .如果真 (查找索引 ＝ 0)
        返回 (-1)
    .如果真结束
    返回 (查找索引 － 文本地址 ＋ 1)

.子程序 文本_是否UTF8_汇编, 逻辑型, 公开, @jr21066
    .参数 参_内容, 字节集
    .局部变量 局_返回值, 逻辑型

    置入代码 ({ 96, 139, 69, 8, 139, 24, 139, 75, 4, 139, 48, 131, 198, 8, 139, 67, 8, 37, 255, 255, 255, 0, 61, 191, 187, 239, 0, 116, 101, 172, 136, 196, 60, 127, 118, 88, 192, 232, 6, 60, 6, 117, 19, 172, 80, 192, 232, 6, 60, 2, 117, 74, 88, 192, 232, 7, 60, 0, 116, 70, 235, 62, 136, 224, 192, 232, 4, 60, 14, 117, 18, 172, 192, 232, 6, 60, 2, 117, 47, 172, 192, 232, 6, 60, 2, 117, 39, 235, 41, 136, 224, 192, 232, 3, 60, 30, 117, 28, 172, 192, 232, 6, 60, 2, 117, 20, 172, 192, 232, 6, 60, 2, 117, 12, 172, 192, 232, 6, 60, 2, 117, 4, 235, 6, 226, 159, 49, 192, 235, 3, 49, 192, 64, 137, 69, 252, 97 })
    返回 (局_返回值)
    ' push esi  正确的保护寄存器就是这样的,因为偷懒才用pushad这样的.唯一的好处就是编译后的字节少,这次因为要用eax带回结果,所以不能保护eax值
    ' push edi
    ' push ebx
    ' mov eax,[ebp+08h]
    ' mov ebx,[eax]
    ' mov ecx,[ebx+04h]
    ' mov esi,[eax]
    ' add esi,08h
    ' mov eax,[ebx+08h]
    ' and eax,00FFFFFFh
    ' cmp eax,00EFBBBFh  有的UTF-8文件是带文件头的,如果有文件头就不判断了.
    ' je Label1
    ' Label6:
    ' lodsb
    ' mov ah,al
    ' cmp al,7Fh  单字节小于127的都是ASCII码,是不用判断的
    ' jbe Label2
    ' shr al,06h
    ' cmp al,06h  判断位数及判定逻辑都在最后.感兴趣的同学可以参阅,是在网上搜索的.不是原创.只能解释这么多了.
    ' jne Label3
    ' lodsb
    ' push eax
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' pop eax
    ' shr al,07h
    ' cmp al,00h
    ' je Label1
    ' jmp Label2
    ' Label3:
    ' mov al,ah
    ' shr al,04h
    ' cmp al,0Eh
    ' jne Label5
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' jmp Label1
    ' Label5:
    ' mov al,ah
    ' shr al,03h
    ' cmp al,1Eh
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' jmp Label1
    ' Label2:
    ' loop Label6
    ' Label4:
    ' xor eax,eax  返回假
    ' jmp Label7
    ' Label1:
    ' xor eax,eax
    ' inc eax  返回真,据说清零加一也比直接给eax1要快很多....
    ' Label7:
    ' pop ebx
    ' pop edi
    ' pop esi
    ' leave
    ' retn 0004h  自己返回的要恢复堆栈,一个参数就是一个整数.占四个字节.
    ' 附编码说明及判定方法,来源于网络.非自创.
    ' 如果不符合utf-8的规范，认为是gb18030编码
    ' 如果有符合utf-8规范中的3字节或4字节编码的，认为是utf-8编码
    ' 如果有符合utf-8规范中的2字节编码的，但是不符合gb18030编码的，认为是utf-8编码
    ' 如果全部都是符合2字节的utf-8编码，同时也符合gb18030编码的，认为是gb18030编码
    ' Unicode符号范围        |   UTF-8编码方式
    ' (十六进制)                 |   （二进制）
    ' ------------------------------+--------------------------------------------------------------
    ' 0000 0000-0000 007F | 0xxxxxxx
    ' 0000 0080-0000 07FF | 110xxxxx 10xxxxxx
    ' 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
    ' 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    ' ---------------------------------------------------------------------------------------------

.子程序 文本_均分文本, , 公开, 方便将大的文件内容均分为几段来处理
    .参数 参_内容, 字节集, , 要处理的文本内容
    .参数 参_文本数组, 文本型, 数组, 用于存放返回文本的数组
    .参数 参_分割数, 整数型, , 分割的段数
    .局部变量 局_区间值, 整数型
    .局部变量 局_偏移, 整数型
    .局部变量 局_内容, 字节集
    .局部变量 局_计数器, 整数型

    ' 复制源内容,保护原文本
    局_内容 ＝ 参_内容
    ' 求区段长度
    局_区间值 ＝ 四舍五入 (取字节集长度 (局_内容) ÷ 参_分割数, )
    清除数组 (参_文本数组)
    .计次循环首 (参_分割数 － 1, 局_计数器)
        ' 寻找上一换行符位置,分割完整的文本行
        局_偏移 ＝ 倒找字节集 (局_内容, { 13, 10 }, 局_区间值)
        加入成员 (参_文本数组, 到文本 (取字节集中间 (局_内容, 1, 局_偏移)))
        局_内容 ＝ 取字节集右边 (局_内容, 取字节集长度 (局_内容) － 局_偏移)
    .计次循环尾 ()
    ' 最后一段文本
    加入成员 (参_文本数组, 到文本 (局_内容))

.子程序 文本_删除空行_汇编, 文本型, 公开, 汇编,一次完成搜索替换 感谢【@jr21066 】分享开源
    .参数 参_内容, 文本型
    .局部变量 返回值, 文本型

    .如果真 (参_内容 ＝ “”)
        返回 (“”)
    .如果真结束
    返回值 ＝ 取空白文本 (取文本长度 (参_内容))
    置入代码 ({ 96, 139, 69, 8, 139, 48, 139, 125, 252, 172, 132, 192, 116, 22, 60, 13, 117, 12, 170, 172, 170, 172, 132, 192, 116, 10, 60, 13, 116, 3, 170, 235, 232, 70, 235, 241, 51, 192, 170, 97 })
    返回 (返回值)

.子程序 文本_取全部汉字拼音, 文本型, 公开, 支持取出文本中所有国标汉字的拼音，默认不保留非国标汉字字符。
    .参数 文本, 文本型, , 欲取拼音的文本
    .参数 保留非汉字, 逻辑型, 可空, 默认假，不保留原文本里的符号和数字等非国标汉字字符；真则保留。
    .局部变量 b, 字节集
    .局部变量 c, 整数型
    .局部变量 n, 整数型
    .局部变量 z, 整数型
    .局部变量 ret, 文本型
    .局部变量 p0, 文本型
    .局部变量 p1, 文本型

    .如果真 (是否为空 (保留非汉字))
        保留非汉字 ＝ 假
    .如果真结束
    b ＝ 到字节集 (文本)
    c ＝ 取字节集长度 (b)
    n ＝ 1
    .判断循环首 (n ≤ c)
        .如果 (n ＞ c)
            z ＝ 1
        .否则
            .如果 (b [n] ＞ 128)
                z ＝ 2
                p0 ＝ 到文本 (取字节集中间 (b, n, 2))
                p1 ＝ 取拼音 (p0, 1)
                .判断开始 (取文本长度 (删全部空 (p1)) ≠ 0)
                    ret ＝ ret ＋ p1 ＋ “空”
                .默认
                    .如果真 (保留非汉字)
                        ret ＝ ret ＋ p0
                    .如果真结束
                    
                .判断结束
                
            .否则
                .如果 (b [n] ≠ 13)
                    z ＝ 1
                .否则
                    .如果 (b [n ＋ 1] ＝ 10)
                        z ＝ 2
                    .否则
                        z ＝ 1
                        
                    .如果结束
                    
                .如果结束
                
                .如果真 (保留非汉字)
                    .如果 (取文本长度 (删全部空 (取拼音 (到文本 (取字节集中间 (b, n ＋ 1, 2)), 1))) ≠ 0) ' ‘判断单字节字符后面是否是双字节字符
                        ret ＝ ret ＋ 到文本 (取字节集中间 (b, n, z)) ＋ “空”
                    .否则
                        ret ＝ ret ＋ 到文本 (取字节集中间 (b, n, z))
                    .如果结束
                    
                .如果真结束
                
            .如果结束
            
        .如果结束
        n ＝ n ＋ z
    .判断循环尾 ()
    ret ＝ 子文本替换 (ret, “ ”, “”, , , 真) ' ’删除中间多余的空格
    ret ＝ 子文本替换 (ret, “空”, “ ”, , , 真) ' ’把用作隔开的“空”替换为“ ”
    
    .如果真 (取文本右边 (ret, 1) ＝ “ ”) ' ’删除尾部多余空格
        ret ＝ 取文本左边 (ret, 取文本长度 (ret) － 1)
    .如果真结束
    返回 (ret)

.子程序 文本_插入文本到关键字所在行后, 文本型, 公开, 插入文本到关键字所在行后，返回处理后的文本  [Harry· 提供]
    .参数 原文本, 文本型
    .参数 关键字, 文本型
    .参数 插入内容, 文本型
    .参数 是否换行, 逻辑型, 可空, 是否换行插入文本，默认为真
    .局部变量 i, 整数型
    .局部变量 临时数组, 文本型, , "0"
    .局部变量 临时文本, 文本型

    临时数组 ＝ 分割文本 (原文本, #换行符, )
    .如果真 (是否为空 (是否换行) ＝ 真)
        是否换行 ＝ 真
    .如果真结束
    .计次循环首 (取数组成员数 (临时数组), i)
        .如果真 (寻找文本 (临时数组 [i], 关键字, , 假) ≠ -1)
            .如果 (是否换行 ＝ 真)
                临时数组 [i] ＝ 临时数组 [i] ＋ #换行符 ＋ 插入内容 ＋ #换行符
            .否则
                临时数组 [i] ＝ 临时数组 [i] ＋ 插入内容 ＋ #换行符
            .如果结束
            
        .如果真结束
        临时文本 ＝ 临时文本 ＋ 临时数组 [i]
    .计次循环尾 ()
    返回 (临时文本)

.子程序 文本_删左边, 文本型, 公开
    .参数 欲处理文本, 文本型
    .参数 删除长度, 整数型

    返回 (取文本右边 (欲处理文本, 取文本长度 (欲处理文本) － 删除长度))

.子程序 文本_删右边, 文本型, 公开
    .参数 欲处理文本, 文本型
    .参数 删除长度, 整数型

    返回 (取文本左边 (欲处理文本, 取文本长度 (欲处理文本) － 删除长度))

.子程序 文本_删中间, 文本型, 公开
    .参数 欲处理文本, 文本型
    .参数 起始位置, 整数型
    .参数 删除长度, 整数型

    返回 (取文本左边 (欲处理文本, 起始位置 － 1) ＋ 文本_删左边 (欲处理文本, 起始位置 ＋ 删除长度 － 1))

.子程序 文本_删中间2, 文本型, 公开, 本命令会删除前面文本和后面文本之间的所有内容（包括后面文本），如文本中含有多个前面文本或后面文本则删除首个前面文本与最后一个后面文本之间的所有内容。
    .参数 原文本, 文本型, , 待处理的文本
    .参数 前面文本, 文本型
    .参数 后面文本, 文本型
    .参数 是否不区分大小写, 逻辑型, 可空, 默认为假，即区分大小写。
    .参数 保留前面文本, 逻辑型, 可空, 默认为假
    .参数 保留后面文本, 逻辑型, 可空, 默认为假
    .局部变量 局_开始位置, 整数型
    .局部变量 局_结束位置, 整数型
    .局部变量 局_返回文本, 文本型
    .局部变量 局_右边文本, 文本型
    .局部变量 局_返回后文本, 文本型
    .局部变量 局_返回前文本, 文本型

    局_开始位置 ＝ 寻找文本 (原文本, 前面文本, , 是否不区分大小写)
    .如果真 (局_开始位置 ＝ -1)
        返回 (原文本)
    .如果真结束
    局_返回前文本 ＝ 取文本左边 (原文本, 局_开始位置 － 1)
    .如果真 (保留前面文本)
        局_返回前文本 ＝ 局_返回前文本 ＋ 前面文本
    .如果真结束
    
    局_右边文本 ＝ 取文本右边 (原文本, 取文本长度 (原文本) － 取文本长度 (局_返回文本))
    局_结束位置 ＝ 倒找文本 (局_右边文本, 后面文本, , 是否不区分大小写)
    .如果真 (局_结束位置 ＝ -1)
        返回 (原文本)
    .如果真结束
    局_返回后文本 ＝ 取文本右边 (局_右边文本, 取文本长度 (局_右边文本) － 局_结束位置 － 取文本长度 (后面文本) ＋ 1)
    
    局_返回文本 ＝ 局_返回前文本 ＋ 局_返回后文本
    .如果真 (保留后面文本)
        局_返回文本 ＝ 局_返回前文本 ＋ 后面文本 ＋ 局_返回后文本
    .如果真结束
    
    返回 (局_返回文本)

.子程序 文本_取出文本中汉字, 文本型, 公开, 取出指定文本中的汉字
    .参数 字符串, 文本型
    .局部变量 字节集长度, 整数型
    .局部变量 字节集, 字节集
    .局部变量 取出位置, 整数型
    .局部变量 文本, 文本型

    字节集 ＝ 到字节集 (字符串)
    字节集长度 ＝ 取字节集长度 (字节集)
    取出位置 ＝ 1
    .判断循环首 (取出位置 ＜ 字节集长度)
        .判断开始 (字节集 [取出位置] ≥ 176 且 字节集 [取出位置 ＋ 1] ≥ 161 且 字节集 [取出位置] ≤ 247 且 字节集 [取出位置 ＋ 1] ≤ 254) ' 判断GBK/2: GB2312 汉字
            文本 ＝ 文本 ＋ 到文本 (取字节集中间 (字节集, 取出位置, 2))
            取出位置 ＝ 取出位置 ＋ 2
        .判断 (字节集 [取出位置] ＞ 127 且 字节集 [取出位置 ＋ 1] ＞ 127) ' 判断是否全角字符)
            取出位置 ＝ 取出位置 ＋ 2
        .默认
            取出位置 ＝ 取出位置 ＋ 1
        .判断结束
        
    .判断循环尾 ()
    返回 (文本)
    

.子程序 文本_取随机Ip, 文本型, 公开, 返回一个随机的IP地址
    .参数 只取国内, 逻辑型, 可空, 可空，默认为真
    .局部变量 局_Ip, 文本型, , "0"
    .局部变量 Arr, 文本型, , "0"
    .局部变量 Str, 文本型
    .局部变量 局_IP1, 文本型
    .局部变量 局_IP2, 文本型
    .局部变量 局_IP头, 文本型
    .局部变量 IP数组1, 文本型, , "0"
    .局部变量 IP数组2, 文本型, , "0"

    置随机数种子 ()
    .如果真 (是否为空 (只取国内))
        只取国内 ＝ 真
    .如果真结束
    .如果真 (只取国内)
        .如果真 (取数组成员数 (局_Ip) ＝ 0)
            局_Ip ＝ 分割文本 (#常量_IP, #换行符, )
        .如果真结束
        Str ＝ 局_Ip [取随机数 (1, 取数组成员数 (局_Ip))]
        局_IP1 ＝ 文本_取左边 (Str, “-”)
        局_IP2 ＝ 文本_取右边 (Str, “-”)
        
        
        IP数组1 ＝ 分割文本 (局_IP1, “.”, )
        IP数组2 ＝ 分割文本 (局_IP2, “.”, )
        .如果真 (取数组成员数 (IP数组1) ≠ 4 或 取数组成员数 (IP数组2) ≠ 4)
            返回 (文本_取随机Ip (只取国内))
        .如果真结束
        
        Str ＝ IP数组1 [1] ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [2]), 到整数 (IP数组2 [2])))
        Str ＝ Str ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [3]), 到整数 (IP数组2 [3])))
        Str ＝ Str ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [4]), 到整数 (IP数组2 [4])))
        返回 (Str)
    .如果真结束
    
    .如果真 (取数组成员数 (局_Ip) ＝ 0)
        Str ＝ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254))
    .如果真结束
    返回 (Str)

.子程序 文本_逐字分割, 整数型, 公开, 将指定文本,逐字分割成数组,保存为指定的变量数组中,返回成员个数,可识别换行符及全半角字符和汉字
    .参数 文本, 文本型, , 需要分割的文本
    .参数 返回的数组, 文本型, 参考 可空 数组, 保存分割结果的数组变量
    .局部变量 c, 整数型
    .局部变量 n, 整数型
    .局部变量 z, 整数型
    .局部变量 返回文本, 文本型
    .局部变量 临时字节集, 字节集

    清除数组 (返回的数组)
    临时字节集 ＝ 到字节集 (文本)
    c ＝ 取字节集长度 (临时字节集)
    n ＝ 1
    .判断循环首 (n ≤ c)
        .如果 (n ＋ 1 ＞ c)
            z ＝ 1
        .否则
            .如果 (临时字节集 [n] ＞ 128)
                z ＝ 2
            .否则
                .如果 (临时字节集 [n] ≠ 13)
                    z ＝ 1
                .否则
                    .如果 (临时字节集 [n ＋ 1] ＝ 10)
                        z ＝ 2
                    .否则
                        z ＝ 1
                    .如果结束
                    
                .如果结束
                
            .如果结束
            
        .如果结束
        加入成员 (返回的数组, 到文本 (取字节集中间 (临时字节集, n, z)))
        n ＝ n ＋ z
    .判断循环尾 ()
    返回 (取数组成员数 (返回的数组))

.子程序 文本_逐字分割_汇编, 整数型, 公开, 超长文本计算时有优势
    .参数 参_内容, 文本型
    .参数 参_文本数组, 文本型, 数组
    .局部变量 返回值, 文本型

    ' 例程收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14228410
    返回值 ＝ 取空白文本 (取文本长度 (参_内容) × 2)
    置入代码 ({ 139, 69, 8, 139, 48, 139, 125, 252, 172, 168, 128, 117, 26, 60, 32, 116, 247, 60, 9, 116, 243, 60, 13, 116, 239, 60, 10, 116, 235, 132, 192, 116, 28, 170, 176, 9, 170, 235, 225, 60, 161, 117, 10, 134, 224, 172, 60, 161, 116, 214, 134, 224, 78, 170, 172, 170, 176, 9, 170, 235, 203, 49, 192, 170 })
    参_文本数组 ＝ 分割文本 (返回值, 到文本 ({ 9 }), )
    返回 (取数组成员数 (参_文本数组))
    

.子程序 文本_递减, 文本型, 公开, 把文本递减1  编辑框1.内容 ＝ 文本_递减 (编辑框1.内容)
    .参数 要递减的文本, 文本型, 参考

    返回 (到文本 (原子递减变量 (到数值 (要递减的文本))))

.子程序 文本_递增, 文本型, 公开, 把文本递增1  编辑框1.内容 ＝ 文本_递增 (编辑框1.内容)
    .参数 要递增的文本, 文本型, 参考

    返回 (到文本 (原子递增变量 (到数值 (要递增的文本))))

.子程序 文本_替换, 文本型, 公开, 批量替换文本；
    .参数 原文本, 文本型
    .参数 替换进行的次数, 整数型, 可空, 可空；参数值指定对子文本进行替换的次数。如果省略，默认进行所有可能的替换。
    .参数 替换的起始位置, 整数型, 可空, 可空；参数值指定被替换子文本的起始搜索位置。如果省略，默认从 1 开始
    .参数 是否区分大小写, 逻辑型, 可空, 可空； 初始值为“假”不区分大小写；为真区分大小写。
    .参数 欲被替换的子文本1, 文本型
    .参数 用作替换的子文本1, 文本型
    .参数 欲被替换的子文本2, 文本型, 可空
    .参数 用作替换的子文本2, 文本型, 可空
    .参数 欲被替换的子文本3, 文本型, 可空
    .参数 用作替换的子文本3, 文本型, 可空
    .参数 欲被替换的子文本4, 文本型, 可空
    .参数 用作替换的子文本4, 文本型, 可空
    .参数 欲被替换的子文本5, 文本型, 可空
    .参数 用作替换的子文本5, 文本型, 可空
    .局部变量 局_文本, 文本型

    .如果真 (替换的起始位置 ＝ 0)
        替换的起始位置 ＝ 1
    .如果真结束
    .如果 (是否为空 (替换进行的次数))
        局_文本 ＝ 子文本替换 (原文本, 欲被替换的子文本1, 用作替换的子文本1, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本2, 用作替换的子文本2, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本3, 用作替换的子文本3, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本4, 用作替换的子文本4, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本5, 用作替换的子文本5, 替换的起始位置, , 是否区分大小写)
    .否则
        局_文本 ＝ 子文本替换 (原文本, 欲被替换的子文本1, 用作替换的子文本1, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本2, 用作替换的子文本2, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本3, 用作替换的子文本3, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本4, 用作替换的子文本4, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本5, 用作替换的子文本5, 替换的起始位置, 替换进行的次数, 是否区分大小写)
    .如果结束
    返回 (局_文本)

.子程序 文本_投递, , 公开, 向指定窗口句柄的窗口中后台发送文本内容,对游戏有效(无返回值)
    .参数 窗口句柄, 整数型, , 接收消息的窗口句柄
    .参数 文本内容, 文本型, , 发送的文本内容
    .局部变量 消息, 字节集
    .局部变量 计次, 整数型

    消息 ＝ 到字节集 (文本内容)
    .计次循环首 (取字节集长度 (消息), 计次)
        投递消息整数 (窗口句柄, 258, 消息 [计次], 0)
    .计次循环尾 ()

.子程序 文本_投递W, , 公开, 支持Unicode字符。
    .参数 窗口句柄, 整数型
    .参数 文本内容, 字节集, , unicode编码
    .局部变量 计次, 整数型

    .变量循环首 (1, 取字节集长度 (文本内容), 2, 计次)
        SendMessageW (窗口句柄, 258, 取字节集数据 (文本内容, #短整数型, 计次), 0)
    .变量循环尾 ()

.子程序 文本_颠倒, 文本型, 公开, 将指定文本倒序 (比如:"123456"倒序后成:"654321")
    .参数 欲转换文本, 文本型, , 欲倒序的文本
    .参数 带有中文, 逻辑型, 可空, 如果要颠倒的文本中带有汉字，请把此参数设置为真。
    .局部变量 字符数, 整数型
    .局部变量 倒序内容, 文本型
    .局部变量 循环变量, 整数型
    .局部变量 字节集, 字节集
    .局部变量 局_结果, 字节集
    .局部变量 i, 整数型

    .如果真 (带有中文)
        字节集 ＝ 编码_Ansi到Unicode (欲转换文本, 真)
        .变量循环首 (取字节集长度 (字节集) － 1, 1, -2, i)
            局_结果 ＝ 局_结果 ＋ 取字节集中间 (字节集, i, 2)
        .变量循环尾 ()
        返回 (编码_Unicode到Ansi (局_结果))
    .如果真结束
    字符数 ＝ 取文本长度 (到文本 (欲转换文本))
    .变量循环首 (1, 字符数, 1, 循环变量)
        倒序内容 ＝ 倒序内容 ＋ 取文本中间 (欲转换文本, 字符数 ＋ 1 － 循环变量, 1)
    .变量循环尾 ()
    返回 (倒序内容)

.子程序 文本_发送, , 公开, 向指定文本框后台发送文本(无返回值)
    .参数 文本框句柄, 整数型, , 文本框的句柄
    .参数 发送的内容, 文本型, , 要发送的文本

    SendMessageA (文本框句柄, 194, 1, 取指针文本_ (发送的内容))

.子程序 文本_粘贴, , 公开, 往指定的窗口粘贴文本
    .参数 窗口句柄, 整数型, 可空, 欲粘贴文本的窗口句柄
    .参数 文本内容, 文本型, 可空, 欲粘贴的文本内容
    .局部变量 局_文本, 文本型

    局_文本 ＝ 取剪辑板文本 ()
    .如果真 (是否为空 (文本内容) ＝ 假)
        置剪辑板文本 (文本内容)
    .如果真结束
    SendMessageA (窗口句柄, 770, 0, 0)
    置剪辑板文本 (局_文本)

.子程序 文本_全选, , 公开, 让指定的文本框内容全部选中
    .参数 文本框句柄, 整数型, , 文本框的句柄
    .参数 类型, 整数型, 可空, 默认为0全选，1=取消全选

    .如果 (类型 ＝ 0)
        SendMessageA (文本框句柄, 177, 0, -1)
    .否则
        SendMessageA (文本框句柄, 177, 0, 0)
    .如果结束
    

.子程序 文本_去重复文本, 文本型, 公开, 去除原文本中重复的文本
    .参数 原文本, 文本型
    .参数 分割符, 文本型, 可空, 原文本单个内容间的分隔符，例如：---  留空为：逐字分割
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_数组1, 文本型, , "0"
    .局部变量 局_计次, 整数型
    .局部变量 局_文本, 文本型

    .如果 (是否为空 (分割符))
        文本_逐字分割 (原文本, 局_数组)
    .否则
        局_数组 ＝ 分割文本 (原文本, 分割符, )
    .如果结束
    
    
    .计次循环首 (取数组成员数 (局_数组), 局_计次)
        .如果真 (内部_数组成员是否存在_文本 (局_数组1, 局_数组 [局_计次]) ＝ -1)
            加入成员 (局_数组1, 局_数组 [局_计次])
            局_文本 ＝ 局_文本 ＋ 局_数组 [局_计次] ＋ 分割符
        .如果真结束
        
    .计次循环尾 ()
    局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 取文本长度 (分割符))
    返回 (局_文本)

.子程序 内部_数组成员是否存在_文本, 整数型
    .参数 数组, 文本型, 数组
    .参数 要判断值, 文本型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (数组), 局_计次)
        .如果真 (数组 [局_计次] ＝ 要判断值)
            返回 (局_计次)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.子程序 内部_数组成员是否存在_整数, 整数型
    .参数 数组, 整数型, 数组
    .参数 要判断值, 整数型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (数组), 局_计次)
        .如果真 (数组 [局_计次] ＝ 要判断值)
            返回 (局_计次)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)
    

.子程序 数组_排序, , 公开, 二分法排序.只能对文本数组进行排序,整数数组请用核心支持库的.
    .参数 要排序的数组, 文本型, 参考 数组
    .参数 排序方式, 字节型, 可空, 可空,默认为0  0=升序排序 1=降序排序
    .参数 区分大小写, 逻辑型, 可空, 可空,默认“真”。真=区分大小写，假=不区分
    .局部变量 N, 整数型
    .局部变量 排序数组, 文本型, , "0"
    .局部变量 成员数量, 整数型
    .局部变量 高位, 整数型
    .局部变量 低位, 整数型
    .局部变量 中间位, 整数型
    .局部变量 比较结果, 整数型, , , 感谢会员 落雪 提供代码

    复制数组 (排序数组, 要排序的数组)
    清除数组 (要排序的数组)
    .如果真 (是否为空 (区分大小写) ＝ 真)
        区分大小写 ＝ 真
    .如果真结束
    
    .计次循环首 (取数组成员数 (排序数组), N)
        .判断开始 (成员数量 ＝ 0)
            插入成员 (要排序的数组, 1, 排序数组 [N])
        .默认
            
            高位 ＝ 成员数量
            低位 ＝ 1
            中间位 ＝ (高位 ＋ 低位) ＼ 2
            ' ; lstrcmp 通过比较ASCII码进行文本的排序,速度快,但存在问题
            .判断开始 (区分大小写 ＝ 假)
                比较结果 ＝ 文本比较 (到大写 (排序数组 [N]), 到大写 (要排序的数组 [成员数量]), 真) ' 不区分就都算大写好了.因为在ACSII码中,大小写字母都是挨着的,所以不会出现"夹"在中间的字符.
            .默认
                比较结果 ＝ 文本比较 (排序数组 [N], 要排序的数组 [成员数量], 真)
            .判断结束
            
            .判断开始 (比较结果 ≥ 0)
                插入成员 (要排序的数组, 成员数量 ＋ 1, 排序数组 [N])
            .判断 (文本比较 (排序数组 [N], 要排序的数组 [1], 真) ≤ 0)
                插入成员 (要排序的数组, 1, 排序数组 [N])
            .默认
                .判断循环首 (高位 － 低位 ＞ 1)
                    .如果真 (排序数组 [N] ＝ 要排序的数组 [中间位])
                        跳出循环 ()
                    .如果真结束
                    .如果 (文本比较 (排序数组 [N], 要排序的数组 [中间位], 真) ＜ 0)
                        高位 ＝ 中间位
                    .否则
                        低位 ＝ 中间位
                    .如果结束
                    中间位 ＝ (高位 ＋ 低位) ＼ 2
                .判断循环尾 ()
                .判断开始 (文本比较 (排序数组 [N], 要排序的数组 [中间位], 真) ≤ 0)
                    插入成员 (要排序的数组, 中间位, 排序数组 [N])
                .默认
                    插入成员 (要排序的数组, 中间位 ＋ 1, 排序数组 [N])
                .判断结束
                
            .判断结束
            
        .判断结束
        成员数量 ＝ 取数组成员数 (要排序的数组)
    .计次循环尾 ()
    .如果真 (排序方式 ＝ 1)
        数组_反转 (要排序的数组)
    .如果真结束
    

.子程序 数组_寻找数组, 整数型, 公开, 寻找指定成员在数组中出现的次数，
    .参数 待查找的数组, 文本型, 数组
    .参数 待查找的成员, 文本型
    .参数 寻找到的数组, 整数型, 参考 数组, 返回出现的位置数组信息
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (待查找的数组), i)
        系统_处理事件 ()
        .如果真 (待查找的成员 ＝ 待查找的数组 [i])
            加入成员 (寻找到的数组, i)
        .如果真结束
        
    .计次循环尾 ()
    返回 (取数组成员数 (寻找到的数组))

.子程序 数组_反转, , 公开, 数组倒序。数组的第一个成员与最后一个成员互换，第二个和倒数第二个互换，以此类推
    .参数 反转的数组, 文本型, 参考 数组
    .局部变量 成员数量, 整数型
    .局部变量 折中数量, 整数型
    .局部变量 临时成员, 文本型
    .局部变量 N, 整数型

    成员数量 ＝ 取数组成员数 (反转的数组)
    折中数量 ＝ 成员数量 ÷ 2
    .计次循环首 (折中数量, N)
        临时成员 ＝ 反转的数组 [N]
        反转的数组 [N] ＝ 反转的数组 [成员数量]
        反转的数组 [成员数量] ＝ 临时成员
        成员数量 ＝ 成员数量 － 1
    .计次循环尾 ()

.子程序 数组_输出, , 公开, 输出数组,方便查看
    .参数 文本数组, 文本型, 可空 数组
    .参数 整数数组, 整数型, 可空 数组
    .局部变量 i, 整数型
    .局部变量 局_文本, 文本型

    .如果真 (是否为空 (文本数组) ＝ 假)
        局_文本 ＝ “文本数组 - ”
        .计次循环首 (取数组成员数 (文本数组), i)
            局_文本 ＝ 局_文本 ＋ “成员” ＋ 到文本 (i) ＋ “(” ＋ 文本数组 [i] ＋ “)  ”
        .计次循环尾 ()
        输出调试文本 (删首尾空 (局_文本))
    .如果真结束
    
    .如果真 (是否为空 (整数数组) ＝ 假)
        局_文本 ＝ “整数数组 - ”
        .计次循环首 (取数组成员数 (整数数组), i)
            局_文本 ＝ 局_文本 ＋ “成员” ＋ 到文本 (i) ＋ “(” ＋ 到文本 (整数数组 [i]) ＋ “)  ”
        .计次循环尾 ()
        输出调试文本 (删首尾空 (局_文本))
    .如果真结束
    

.子程序 数组_合并, 文本型, 公开, 连接数组，类似VB中的join方法,合并一个文本数组到字符串。
    .参数 文本数组, 文本型, 数组
    .参数 合并字符, 文本型, 可空, 可空，默认为,
    .局部变量 i, 整数型
    .局部变量 返回文本, 文本型

    合并字符 ＝ 选择 (是否为空 (合并字符), “,”, 合并字符)
    .计次循环首 (取数组成员数 (文本数组), i)
        .如果 (i ＝ 1)
            返回文本 ＝ 文本数组 [i]
        .否则
            返回文本 ＝ 返回文本 ＋ 合并字符 ＋ 文本数组 [i]
        .如果结束
        
    .计次循环尾 ()
    返回 (返回文本)

.子程序 数组_去重复, 整数型, 公开, 返回剩余不重复数组的成员数量，可处理特殊字符效率较慢
    .参数 文本数组, 文本型, 可空 数组, 要去重复的 文本数组
    .参数 整数数组, 整数型, 可空 数组, 要去重复的 整数数组
    .局部变量 局_文本数组, 文本型, 数组, "0"
    .局部变量 局_整数数组, 整数型, 数组, "0"
    .局部变量 局_计次, 整数型

    .如果真 (是否为空 (文本数组) ＝ 假)
        .计次循环首 (取数组成员数 (文本数组), 局_计次)
            .如果真 (内部_数组成员是否存在_文本 (局_文本数组, 文本数组 [局_计次]) ＝ -1)
                加入成员 (局_文本数组, 文本数组 [局_计次])
            .如果真结束
            
        .计次循环尾 ()
        文本数组 ＝ 局_文本数组
        返回 (取数组成员数 (文本数组))
    .如果真结束
    
    .如果真 (是否为空 (整数数组) ＝ 假)
        .计次循环首 (取数组成员数 (整数数组), 局_计次)
            .如果真 (内部_数组成员是否存在_整数 (局_整数数组, 整数数组 [局_计次]) ＝ -1)
                加入成员 (局_整数数组, 整数数组 [局_计次])
            .如果真结束
            
        .计次循环尾 ()
        整数数组 ＝ 局_整数数组
        返回 (取数组成员数 (整数数组))
    .如果真结束
    返回 (0)

.子程序 数组_取次数, 整数型, 公开, 取指定数组成员出现相同数量，源码由易友【C盘是头猪】提供。
    .参数 参数_数组, 文本型, 数组
    .参数 参数_成员, 文本型
    .局部变量 n, 整数型
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (参数_数组), i)
        .如果真 (参数_数组 [i] ＝ 参数_成员)
            n ＝ n ＋ 1
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    返回 (n)

.子程序 文本_取长度, 整数型, 公开, 取一段文本的长度，中文算两个长度，字母算一个长度
    .参数 源文本, 文本型

    返回 (lstrlenA (取指针文本_ (源文本)))

.子程序 文本_取长度W, 整数型, 公开, 取一段文本的长度，中文和字母都算一个长度
    .参数 源文本, 字节集, , Unicode字节集

    返回 (lstrlenW (取指针_字节集型 (源文本)))

.子程序 文本_取声母, 文本型, 公开, 取一组文本中每个字的拼音首字,如果不是中文就直接取
    .参数 文本, 文本型, , 转换前文本
    .局部变量 循环次数, 整数型
    .局部变量 结果, 文本型

    文本 ＝ 到全角 (文本)
    .计次循环首 (取文本长度 (文本), 循环次数)
        .判断开始 (取代码 (到半角 (取文本中间 (文本, 循环次数 × 2 － 1, 2)), ) ＞ 0)
            结果 ＝ 结果 ＋ 到半角 (取文本中间 (文本, 循环次数 × 2 － 1, 2))
        .默认
            结果 ＝ 结果 ＋ 取文本左边 (取声母 (取文本中间 (文本, 循环次数 × 2 － 1, 2), 1), 1)
        .判断结束
        
    .计次循环尾 ()
    
    返回 (结果)

.子程序 文本_到小写, 文本型, 公开, 把字母转换到小写
    .参数 要转换的文本, 文本型, , 要转换的文本
    .局部变量 局_欲转换的文本, 文本型

    局_欲转换的文本 ＝ 要转换的文本
    返回 (CharLowerA (局_欲转换的文本))

.子程序 文本_到小写EX, 文本型, 公开, 把字母转换到小写
    .参数 要转换的文本, 文本型, , 要转换的文本
    .局部变量 局_转换, 文本型

    局_转换 ＝ 要转换的文本
    返回 (API_文本小写 (局_转换))

.子程序 文本_到小写m, 文本型, 公开, 将文本中的大写英文字母变换为小写，返回变换后的结果文本。本命令为初级命令。
    .参数 欲变换的文本, 文本型

    置入代码 ({ 81 }) ' 00445FC0      51            push ecx
    置入代码 ({ 82 }) ' 00445FC1      52            push edx
    置入代码 ({ 83 }) ' 00445FC2      53            push ebx
    置入代码 ({ 86 }) ' 00445FC3      56            push esi
    置入代码 ({ 87 }) ' 00445FC4      57            push edi
    
    ' -------------------------------------------------------------------
    RtlAllocateHeap (GetProcessHeap (), 0, 32) ' 申请一块栈空间地址
    ' 置入代码 ({ 139, 248 })  ' 8BF8          mov edi,eax           ;  目的内存地址
    置入代码 ({ 80 }) ' 50            push eax                    ;  保存内存地址
    
    ' ------------取参数<欲变换的文本>长度------------------------------
    置入代码 ({ 139, 125, 8 }) ' 8B7D 08       mov edi,dword ptr ss:[ebp+0x8]
    置入代码 ({ 139, 63 }) ' 8B3F          mov edi,dword ptr ds:[edi]
    置入代码 ({ 139, 247 }) ' 8BF7               mov esi,edi
    置入代码 ({ 131, 201, 255 }) ' 83C9 FF       or ecx,0xFFFFFFFF
    置入代码 ({ 51, 192 }) ' 33C0          xor eax,eax
    置入代码 ({ 242, 174 }) ' F2:AE         repne scas byte ptr es:[edi]
    置入代码 ({ 247, 209 }) ' F7D1          not ecx
    置入代码 ({ 73 }) ' 49            dec ecx
    置入代码 ({ 95 }) ' 5F              pop edi
    置入代码 ({ 87 }) ' 57              push edi
    ' -------------复制内容到刚申请的内存地址里-------------------------------------------
    置入代码 ({ 139, 217 }) ' 8BD9             mov ebx,ecx
    置入代码 ({ 193, 233, 2 }) ' C1E9 02          shr ecx,0x2
    置入代码 ({ 38, 243, 165 }) ' 26:F3:A5         rep movs dword ptr es:[edi],dword ptr es:[esi]
    置入代码 ({ 139, 203 }) ' 8BCB             mov ecx,ebx
    置入代码 ({ 131, 225, 3 }) ' 83E1 03          and ecx,0x3
    置入代码 ({ 243, 164 }) ' F3:A4            rep movs byte ptr es:[edi],byte ptr [esi]
    置入代码 ({ 198, 7, 0 }) ' C607 00          mov byte ptr [edi],0x0
    ' ---------------转大写-----------------------------------------------------------------
    置入代码 ({ 51, 210 }) ' 33D2             xor edx,edx
    置入代码 ({ 88 }) ' 58               pop eax
    置入代码 ({ 139, 248 }) ' 8BF8          mov edi,eax
    
    置入代码 ({ 128, 60, 58, 65 }) ' 803C3A 41       cmp byte ptr [edx+edi],0x41
    置入代码 ({ 124, 10 }) ' 7C 0A           jl X0040112F
    置入代码 ({ 128, 60, 58, 90 }) ' 803C3A 5A       cmp byte ptr [edx+edi],0x5A
    置入代码 ({ 127, 4 }) ' 7F 04           jg X0040112F
    置入代码 ({ 128, 12, 58, 32 }) ' 800C3A 20       or byte ptr [edx+edi],0x20
    
    置入代码 ({ 128, 60, 58, 0 }) ' 803C3A 00       cmp byte ptr [edx+edi],0x0
    置入代码 ({ 116, 3 }) ' 74 03            je X0040101E
    置入代码 ({ 66 }) ' 42               inc edx
    置入代码 ({ 235, 231 }) ' EB E7            jmp X00401005
    ' -------------恢复寄存器原状态-------------------------------------------------------------
    置入代码 ({ 95 }) ' 00445FC5      5F            pop edi
    置入代码 ({ 94 }) ' 00445FC6      5E            pop esi
    置入代码 ({ 91 }) ' 00445FC7      5B            pop ebx
    置入代码 ({ 90 }) ' 00445FC8      5A            pop edx
    置入代码 ({ 89 }) ' 00445FC9      59            pop ecx
    置入代码 ({ 201 }) ' C9                       leave
    置入代码 ({ 194, 4, 0 }) ' C2 0400       retn 0x4
    返回 (“”)

.子程序 文本_到大写, 文本型, 公开, 把字母转换到大写
    .参数 要转换的文本, 文本型, , 要转换的文本
    .局部变量 局_欲转换的文本, 文本型

    局_欲转换的文本 ＝ 要转换的文本
    返回 (CharUpperA (局_欲转换的文本))

.子程序 文本_折行, 文本型, 公开, 把一段长文本按你指定的字数分行
    .参数 要处理的文本, 文本型
    .参数 每行字数, 整数型, 可空, 半角字数，如果为空，将不进行分行操作，直接返回文本内容，如果包含文本或全角字符，则需要把每行字数至少设置为2
    .参数 是否强行分行, 逻辑型, 可空, 为真则强行按设定长度分行。为假则保留连续半角数字或字母为一行。默认为假。
    .参数 是否全角, 逻辑型, 可空, 是否将半角转换为全角,如果为空即不转换
    .参数 首空字节数, 整数型, 可空, 在每行前面加入空格,如果为空,为0,即不加空格
    .局部变量 操作文本, 文本型
    .局部变量 开始位置, 整数型
    .局部变量 读取长度, 整数型
    .局部变量 开始计算半角, 逻辑型
    .局部变量 半角位置, 整数型
    .局部变量 结果文本, 文本型

    .如果真 (是否为空 (每行字数))
        返回 (要处理的文本)
    .如果真结束
    .如果真 (是否为空 (是否强行分行))
        是否强行分行 ＝ 假
    .如果真结束
    .如果真 (是否全角 ＝ 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “...”, “…”, 1, , 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “->”, “→”, 1, , 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “<-”, “←”, 1, , 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “--”, “—”, 1, , 真)
        要处理的文本 ＝ 到全角 (要处理的文本)
    .如果真结束
    .如果真 (首空字节数 ≥ 1)
        要处理的文本 ＝ 取空白文本 (首空字节数) ＋ 要处理的文本
        要处理的文本 ＝ 子文本替换 (要处理的文本, #换行符, #换行符 ＋ 取空白文本 (首空字节数), 1, , 真)
    .如果真结束
    操作文本 ＝ 要处理的文本
    .判断循环首 (取文本长度 (操作文本) ＞ 每行字数)
        .判断循环首 (读取长度 ＜ 每行字数)
            ' 首先这里存在2个情况，一个是如果为全角或汉字。则他们1位是2个长度，直接取是取不出来的。
            .如果 (取代码 (操作文本, 读取长度 ＋ 1) ≥ 127 或 取代码 (操作文本, 读取长度 ＋ 1) ＜ 0)
                ' 如果不是半角的话。则需要把读取长度增加到2
                半角位置 ＝ 0
                开始计算半角 ＝ 假
                .如果真 (读取长度 ＝ 每行字数 － 1)
                    输出调试文本 (“文本_折行 - 注意：检测到文本中包含中文或全角字符，需要把每行字数至少设置为2.”)
                    返回 (“”)
                .如果真结束
                读取长度 ＝ 读取长度 ＋ 2
            .否则
                .判断开始 (取文本中间 (操作文本, 读取长度 ＋ 1, 1) ＝ “ ”)
                    读取长度 ＝ 读取长度 ＋ 1
                    半角位置 ＝ 0
                    开始计算半角 ＝ 假
                .判断 (取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ #换行符)
                    读取长度 ＝ 读取长度 ＋ 2
                    跳出循环 ()
                .默认
                    .如果真 (开始计算半角 ＝ 假)
                        半角位置 ＝ 读取长度
                        开始计算半角 ＝ 真
                    .如果真结束
                    读取长度 ＝ 读取长度 ＋ 1
                .判断结束
                
            .如果结束
            
        .判断循环尾 ()
        .如果真 (读取长度 ≥ 每行字数)
            .如果 (是否强行分行 ＝ 假)
                读取长度 ＝ 选择 (半角位置 ＝ 0, 每行字数, 选择 (取代码 (操作文本, 每行字数 ＋ 1) ≥ 127 或 取代码 (操作文本, 每行字数 ＋ 1) ＜ 0, 每行字数, 半角位置))
                开始计算半角 ＝ 假
                半角位置 ＝ 0
            .否则
                读取长度 ＝ 每行字数
            .如果结束
            
        .如果真结束
        .如果真 (是否强行分行 ＝ 假)
            .如果 (取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “《” 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “（” 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ #左引号 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “〈” 或 取文本中间 (操作文本, 读取长度 － 11, 2) ＝ “‘”)
                读取长度 ＝ 读取长度 － 2
            .否则
                .如果真 (取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “》” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “）” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ #右引号 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “〉” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “，” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “。” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “？” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “：” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “’” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “；” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “、”)
                    .如果 (取代码 (操作文本, 读取长度) ≥ 127 或 取代码 (操作文本, 读取长度) ＜ 0)
                        读取长度 ＝ 读取长度 － 2
                    .否则
                        读取长度 ＝ 读取长度 － 1
                    .如果结束
                    
                .如果真结束
                
            .如果结束
            
        .如果真结束
        .如果 (取文本中间 (操作文本, 读取长度 － 1, 2) ＝ #换行符)
            结果文本 ＝ 结果文本 ＋ 取文本左边 (操作文本, 读取长度)
        .否则
            结果文本 ＝ 结果文本 ＋ 取文本左边 (操作文本, 读取长度) ＋ #换行符
        .如果结束
        操作文本 ＝ 取文本右边 (操作文本, 取文本长度 (操作文本) － 读取长度)
        读取长度 ＝ 0
    .判断循环尾 ()
    结果文本 ＝ 结果文本 ＋ 操作文本
    返回 (结果文本)

.子程序 文本_删首尾空, 文本型, 公开, 删除一段文本前后的空格
    .参数 源文本, 文本型
    .局部变量 局_欲删除空格的文本, 字节集

    局_欲删除空格的文本 ＝ 到字节集 (源文本) ＋ { 0 }
    PathRemoveBlanksA (取指针_字节集型 (局_欲删除空格的文本))
    返回 (取字节集数据 (局_欲删除空格的文本, #文本型, ))

.子程序 文本_删除空行, 文本型, 公开, 删除文本当中的空白行
    .参数 要操作的文本, 文本型
    .局部变量 正则, 正则表达式类

    .如果真 (取文本左边 (要操作的文本, 2) ＝ #换行符)
        要操作的文本 ＝ 取文本右边 (要操作的文本, 取文本长度 (要操作的文本) － 2)
    .如果真结束
    
    .如果真 (取文本右边 (要操作的文本, 2) ＝ #换行符)
        要操作的文本 ＝ 取文本左边 (要操作的文本, 取文本长度 (要操作的文本) － 2)
    .如果真结束
    正则.创建 (“(?:^\r|\n$)”, 要操作的文本, , , , ) ' 原表达式“\n\s*\r”
    返回 (正则.替换 (“”))

.子程序 文本_是否重复, 逻辑型, 公开, 判断文本中的指定文本是否有重复，有重复返回真，没得复返回假
    .参数 源文本, 文本型
    .参数 查询的文本, 文本型
    .参数 严格模式, 逻辑型, 可空, 可空。默认为正常模式。
    .局部变量 位置1, 整数型
    .局部变量 位置2, 整数型

    位置1 ＝ 寻找文本 (源文本, 查询的文本, , 真)
    .如果 (严格模式)
        返回 (寻找文本 (源文本, 查询的文本, 位置1 ＋ 1, 真) ＞ 0)
        
    .否则
        .如果真 (位置1 ＜ 1)
            返回 (假)
        .如果真结束
        返回 (寻找文本 (源文本, 查询的文本, 位置1 ＋ 取文本长度 (查询的文本), 真) ＞ 0)
    .如果结束
    返回 (假)

.子程序 文本_取左边, 文本型, 公开, 从文本的左边按 欲寻找的文本 开始寻找
    .参数 被查找的文本, 文本型, , 被查找的文本
    .参数 欲寻找的文本, 文本型, , 欲寻找的文本
    .参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
    .参数 是否不区分大小写, 逻辑型, 可空, 初始值为“假”。为真不区分大小写，为假区分。
    .局部变量 局_长度, 整数型
    .局部变量 局_起始搜寻位置, 整数型
    .局部变量 局_方向, 整数型
    .局部变量 局_找到的位置, 整数型
    .局部变量 局_返回结果, 文本型

    局_长度 ＝ 取文本长度 (被查找的文本)
    
    局_起始搜寻位置 ＝ 起始寻找位置
    .如果真 (局_起始搜寻位置 ＜ 0)
        局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
        .如果真 (局_起始搜寻位置 ＝ 1)
            局_起始搜寻位置 ＝ 0
        .如果真结束
        局_方向 ＝ 1
    .如果真结束
    
    .如果 (局_方向 ＝ 1)
        局_找到的位置 ＝ 倒找文本 (被查找的文本, 欲寻找的文本, 局_长度 － 局_起始搜寻位置, 是否不区分大小写)
    .否则
        .如果真 (局_起始搜寻位置 ＝ 0)
            局_起始搜寻位置 ＝ 1
        .如果真结束
        局_找到的位置 ＝ 寻找文本 (被查找的文本, 欲寻找的文本, 局_起始搜寻位置, 是否不区分大小写)
    .如果结束
    
    .如果真 (局_找到的位置 ＝ -1)
        返回 (“”)
    .如果真结束
    
    局_返回结果 ＝ 取文本左边 (被查找的文本, 局_找到的位置 － 1)
    返回 (局_返回结果)

.子程序 文本_取右边, 文本型, 公开, 从文本的右边按 欲寻找的文本 开始寻找, 取行右边 (“1234567890”, “5”, 1, 真)
    .参数 被查找的文本, 文本型, , 被查找的文本
    .参数 欲寻找的文本, 文本型, , 欲寻找的文本
    .参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从右往左寻找，如果为负数，则从左往右寻找。
    .参数 是否不区分大小写, 逻辑型, 可空, 默认为假,区分大小写
    .局部变量 局_长度, 整数型
    .局部变量 局_起始搜寻位置, 整数型
    .局部变量 局_方向, 整数型
    .局部变量 局_找到的位置, 整数型
    .局部变量 局_返回结果, 文本型

    局_长度 ＝ 取文本长度 (被查找的文本)
    
    局_起始搜寻位置 ＝ 起始寻找位置
    .如果真 (局_起始搜寻位置 ＜ 0)
        局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
        .如果真 (局_起始搜寻位置 ＝ 1)
            局_起始搜寻位置 ＝ 0
        .如果真结束
        局_方向 ＝ 1
    .如果真结束
    
    .如果 (局_方向 ＝ 1)
        .如果真 (局_起始搜寻位置 ＝ 0)
            局_起始搜寻位置 ＝ 1
        .如果真结束
        局_找到的位置 ＝ 寻找文本 (被查找的文本, 欲寻找的文本, 局_起始搜寻位置, 是否不区分大小写)
    .否则
        局_找到的位置 ＝ 倒找文本 (被查找的文本, 欲寻找的文本, 局_长度 － 局_起始搜寻位置, 是否不区分大小写)
    .如果结束
    
    .如果真 (局_找到的位置 ＝ -1)
        返回 (“”)
    .如果真结束
    
    局_返回结果 ＝ 取文本右边 (被查找的文本, 局_长度 － 取文本长度 (欲寻找的文本) － 局_找到的位置 ＋ 1)
    返回 (局_返回结果)

.子程序 文本_取首拼, 文本型, 公开, 取出给出文本的首拼;注:英文,数字,符号则直接返回.首拼一律为小写[V雪落有声V]
    .参数 文本, 文本型, , 需要取出首拼的文本.可以包含数字,字母.请使用半角格式.
    .局部变量 局_计次, 整数型
    .局部变量 局_文本, 文本型
    .局部变量 局_返回文本, 文本型

    局_计次 ＝ 1
    文本 ＝ 到半角 (文本)
    .判断循环首 (局_计次 ≤ 取文本长度 (文本))
        局_文本 ＝ 取文本中间 (文本, 局_计次, 1)
        .如果 (取代码 (局_文本, ) ＜ 0)
            局_文本 ＝ 取文本中间 (文本, 局_计次, 2)
            .如果真 (文本_是否为汉字 (局_文本))
                局_文本 ＝ 取文本左边 (取拼音 (局_文本, 1), 1)
                局_返回文本 ＝ 局_返回文本 ＋ 局_文本
            .如果真结束
            局_计次 ＝ 局_计次 ＋ 1
        .否则
            局_返回文本 ＝ 局_返回文本 ＋ 局_文本
        .如果结束
        局_计次 ＝ 局_计次 ＋ 1
    .判断循环尾 ()
    返回 (局_返回文本)

.子程序 文本_取空白文本, 文本型, 公开, 汇编方式获取空白文本，返回具有指定数目半角空格的文本
    .参数 文本长度, 整数型
    .局部变量 address, 整数型

    address ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 文本长度 ＋ 8)
    RtlFillMemory_字节 (address, 文本长度, 32)
    置入代码 ({ 139, 69, 8, 3, 69, 252, 139, 69, 252, 137, 236, 93, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' add eax,[ebp-4]
    ' mov eax,[ebp-4]
    ' mov esp,ebp
    ' pop ebp
    ' retn 4
    返回 (“”)
    
    

.子程序 文本_取行数, 整数型, 公开, 取一个文本共有有多少行。
    .参数 文本, 文本型

    置入代码 ({ 87, 51, 192, 139, 125, 8, 139, 63, 133, 255, 116, 24, 51, 201, 138, 15, 71, 128, 249, 10, 117, 1, 64, 132, 201, 117, 243, 138, 79, 255, 128, 249, 10, 116, 1, 64, 95, 139, 229, 93, 194, 4, 0 })
    返回 (0)

.子程序 文本_转拼音, 文本型, 公开, 把一段文本转换到拼音
    .参数 欲转拼音的文本, 文本型
    .参数 是否加空格, 逻辑型, 可空, 可空,默认为假,不加;
    .参数 是否全角, 逻辑型, 可空, 可空，默认为假，半角
    .参数 是否正则, 逻辑型, 可空, 是否正则方式判断，可以判断生僻的汉字，可空，默认为假 
    .局部变量 局_文本, 文本型
    .局部变量 局_字符数量, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_结果, 文本型

    欲转拼音的文本 ＝ 到全角 (欲转拼音的文本)
    局_字符数量 ＝ 取文本长度 (欲转拼音的文本) ÷ 2
    .计次循环首 (局_字符数量, 局_计次)
        局_文本 ＝ 取文本中间 (欲转拼音的文本, 局_计次 × 2 － 1, 2)
        .如果 (文本_是否为汉字 (局_文本, 是否正则))
            .判断开始 (是否加空格)
                局_结果 ＝ 局_结果 ＋ 取拼音 (局_文本, 1) ＋ “ ”
            .默认
                局_结果 ＝ 局_结果 ＋ 取拼音 (局_文本, 1)
            .判断结束
            
        .否则
            .判断开始 (是否全角)
                局_结果 ＝ 局_结果 ＋ 到全角 (局_文本)
            .默认
                局_结果 ＝ 局_结果 ＋ 到半角 (局_文本)
            .判断结束
            
        .如果结束
        
    .计次循环尾 ()
    欲转拼音的文本 ＝ 到半角 (欲转拼音的文本)
    返回 (局_结果)

.子程序 文本_替换行内容, 文本型, 公开, 替换指定行整行内容，返回替换后的文本。
    .参数 文本, 文本型
    .参数 行数, 整数型
    .参数 替换内容, 文本型
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型
    .局部变量 临时文本, 文本型, , "0"
    .局部变量 局_总数, 整数型

    临时文本 ＝ 分割文本 (文本, #换行符, )
    局_总数 ＝ 取数组成员数 (临时文本)
    .如果真 (行数 ＞ 局_总数)
        输出调试文本 (“传入行数大于实际文本行”)
        返回 (“”)
    .如果真结束
    临时文本 [行数] ＝ 替换内容
    .计次循环首 (局_总数, 计次)
        .如果真 (取数组成员数 (临时文本) ≠ 计次)
            输出文本 ＝ 输出文本 ＋ 临时文本 [计次] ＋ #换行符
            到循环尾 ()
        .如果真结束
        输出文本 ＝ 输出文本 ＋ 临时文本 [计次]
    .计次循环尾 ()
    清除数组 (临时文本)
    返回 (输出文本)

.子程序 文本_取随机汉字, 文本型, 公开, 取常用的随机汉字
    .参数 个数, 整数型, , 要取出多少个汉字！
    .参数 汉字或全拼, 整数型, 可空, 0为汉字，否则为全拼音！
    .局部变量 计次, 整数型
    .局部变量 得到的文本, 文本型

    .判断开始 (汉字或全拼 ＝ 0)
        .计次循环首 (个数, 计次)
            得到的文本 ＝ 得到的文本 ＋ 到文本 (字符 (－汇编_取随机数 (38, 80)) ＋ 字符 (－汇编_取随机数 (38, 80)))
        .计次循环尾 ()
    .默认
        .计次循环首 (个数, 计次)
            得到的文本 ＝ 得到的文本 ＋ 取拼音 (到文本 (字符 (－汇编_取随机数 (38, 80)) ＋ 字符 (－汇编_取随机数 (38, 80))), 1)
        .计次循环尾 ()
    .判断结束
    返回 (得到的文本)

.子程序 文本_取随机字母, 文本型, 公开, 取随机26个字母！
    .参数 要取的字符数, 整数型, , 要取字符个数；
    .参数 字母类型, 整数型, 可空, 可空：默认为小写字母；0=小写字母；1=大写字母；2=大小写字母混合；
    .局部变量 临时文本, 文本型
    .局部变量 大小写, 整数型
    .局部变量 i, 整数型

    .判断开始 (字母类型 ＝ 0)
        .计次循环首 (要取的字符数, )
            临时文本 ＝ 临时文本 ＋ 字符 (汇编_取随机数 (97, 122))
        .计次循环尾 ()
    .判断 (字母类型 ＝ 1)
        .计次循环首 (要取的字符数, )
            临时文本 ＝ 临时文本 ＋ 字符 (汇编_取随机数 (65, 90))
        .计次循环尾 ()
    .默认
        .计次循环首 (要取的字符数, i)
            大小写 ＝ 选择 (i ％ 2 ＝ 1, 1, 0)
            .如果 (大小写 ＝ 1)
                临时文本 ＝ 临时文本 ＋ 字符 (汇编_取随机数 (97, 122))
            .否则
                临时文本 ＝ 临时文本 ＋ 字符 (汇编_取随机数 (65, 90))
            .如果结束
            
        .计次循环尾 ()
    .判断结束
    返回 (临时文本)

.子程序 文本_取随机姓氏, 文本型, 公开, 取出一个随机的百家姓！
    .参数 汉字或全拼, 整数型, 可空, 0为汉字，否则为全拼音！

    .判断开始 (汉字或全拼 ＝ 0)
        返回 (取文本中间 (#百家姓, 到数值 (文本_取随机范围数字 (1, 814, 1)), 2))
    .默认
        返回 (取拼音 (取文本中间 (#百家姓, 到数值 (文本_取随机范围数字 (1, 814, 1)), 2), 1))
    .判断结束
    

.子程序 文本_取随机数字, 文本型, 公开, 汇编_取随机数字，可选单或双！
    .参数 字符数, 整数型, , 要取字符个数
    .参数 单双选择, 整数型, 可空, 0为单双，1为单，其他数值为双；默认单双一起
    .局部变量 返回的文本, 文本型

    .判断开始 (单双选择 ＝ 0)
        .计次循环首 (字符数, )
            返回的文本 ＝ 返回的文本 ＋ 到文本 (汇编_取随机数 (0, 9))
        .计次循环尾 ()
    .判断 (单双选择 ＝ 1)
        .计次循环首 (字符数, )
            返回的文本 ＝ 返回的文本 ＋ 到文本 (多项选择 (汇编_取随机数 (1, 5), 1, 3, 5, 7, 9))
        .计次循环尾 ()
    .默认
        .计次循环首 (字符数, )
            返回的文本 ＝ 返回的文本 ＋ 到文本 (多项选择 (汇编_取随机数 (1, 5), 0, 2, 4, 6, 8))
        .计次循环尾 ()
    .判断结束
    返回 (返回的文本)

.子程序 汇编_取随机数, 整数型, 公开, 返回一个指定范围内的随机数值。在使用本命令取一系列的随机数之前，应该先使用“置随机数种子”命令为随机数生成器初始化一个种子值。本命令为初级命令。
    .参数 欲取随机数的最小值, 整数型, 可空, 参数必须大于或等于零。本参数如果被省略，默认为 0。
    .参数 欲取随机数的最大值, 整数型, 可空, 参数必须大于或等于零。本参数如果被省略，默认为无限。

    ' 例程来自：https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=13841642&pid=8692203
    置入代码 ({ 81, 82, 15, 49, 105, 192, 253, 67, 3, 0, 5, 195, 158, 38, 0, 193, 232, 16, 37, 255, 127, 0, 0, 139, 77, 16, 133, 201, 117, 5, 185, 255, 255, 255, 127, 43, 77, 8, 65, 51, 210, 247, 241, 3, 85, 8, 139, 194, 90, 89, 139, 229, 93, 194, 16, 0 })
    ' PUSH EBP
    ' MOV EBP, ESP
    ' PUSH ECX
    ' PUSH EDX
    ' RDTSC
    ' IMUL EAX, EAX, 343FDh
    ' ADD EAX, 269EC3h
    ' SHR EAX, 10h
    ' AND EAX, 7FFFh
    ' MOV ECX, DWORD PTR SS:[EBP+10h]
    ' TEST ECX, ECX
    ' JNZ SHORT Jump
    ' MOV ECX, 7FFFFFFFh
    ' @Jump:
    ' SUB ECX, DWORD PTR SS:[EBP+8h]
    ' INC ECX
    ' XOR EDX, EDX
    ' DIV ECX
    ' ADD EDX, DWORD PTR SS:[EBP+8h]
    ' MOV EAX, EDX
    ' POP EDX
    ' POP ECX
    ' MOV ESP, EBP
    ' POP EBP
    ' RETN 10h
    返回 (0)

.子程序 汇编_取随机数_硬件版, 整数型, 公开, 部分CPU不支持 失败返回 0
    .参数 欲取随机数的最小值, 整数型, 可空
    .参数 欲取随机数的最大值, 整数型, 可空

    ' 例程来自：http://bbs.eyuyan.com/read.php?tid=405670
    .判断开始 (IsRdRandSupported ())
        .如果真 (欲取随机数的最小值 ＝ 0)
            欲取随机数的最小值 ＝ 1
        .如果真结束
        .如果真 (欲取随机数的最大值 ＝ 0)
            欲取随机数的最大值 ＝ 9999
        .如果真结束
        
        返回 (RdRand (欲取随机数的最小值, 欲取随机数的最大值))
    .默认
        返回 (0)
    .判断结束
    

.子程序 汇编_取随机数种子_硬件版, 整数型, 公开, 部分CPU不支持 失败返回 0
    ' 例程来自：http://bbs.eyuyan.com/read.php?tid=405670
    .判断开始 (IsRdSeedSupported ())
        返回 (RdSeed ())
    .默认
        返回 (0)
    .判断结束
    

.子程序 IsRdRandSupported, 逻辑型
    置入代码 ({ 184, 1, 0, 0, 0, 15, 162, 49, 192, 15, 186, 225, 30, 17, 192, 201, 195 })
    返回 (假)

.子程序 IsRdSeedSupported, 逻辑型
    置入代码 ({ 184, 7, 0, 0, 0, 49, 201, 15, 162, 49, 192, 15, 186, 227, 18, 17, 192, 201, 195 })
    返回 (假)

.子程序 RdRand, 整数型, , 直接调用取随机数即可 不需要随机种子 By莽
    .参数 Min, 整数型
    .参数 Max, 整数型

    置入代码 ({ 81, 82, 15, 199, 240, 139, 77, 12, 43, 77, 8, 65, 51, 210, 247, 241, 3, 85, 8, 139, 194, 90, 89, 201, 194, 8, 0 })
    返回 (0)

.子程序 RdSeed, 长整数型, , 取随机数种子 作为其他伪随机数的种子 By莽
    置入代码 ({ 15, 199, 248, 201, 195 })
    返回 (0)

.子程序 文本_取随机字符, 文本型, 公开, 取随机可见字符,只取能显示的字符
    .参数 要取的字符数, 整数型, , 要取字符个数
    .参数 获取模式, 整数型, 可空, 获取模式, 1=数字, 2=小写字母, 4=大写字母, 8=特殊字符, 需要多个组合用位或或起来, 默认为1, 只返回数字
    .局部变量 buffer, 字节集
    .局部变量 pBuffer, 整数型
    .局部变量 bufferSize, 整数型
    .局部变量 str, 文本型
    .局部变量 pStr, 整数型
    .局部变量 tmp, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    置随机数种子 ()
    buffer ＝ 取空白字节集 (129)
    pBuffer ＝ 取指针_字节集型 (buffer)
    str ＝ 取空白文本 (要取的字符数)
    pStr ＝ 取指针_文本型 (str)
    .如果真 (位与 (获取模式, 1) ≠ 0)
        tmp ＝ 位或 (tmp, 1)
    .如果真结束
    .如果真 (位与 (获取模式, 2) ≠ 0)
        tmp ＝ 位或 (tmp, 2)
    .如果真结束
    .如果真 (位与 (获取模式, 4) ≠ 0)
        tmp ＝ 位或 (tmp, 4)
    .如果真结束
    .如果真 (位与 (获取模式, 8) ≠ 0)
        tmp ＝ 位或 (tmp, 8)
    .如果真结束
    .如果真 (tmp ＝ 0)
        tmp ＝ 1
    .如果真结束
    获取模式 ＝ tmp
    .如果真 (位与 (获取模式, 1) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“0123456789”), 10)
        bufferSize ＝ bufferSize ＋ 10
    .如果真结束
    .如果真 (位与 (获取模式, 2) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“abcdefghijklmnopqrstuvwxyz”), 26)
        bufferSize ＝ bufferSize ＋ 26
    .如果真结束
    .如果真 (位与 (获取模式, 4) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“ABCDEFGHIJKLMNOPQRSTUVWXYZ”), 26)
        bufferSize ＝ bufferSize ＋ 26
    .如果真结束
    .如果真 (位与 (获取模式, 8) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“ !” ＋ #引号 ＋ “#$%&'()*+,-./:;<=>?@[\]^_`{|}~”), 33)
        bufferSize ＝ bufferSize ＋ 33
    .如果真结束
    bufferSize ＝ bufferSize － 1
    .计次循环首 (要取的字符数, i)
        RtlMoveMemory (pStr ＋ i － 1, pBuffer ＋ 取随机数 (0, bufferSize), 1)
    .计次循环尾 ()
    返回 (str)

.子程序 文本_插入新一行, 文本型, 公开, 在指定行插入文本，原文本后移，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 行数, 整数型
    .参数 新一文本行内容, 文本型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型

    文本数组 ＝ 分割文本 (原文本, #换行符, )
    插入成员 (文本数组, 行数, 新一文本行内容)
    .计次循环首 (取数组成员数 (文本数组), 计次)
        .如果真 (取数组成员数 (文本数组) ＝ 计次)
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
            跳出循环 ()
        .如果真结束
        输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
    .计次循环尾 ()
    清除数组 (文本数组)
    返回 (输出文本)

.子程序 文本_是否为汉字, 逻辑型, 公开, 中间不能有空格,判断一个文本是否全为汉字,是汉字返回真,否则返回假
    .参数 欲判断文本, 文本型
    .参数 正则方式, 逻辑型, 可空, 是否正则方式判断，可以判断生僻的汉字
    .局部变量 局_区码, 字节型
    .局部变量 局_位码, 字节型
    .局部变量 RegExp, 对象
    .局部变量 匹配文本, 文本型
    .局部变量 bool, 逻辑型
    .局部变量 局_长度
    .局部变量 i, 整数型
    .局部变量 局_键代码, 整数型

    局_长度 ＝ 取文本长度 (删全部空 (欲判断文本))
    .如果真 (局_长度 ≤ 1)
        返回 (假)
    .如果真结束
    .如果真 (正则方式)
        CoInitialize (0)
        RegExp.创建 (“VBScript.RegExp”, )
        RegExp.写属性 (“Pattern”, “^[\u4e00-\u9fa5]{1,}$”)
        bool ＝ RegExp.逻辑方法 (“Test”, 欲判断文本)
        RegExp.清除 ()
        CoUninitialize ()
        返回 (bool)
    .如果真结束
    ' 非正则方式判断------------------------------------------------
    .计次循环首 (局_长度, i)
        局_键代码 ＝ 取代码 (欲判断文本, i)
        .如果真 (局_键代码 ≥ 0)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_是否为汉字2, 逻辑型, 公开, 中间不能有空格,判断一个文本第一个字是否是汉字,是汉字返回真,否则返回假
    .参数 欲判断文本, 文本型
    .局部变量 局_欲判断文本, 文本型
    .局部变量 局_长度, 整数型
    .局部变量 局_拼音, 文本型

    局_欲判断文本 ＝ 欲判断文本
    局_欲判断文本 ＝ 删全部空 (局_欲判断文本)
    局_长度 ＝ 取文本长度 (局_欲判断文本)
    .如果真 (局_长度 ＜ 2)
        返回 (假)
    .如果真结束
    局_拼音 ＝ 取拼音 (取文本左边 (局_欲判断文本, 2), 1)
    返回 (局_拼音 ≠ “”)

.子程序 文本_是否为双字节字符, 逻辑型, 公开, 与  OPenGL支持库->文字轮廓 中的 是否为双字节字符相同，如果为双字节返回真，否则返回假。
    .参数 欲检查文本, 文本型
    .参数 欲检查的字符位置

    返回 (IsDBCSLeadByteEx (欲检查的字符位置, 取代码 (欲检查文本, )))

.子程序 文本_是否为字母, 逻辑型, 公开, 中间不能有空格
    .参数 文本字符, 文本型
    .局部变量 Len, 整数型
    .局部变量 i, 整数型
    .局部变量 asc, 整数型

    Len ＝ 取文本长度 (文本字符)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (文本字符, i)
        .判断开始 (asc ≥ 65 且 asc ≤ 90) ' A-Z
            
        .判断 (asc ≥ 97 且 asc ≤ 122) ' a-z
            
        .默认
            返回 (假)
        .判断结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_取出现次数, 整数型, 公开, 返回指定文本中指定内容出现的次数
    .参数 被搜索文本, 文本型
    .参数 欲搜索文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .局部变量 位置_, 整数型, , , 感谢论坛会员 Mr.Yang提供的代码
    .局部变量 i, 整数型

    .如果真 (取文本长度 (被搜索文本) ＞ 0 且 取文本长度 (欲搜索文本) ＞ 0)
        位置_ ＝ 寻找文本 (被搜索文本, 欲搜索文本, , 取反 (是否区分大小写))
        .判断循环首 (位置_ ≠ -1)
            i ＝ i ＋ 1
            位置_ ＝ 寻找文本 (被搜索文本, 欲搜索文本, 位置_ ＋ 取文本长度 (欲搜索文本), 取反 (是否区分大小写))
        .判断循环尾 ()
    .如果真结束
    返回 (i)

.子程序 文本_首字母改大写, 文本型, 公开, 〈文本型〉 首字母大写 （文本）例： FOXPRO 或 foxpro，返回 Foxpro，注意本命令对首字为汉字的文本无效
    .参数 英文文本, 文本型

    返回 (到大写 (取文本左边 (英文文本, 1)) ＋ 取文本中间 (英文文本, 2, 取文本长度 (英文文本)))

.子程序 文本_取汉字区位码, 文本型, 公开, 返回一个汉字的区位码,如果汉字过长,只取第一个字,如果不是汉字,返回空
    .参数 汉字, 文本型, , 传送一个汉字进行处理
    .参数 区码还是位码, 整数型, 可空, 需返回的内容,1表示区码,2表示位码,3表示区码与位码都返回,默认为3
    .局部变量 区码, 字节型
    .局部变量 位码, 字节型

    区码 ＝ 取代码 (取文本左边 (汉字, 1), )
    位码 ＝ 取代码 (取文本中间 (汉字, 2, 1), )
    .如果真 (区码 ＜ 176 或 区码 ＞ 247 或 位码 ＜ 161 或 位码 ＞ 254)
        返回 (“”)
    .如果真结束
    .判断开始 (区码还是位码 ＝ 1)
        返回 (到文本 (区码))
    .判断 (区码还是位码 ＝ 2)
        返回 (到文本 (位码))
    .判断 (区码还是位码 ＝ 3)
        返回 (到文本 (区码) ＋ 到文本 (位码))
    .默认
        返回 (“”)
    .判断结束
    
    

.子程序 文本_取汉字机内码, 文本型, 公开
    .参数 汉字, 文本型
    .局部变量 机内码, 整数型

    .如果真 (取代码 (汉字, 1) ＞ 0)
        返回 (“”)
    .如果真结束
    机内码 ＝ (取代码 (汉字, 1) ＋ 256) × 256 ＋ 取代码 (汉字, 2) ＋ 256
    返回 (取十六进制文本 (机内码))
    ' 区位码 ＝ 机内码 － 41120  ' 41120=A0A0H

.子程序 文本_取出中间文本, 文本型, 公开, 比如：欲取全文本为“12345”,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”，
    .参数 欲取全文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面文本, 文本型, , 3的前面为“2”，引号直接用 #引号，如："<font color="#引号red#引号">"
    .参数 后面文本, 文本型, , 3的后面为“4”，引号直接用 #引号，如："<font color="#引号red#引号">"
    .参数 起始搜寻位置, 整数型, 可空, 可空,这里是指搜寻 参数二 前面文本 的开始位置
    .参数 是否不区分大小写, 逻辑型, 可空, 为真不区分大小写，为假区分。
    .局部变量 局_前面文本位置, 整数型
    .局部变量 局_后面文本位置, 整数型
    .局部变量 局_前面文本, 文本型
    .局部变量 局_后面文本, 文本型

    局_前面文本 ＝ 子文本替换 (前面文本, “#引号”, #引号, , , 真)
    局_后面文本 ＝ 子文本替换 (后面文本, “#引号”, #引号, , , 真)
    局_前面文本位置 ＝ 寻找文本 (欲取全文本, 局_前面文本, 起始搜寻位置, 是否不区分大小写)
    .如果真 (局_前面文本位置 ≠ -1)
        局_前面文本位置 ＝ 局_前面文本位置 ＋ 取文本长度 (局_前面文本)
        局_后面文本位置 ＝ 寻找文本 (欲取全文本, 局_后面文本, 局_前面文本位置, 是否不区分大小写)
        .如果真 (局_后面文本位置 ≠ -1)
            返回 (取文本中间 (欲取全文本, 局_前面文本位置, 局_后面文本位置 － 局_前面文本位置))
        .如果真结束
        
    .如果真结束
    返回 (“”)

.子程序 文本_倒取出中间文本, 文本型, 公开, 比如：欲取全文本为“0012345”,现在要取出“123”，<123>的右边为“4”，<123>的左边为“0”，注意这里是倒取
    .参数 欲取全文本, 文本型, , 比如：欲取全文本为“0012345”
    .参数 右边文本, 文本型, , 123的右边为“4”，引号直接用 #引号，如："<font color=#引号red#引号>" 注意左右
    .参数 左边文本, 文本型, , 123的左边为“0”，引号直接用 #引号，如："<font color=#引号red#引号>" 注意左右
    .参数 倒数搜寻位置, 整数型, 可空, 可空,这里是指搜寻 参数二 右边文本的开始位置
    .参数 是否不区分大小写, 逻辑型, 可空, 默认为假：区分大小写 真：不区分大小写
    .局部变量 rPos, 整数型
    .局部变量 lPos, 整数型

    倒数搜寻位置 ＝ 选择 (倒数搜寻位置 ≤ 0, -1, 倒数搜寻位置)
    倒数搜寻位置 ＝ 取文本长度 (欲取全文本) － 倒数搜寻位置
    rPos ＝ 倒找文本 (欲取全文本, 右边文本, 倒数搜寻位置, 是否不区分大小写)
    .如果真 (rPos ≠ -1)
        lPos ＝ 倒找文本 (欲取全文本, 左边文本, rPos, 是否不区分大小写)
        .如果真 (lPos ≠ -1)
            lPos ＝ lPos ＋ 取文本长度 (左边文本)
        .如果真结束
        返回 (取文本中间 (欲取全文本, lPos, rPos － lPos))
    .如果真结束
    返回 (“”)

.子程序 文本_取文本所在行, 整数型, 公开, 查找某段字或关键中在文本中的哪一行出现，成功返回行数，失败返回0
    .参数 源文本, 文本型
    .参数 欲查找的文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .局部变量 局_文本, 文本型, , "0"
    .局部变量 局_计次, 整数型

    局_文本 ＝ 分割文本 (源文本, #换行符, )
    .计次循环首 (取数组成员数 (局_文本), 局_计次)
        .如果真 (寻找文本 (局_文本 [局_计次], 欲查找的文本, , 取反 (是否区分大小写)) ≠ -1)
            返回 (局_计次)
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 文本_取文本所在行_优化版, 整数型, 公开, 查找某段字或关键中在文本中的哪一行出现，成功返回行数，失败返回0
    .参数 源文本, 文本型
    .参数 欲查找的文本, 文本型
    .参数 起始搜寻位置, 整数型, 可空, 位置值从 1 开始。如果本参数被省略，默认为 1 【单位：行】
    .参数 是否区分大小写, 逻辑型, 可空
    .局部变量 局_文本, 文本型, , "0"
    .局部变量 局_计次, 整数型

    局_文本 ＝ 分割文本 (源文本, #换行符, )
    .计次循环首 (取数组成员数 (局_文本), 局_计次)
        .如果真 (是否为空 (起始搜寻位置))
            起始搜寻位置 ＝ 1
        .如果真结束
        .如果真 (寻找文本 (局_文本 [局_计次], 欲查找的文本, , 取反 (是否区分大小写)) ≠ -1)
            .如果真 (局_计次 ≥ 起始搜寻位置)
                返回 (局_计次)
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 文本_取汉字区位码2, 整数型, 公开
    .参数 汉字, 文本型
    .局部变量 机内码, 整数型

    .如果真 (取代码 (汉字, 1) ＞ 0)
        返回 (0)
    .如果真结束
    机内码 ＝ (取代码 (汉字, 1) ＋ 256) × 256 ＋ 取代码 (汉字, 2) ＋ 256
    ' 返回 (取十六进制文本 (机内码))
    返回 (机内码 － 41120) ' 41120=A0A0H

.子程序 文本_删除指定文本行, 文本型, 公开, 删除指定文本的一行文本，返回删行后的文本
    .参数 源文本, 文本型
    .参数 行数, 整数型, , 输入你想删除的行数，如：想删除第3行的整行文本就直接输3
    .局部变量 临时文本, 文本型, , "0"
    .局部变量 计次, 整数型
    .局部变量 输出文本, 文本型

    输出文本 ＝ 源文本
    .如果真 (寻找文本 (输出文本, #换行符, , 假) ＝ -1)
        输出文本 ＝ 输出文本 ＋ #换行符
    .如果真结束
    临时文本 ＝ 分割文本 (输出文本, #换行符, )
    输出文本 ＝ “”
    删除成员 (临时文本, 行数, )
    .计次循环首 (取数组成员数 (临时文本), 计次)
        .如果 (取数组成员数 (临时文本) ≠ 计次)
            输出文本 ＝ 输出文本 ＋ 临时文本 [计次] ＋ #换行符
        .否则
            输出文本 ＝ 输出文本 ＋ 临时文本 [计次]
        .如果结束
        
    .计次循环尾 ()
    清除数组 (临时文本)
    返回 (输出文本)

.子程序 文本_删除指定文件行, 逻辑型, 公开, 删除指定文件内的一行文本。
    .参数 文件路径, 文本型
    .参数 要删除的文本行文本, 文本型
    .局部变量 内容, 字节集
    .局部变量 行头, 整数型
    .局部变量 局_数据, 字节集

    内容 ＝ 读入文件 (文件路径)
    行头 ＝ 寻找字节集 (内容, 到字节集 (要删除的文本行文本), )
    局_数据 ＝ 字节集替换 (内容, 行头, 取字节集长度 (到字节集 (要删除的文本行文本) ＋ { 13, 10 }), { })
    返回 (写到文件 (文件路径, 局_数据))

.子程序 文本_取随机范围数字, 文本型, 公开, 如1-100之间的双数或单数或单双一起！
    .参数 起始数, 整数型, , 如：1
    .参数 结束数, 整数型, , 如：1000
    .参数 单双选择, 整数型, 可空, 1为单，2为双,否则为取单双
    .局部变量 临时整数, 整数型

    .判断开始 (起始数 ＜ 1 或 结束数 ＜ 1)
        返回 (“起始数或结束数都必须≥1”)
    .判断 (起始数 ＞ 结束数)
        临时整数 ＝ 汇编_取随机数 (结束数, 起始数)
    .默认
        临时整数 ＝ 汇编_取随机数 (起始数, 结束数)
    .判断结束
    
    
    .判断开始 (单双选择 ＝ 1)
        .如果真 (临时整数 ％ 2 ＝ 0)
            .判断开始 (临时整数 ＝ 结束数)
                临时整数 ＝ 临时整数 － 1
            .默认
                临时整数 ＝ 临时整数 ＋ 1
            .判断结束
            
        .如果真结束
        返回 (到文本 (临时整数))
    .判断 (单双选择 ＝ 2)
        .如果真 (临时整数 ％ 2 ＝ 1)
            .判断开始 (临时整数 ＝ 结束数)
                临时整数 ＝ 临时整数 － 1
            .默认
                临时整数 ＝ 临时整数 ＋ 1
            .判断结束
            
        .如果真结束
        返回 (到文本 (临时整数))
    .默认
        返回 (到文本 (临时整数))
    .判断结束
    

.子程序 文本_删除指定文件文本行1, 逻辑型, 公开, 感谢 @jr21066 分享开源
    .参数 参_文件路径, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_内容, 字节集
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    ' 真有人来参数0.也不出错了
    .如果真 (参_行号 ＝ 0)
        返回 (假)
    .如果真结束
    局_内容 ＝ 读入文件 (参_文件路径)
    
    .计次循环首 (参_行号 － 1, )
        ' 行开始定位到换行符的后边
        局_行开始 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
        .如果 (局_行开始 ＝ -1)
            返回 (假)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    局_行结束 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
    .如果 (局_行结束 ＝ -1)
        ' 如果文件尾没有换行符就以文件尾为单位
        .如果 (取字节集长度 (局_内容) ＞ 局_行开始)
            局_行结束 ＝ 取字节集长度 (局_内容)
        .否则
            返回 (假)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 1
    .如果结束
    
    .如果真 (写到文件 (参_文件路径, 取字节集左边 (局_内容, 局_行开始) ＋ 取字节集右边 (局_内容, 取字节集长度 (局_内容) － 局_行结束)))
        返回 (真)
    .如果真结束
    
    返回 (假)

.子程序 文本_删除指定变量文本行1, 文本型, 公开, 感谢【@jr21066 】分享开源
    .参数 参_文本, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    .如果真 (参_行号 ＝ 0)
        返回 (参_文本)
    .如果真结束
    .计次循环首 (参_行号 － 1, )
        局_行开始 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
        .如果 (局_行开始 ＝ -1)
            返回 (“”)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    局_行结束 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
    .如果 (局_行结束 ＝ -1)
        .如果 (取文本长度 (参_文本) ＞ 局_行开始)
            局_行结束 ＝ 取文本长度 (参_文本)
        .否则
            返回 (“”)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 1
    .如果结束
    返回 (取文本左边 (参_文本, 局_行开始) ＋ 取文本右边 (参_文本, 取文本长度 (参_文本) － 局_行结束))

.子程序 文本_取文本起始位置, , 公开, 返回某个字符的在整个文本中出现的位置数组，数组第一个成员是第一次出现的位置。
    .参数 文本, 文本型
    .参数 欲搜寻的文本, 文本型
    .参数 起始位置, 整数型, 参考 数组
    .局部变量 起始位置数值, 整数型
    .局部变量 起始位置数值2, 整数型
    .局部变量 文本长度, 整数型
    .局部变量 计次, 整数型

    文本长度 ＝ 取文本长度 (欲搜寻的文本)
    .计次循环首 (文本_取出现次数 (文本, 欲搜寻的文本), 计次)
        .如果 (计次 ＝ 1)
            起始位置数值 ＝ 寻找文本 (文本, 欲搜寻的文本, , 真)
            起始位置数值2 ＝ 起始位置数值 ＋ 文本长度 ＋ 1
            加入成员 (起始位置, 起始位置数值)
        .否则
            起始位置数值2 ＝ 寻找文本 (文本, 欲搜寻的文本, 起始位置数值2, 真)
            加入成员 (起始位置, 起始位置数值2)
            起始位置数值2 ＝ 起始位置数值2 ＋ 文本长度
        .如果结束
        
    .计次循环尾 ()

.子程序 字节集_取空白字节集, 字节集, 公开, 汇编方式获取空白字节集，返回具有特定数目 0 字节的字节集 
    .参数 字节集长度, 整数型

    HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 字节集长度 ＋ 8)
    置入代码 ({ 199, 0, 1, 0, 0, 0, 255, 117, 8, 143, 64, 4, 139, 229, 93, 194, 4, 0 })
    ' mov dword ptr[eax],01h  ;字节集 前4位 为整数1，第二个4位 是整数 字节集长度，写入1标记为字节集，可以当 字节数组引用
    
    ' push dword ptr[ebp+8]
    ' pop dword ptr[eax+4]
    ' mov esp,ebp
    ' pop ebp
    ' retn 4
    返回 ({ })

.子程序 文本_文本数组排序, , 公开, 排序从z到a排序或从a-z排序
    .参数 要排序的数组, 文本型, 数组, 要排序的数组。
    .参数 排序后的数组, 文本型, 参考 数组, 排序后结果返回的数组。
    .参数 排序方向是否从大到小, 逻辑型, 可空, 如果参数值为真，排序将从小到大；如果为假，则为从打到小。如果本参数被省略，将默认为假
    .局部变量 A, 整数型
    .局部变量 B, 整数型
    .局部变量 C, 整数型
    .局部变量 临时_文本, 文本型

    .如果真 (是否为空 (排序方向是否从大到小))
        排序方向是否从大到小 ＝ 假
    .如果真结束
    ' 注意：这里要保证原来的数组不发生改变，所以所有的排序操作都应该在排序后的数组中。
    复制数组 (排序后的数组, 要排序的数组)
    A ＝ 取数组成员数 (排序后的数组)
    .如果 (排序方向是否从大到小 ＝ 真)
        .判断循环首 (A ＞ 0)
            C ＝ 0
            .变量循环首 (1, A － 1, 1, B)
                .如果真 (排序后的数组 [B] ＜ 排序后的数组 [B ＋ 1])
                    临时_文本 ＝ 排序后的数组 [B]
                    排序后的数组 [B] ＝ 排序后的数组 [B ＋ 1]
                    排序后的数组 [B ＋ 1] ＝ 临时_文本
                    C ＝ B
                .如果真结束
                
            .变量循环尾 ()
            A ＝ C
        .判断循环尾 ()
        
    .否则
        .判断循环首 (A ＞ 0)
            C ＝ 0
            .变量循环首 (1, A － 1, 1, B)
                .如果真 (排序后的数组 [B] ＞ 排序后的数组 [B ＋ 1])
                    临时_文本 ＝ 排序后的数组 [B]
                    排序后的数组 [B] ＝ 排序后的数组 [B ＋ 1]
                    排序后的数组 [B ＋ 1] ＝ 临时_文本
                    C ＝ B
                .如果真结束
                
            .变量循环尾 ()
            A ＝ C
        .判断循环尾 ()
        
    .如果结束
    

.子程序 文本_插入文本到某行前, 文本型, 公开, 将文本加入到某行之前，返回加入后的文本。
    .参数 原文本, 文本型
    .参数 行数, 整数型
    .参数 欲插入内容, 文本型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型

    文本数组 ＝ 分割文本 (原文本, #换行符, )
    .如果真 (行数 ≤ 取数组成员数 (文本数组))
        文本数组 [行数] ＝ 欲插入内容 ＋ 文本数组 [行数]
        .计次循环首 (取数组成员数 (文本数组), 计次)
            .如果真 (取数组成员数 (文本数组) ＝ 计次)
                输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
                跳出循环 ()
            .如果真结束
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
        .计次循环尾 ()
        清除数组 (文本数组)
        返回 (输出文本)
    .如果真结束
    清除数组 (文本数组)
    返回 (“”)

.子程序 文本_插入文本到某行后, 文本型, 公开, 将文本加入到某行之后，返回加入后的文本。
    .参数 原文本, 文本型
    .参数 行数, 整数型
    .参数 欲插入内容, 文本型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型

    文本数组 ＝ 分割文本 (原文本, #换行符, )
    .如果真 (行数 ≤ 取数组成员数 (文本数组))
        文本数组 [行数] ＝ 文本数组 [行数] ＋ 欲插入内容
        .计次循环首 (取数组成员数 (文本数组), 计次)
            .如果真 (取数组成员数 (文本数组) ＝ 计次)
                输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
                跳出循环 ()
            .如果真结束
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
        .计次循环尾 ()
        清除数组 (文本数组)
        返回 (输出文本)
    .如果真结束
    清除数组 (文本数组)
    返回 (“”)

.子程序 文本_插入文本到某位置, 文本型, 公开, 插入某文本到左起某一位置，原文本后移，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 欲插入的文本, 文本型
    .参数 插入位置, 整数型, , 位置必须为偶数值（字母、数字、标点、符号都和汉字均占2长度)

    返回 (到半角 (文本替换 (到全角 (原文本), 插入位置 － 1, 0, 到全角 (欲插入的文本))))

.子程序 文本_取字符串宽度, 整数型, 公开
    .参数 启动窗口句柄, 整数型
    .参数 欲要取出的字符串, 文本型
    .局部变量 Size, 精易_坐标J

    GetTextExtentPointA (GetDC (启动窗口句柄), 欲要取出的字符串, 取文本长度 (欲要取出的字符串), Size)
    返回 (Size.x)

.子程序 文本_取指定文件文本行, 文本型, 公开, 成功返回指定的文本行文本，失败返回空文本。
    .参数 文件路径, 文本型
    .参数 行号, 整数型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 文本内容, 文本型

    文本内容 ＝ 到文本 (读入文件 (文件路径))
    文本数组 ＝ 分割文本 (文本内容, #换行符, )
    .如果真 (行号 ≤ 0)
        返回 (“”)
    .如果真结束
    .如果真 (行号 ＞ 取数组成员数 (文本数组))
        返回 (“”)
    .如果真结束
    返回 (文本数组 [行号])

.子程序 文本_取指定变量文本行, 文本型, 公开, 成功返回指定的文本行文本，失败返回空文本。
    .参数 文本, 文本型
    .参数 行号, 整数型
    .局部变量 文本数组, 文本型, , "0"

    文本数组 ＝ 分割文本 (文本, #换行符, )
    .如果真 (行号 ≤ 0)
        返回 (“”)
    .如果真结束
    .如果真 (行号 ＞ 取数组成员数 (文本数组))
        返回 (“”)
    .如果真结束
    返回 (文本数组 [行号])

.子程序 文本_取指定文件文本行1, 文本型, 公开, 感谢【@jr21066】分享开源
    .参数 参_文件路径, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_内容, 字节集
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    .如果真 (参_行号 ＝ 0)
        返回 (“”)
    .如果真结束
    局_内容 ＝ 读入文件 (参_文件路径)
    .计次循环首 (参_行号 － 1, )
        局_行开始 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
        .如果 (局_行开始 ＝ -1)
            返回 (“”)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 2
        .如果结束
        
    .计次循环尾 ()
    .如果真 (局_行开始 ＝ 0)
        局_行开始 ＝ 1
    .如果真结束
    局_行结束 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
    .如果 (局_行结束 ＝ -1)
        .如果 (取字节集长度 (局_内容) ＞ 局_行开始)
            局_行结束 ＝ 取字节集长度 (局_内容) ＋ 1
        .否则
            返回 (“”)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 2
    .如果结束
    返回 (到文本 (取字节集中间 (局_内容, 局_行开始, 局_行结束 － 局_行开始)))

.子程序 文本_取指定变量文本行1, 文本型, 公开, 感谢【@jr21066 】分享开源
    .参数 参_文本, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    .如果真 (参_行号 ＝ 0)
        返回 (“”)
    .如果真结束
    
    .计次循环首 (参_行号 － 1, )
        局_行开始 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
        .如果 (局_行开始 ＝ -1)
            返回 (“”)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 2
        .如果结束
        
    .计次循环尾 ()
    .如果真 (局_行开始 ＝ 0)
        局_行开始 ＝ 1
    .如果真结束
    局_行结束 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
    .如果 (局_行结束 ＝ -1)
        .如果 (取文本长度 (参_文本) ＞ 局_行开始)
            局_行结束 ＝ 取文本长度 (参_文本)
        .否则
            返回 (“”)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 1
    .如果结束
    返回 (取文本中间 (参_文本, 局_行开始, 局_行结束 － 局_行开始 ＋ 1))

.子程序 文本_取文本行出现次数, 整数型, 公开, 取某行文本共出现了多少次，不存在返回-1。
    .参数 被搜寻的文本, 文本型
    .参数 行数, 整数型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 出现的次数, 整数型

    文本数组 ＝ 分割文本 (被搜寻的文本, 文本_取指定变量文本行 (被搜寻的文本, 行数), )
    出现的次数 ＝ 取数组成员数 (文本数组) － 1
    .如果 (出现的次数 ＜ 0)
        清除数组 (文本数组)
        返回 (-1)
    .否则
        清除数组 (文本数组)
        返回 (出现的次数)
    .如果结束
    

.子程序 文本_取文本行起始位置, , 公开, 返回某行在整个文本中出现的位置数组，数组第一个成员是第一次出现的位置。
    .参数 文本, 文本型
    .参数 行数, 整数型
    .参数 起始位置, 整数型, 参考 数组
    .局部变量 起始位置数值, 整数型
    .局部变量 起始位置数值2, 整数型
    .局部变量 文本行, 文本型
    .局部变量 文本长度, 整数型
    .局部变量 计次, 整数型

    文本行 ＝ 文本_取指定变量文本行 (文本, 行数)
    文本长度 ＝ 取文本长度 (文本行)
    .计次循环首 (文本_取文本行出现次数 (文本, 行数), 计次)
        .如果 (计次 ＝ 1)
            起始位置数值 ＝ 寻找文本 (文本, 文本行, , 真)
            起始位置数值2 ＝ 起始位置数值 ＋ 文本长度 ＋ 1
            加入成员 (起始位置, 起始位置数值)
        .否则
            起始位置数值2 ＝ 寻找文本 (文本, 文本行, 起始位置数值2, 真)
            加入成员 (起始位置, 起始位置数值2)
            起始位置数值2 ＝ 起始位置数值2 ＋ 文本长度
        .如果结束
        
    .计次循环尾 ()

.子程序 文本_寻找出文本并删除, 文本型, 公开, 比如：欲寻找的全文本为<12345789>,现在要删除2到5之间的全部字符，包括2跟5,成功返回删除后的结果文本，失败返回原文本！
    .参数 欲寻找的全文本, 文本型, , 比如：欲寻找的全文本为 12345789
    .参数 前面文本, 文本型, , 前面为“2”
    .参数 后面文本, 文本型, , 后面为“5”
    .参数 是否保留前后文本, 逻辑型, 可空, 默认不保留
    .局部变量 中间文本, 文本型
    .局部变量 起始位置, 整数型

    .计次循环首 (文本_取出现次数 (欲寻找的全文本, 前面文本, ), )
        中间文本 ＝ 文本_取出中间文本 (欲寻找的全文本, 前面文本, 后面文本, 起始位置, )
        .如果 (是否保留前后文本 ＝ 真)
            欲寻找的全文本 ＝ 子文本替换 (欲寻找的全文本, 前面文本 ＋ 中间文本 ＋ 后面文本, 前面文本 ＋ 后面文本, , 1, 真)
            起始位置 ＝ 寻找文本 (欲寻找的全文本, 前面文本 ＋ 后面文本, 起始位置, 假) ＋ 取文本长度 (前面文本 ＋ 后面文本)
        .否则
            欲寻找的全文本 ＝ 子文本替换 (欲寻找的全文本, 前面文本 ＋ 中间文本 ＋ 后面文本, , , 1, 真)
        .如果结束
        
    .计次循环尾 ()
    返回 (欲寻找的全文本)

.子程序 文本_插入文本到某字前, 文本型, 公开, 插入文本到某字前，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 某字, 文本型
    .参数 被插在某字前的文本, 文本型
    .参数 插入次数, 整数型, 可空, 如果省略，默认进行所有可能的插入

    .如果真 (是否为空 (插入次数))
        返回 (子文本替换 (原文本, 某字, 被插在某字前的文本 ＋ 某字, , , 假))
    .如果真结束
    返回 (子文本替换 (原文本, 某字, 被插在某字前的文本 ＋ 某字, , 插入次数, 假))

.子程序 文本_插入文本到某字后, 文本型, 公开, 插入文本到某字后，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 某字, 文本型
    .参数 被插在某字后的文本, 文本型
    .参数 插入次数, 整数型, 可空, 如果省略，默认进行所有可能的插入

    .如果真 (是否为空 (插入次数))
        返回 (子文本替换 (原文本, 某字, 某字 ＋ 被插在某字后的文本, , , 假))
    .如果真结束
    返回 (子文本替换 (原文本, 某字, 某字 ＋ 被插在某字后的文本, , 插入次数, 假))

.子程序 文本_取出N组不重复数字, , 公开, 取出N组不重复数字,如：在1-100之间取出80个数字，要求不重复。
    .参数 返回取出的数组, 整数型, 数组, 存放取出来的数组
    .参数 欲取多少组, 整数型, , 要取多少组
    .参数 最小值, 整数型, , 要取的最小数值
    .参数 最大值, 整数型, , 要取的最大数值
    .局部变量 局_计次, 整数型
    .局部变量 局_大计次, 整数型
    .局部变量 局_随机数, 整数型

    清除数组 (返回取出的数组)
    .计次循环首 (欲取多少组, 局_大计次)
        局_随机数 ＝ 汇编_取随机数 (最小值, 最大值)
        .如果 (取数组成员数 (返回取出的数组) ＞ 0)
            .循环判断首 ()
                局_计次 ＝ 局_计次 ＋ 1
                .如果真 (局_随机数 ＝ 返回取出的数组 [局_计次])
                    局_随机数 ＝ 汇编_取随机数 (最小值, 最大值)
                    局_计次 ＝ 0
                    到循环尾 ()
                .如果真结束
                .如果真 (局_随机数 ≠ 返回取出的数组 [局_计次] 且 局_计次 ＝ 取数组成员数 (返回取出的数组))
                    加入成员 (返回取出的数组, 局_随机数)
                    局_计次 ＝ 0
                    跳出循环 ()
                .如果真结束
                
            .循环判断尾 (局_计次 ≠ 取数组成员数 (返回取出的数组))
        .否则
            加入成员 (返回取出的数组, 局_随机数)
        .如果结束
        
    .计次循环尾 ()

.子程序 文本_取GB2312简体汉字笔画数, 整数型, 公开
    .参数 汉字, 文本型
    .局部变量 数据, 整数型, 静态, "0", 代码作者：袁晓辉（海洋）
    .局部变量 区码, 字节型
    .局部变量 位码, 字节型
    .局部变量 索引, 整数型

    数据 ＝ { 10, 7, 10, 10, 8, 10, 9, 11, 17, 14, 13, 5, 13, 10, 12, 15, 10, 6, 10, 9, 13, 8, 10, 10, 8, 8, 10, 5, 10, 14, 16, 9, 12, 12, 15, 15, 7, 10, 5, 5, 7, 10, 2, 9, 4, 8, 12, 13, 7, 10, 7, 21, 10, 8, 5, 9, 6, 13, 8, 8, 9, 13, 12, 10, 13, 7, 10, 10, 8, 8, 7, 8, 7, 19, 5, 4, 8, 5, 9, 10, 14, 14, 9, 12, 15, 10, 15, 12, 12, 8, 9, 5, 15, 10, 16, 13, 9, 12, 8, 8, 8, 7, 15, 10, 13, 19, 8, 13, 12, 8, 5, 12, 9, 4, 9, 10, 7, 8, 12, 12, 10, 8, 8, 5, 11, 11, 11, 9, 9, 18, 9, 12, 14, 4, 13, 10, 8, 14, 13, 14, 6, 10, 9, 4, 7, 13, 6, 11, 14, 5, 13, 16, 17, 16, 9, 18, 5, 12, 8, 9, 9, 8, 4, 16, 16, 17, 12, 9, 11, 15, 8, 19, 16, 7, 15, 11, 12, 16, 13, 10, 13, 7, 6, 9, 5, 8, 9, 9, 10, 6, 8, 11, 15, 8, 10, 8, 12, 9, 13, 10, 14, 7, 8, 11, 11, 14, 12, 8, 7, 10, 2, 10, 7, 11, 4, 5, 7, 19, 10, 8, 17, 11, 12, 7, 3, 7, 12, 15, 8, 11, 11, 14, 16, 8, 10, 9, 11, 11, 7, 7, 10, 4, 7, 17, 16, 16, 15, 11, 9, 8, 12, 8, 5, 9, 7, 19, 12, 3, 9, 9, 9, 14, 12, 14, 7, 9, 8, 8, 10, 10, 12, 11, 14, 12, 11, 13, 11, 6, 11, 19, 8, 11, 6, 9, 11, 4, 11, 7, 2, 12, 8, 11, 10, 12, 7, 9, 12, 15, 15, 11, 7, 8, 4, 7, 15, 12, 7, 15, 10, 6, 7, 6, 11, 7, 7, 7, 12, 8, 15, 10, 9, 16, 6, 7, 10, 12, 12, 15, 8, 8, 10, 10, 10, 6, 13, 9, 11, 6, 7, 6, 6, 10, 8, 8, 4, 7, 10, 5, 9, 6, 6, 6, 11, 8, 8, 13, 12, 14, 13, 13, 13, 4, 11, 14, 4, 10, 7, 5, 16, 12, 18, 12, 13, 12, 9, 13, 10, 12, 24, 13, 13, 5, 12, 3, 9, 13, 7, 11, 12, 7, 9, 12, 15, 7, 6, 6, 7, 8, 11, 13, 8, 9, 13, 15, 10, 11, 7, 21, 18, 11, 11, 9, 14, 14, 13, 13, 10, 7, 6, 8, 12, 6, 15, 12, 7, 5, 4, 5, 11, 11, 15, 17, 9, 19, 16, 12, 14, 11, 13, 10, 13, 14, 11, 14, 7, 6, 3, 14, 15, 12, 11, 10, 13, 12, 6, 12, 14, 5, 3, 7, 4, 12, 17, 9, 9, 5, 9, 11, 9, 11, 9, 10, 8, 4, 8, 10, 11, 9, 5, 12, 7, 11, 11, 8, 11, 11, 6, 9, 10, 9, 10, 2, 10, 17, 10, 7, 11, 6, 8, 15, 11, 12, 11, 15, 11, 8, 19, 6, 12, 12, 17, 14, 4, 12, 7, 14, 8, 10, 11, 7, 10, 14, 14, 8, 8, 6, 12, 11, 9, 7, 10, 12, 16, 11, 13, 13, 9, 8, 16, 9, 5, 7, 7, 8, 11, 12, 11, 13, 13, 5, 16, 10, 2, 11, 6, 8, 10, 12, 10, 14, 15, 8, 11, 13, 2, 7, 5, 7, 8, 12, 13, 8, 4, 6, 5, 5, 12, 15, 6, 9, 8, 9, 7, 9, 11, 7, 4, 9, 7, 10, 12, 10, 13, 9, 12, 9, 10, 11, 13, 12, 7, 14, 7, 9, 12, 7, 14, 12, 14, 9, 11, 12, 11, 7, 4, 5, 15, 7, 19, 12, 10, 7, 9, 9, 12, 11, 9, 6, 6, 9, 13, 6, 13, 11, 8, 12, 11, 13, 10, 12, 9, 15, 6, 10, 10, 4, 7, 12, 11, 10, 10, 6, 2, 6, 5, 9, 9, 2, 9, 5, 9, 12, 6, 4, 9, 8, 9, 18, 6, 12, 18, 15, 8, 8, 17, 3, 10, 4, 7, 8, 8, 5, 7, 7, 7, 7, 4, 8, 8, 6, 7, 6, 6, 7, 8, 11, 8, 11, 3, 8, 10, 10, 7, 8, 8, 8, 9, 7, 11, 7, 8, 4, 7, 7, 12, 7, 10, 8, 6, 8, 12, 12, 4, 9, 8, 13, 10, 12, 4, 9, 11, 10, 5, 13, 6, 8, 4, 7, 7, 4, 15, 8, 14, 7, 8, 13, 12, 9, 11, 6, 9, 8, 10, 11, 13, 11, 5, 7, 7, 11, 10, 10, 8, 11, 12, 8, 14, 9, 11, 18, 12, 9, 12, 5, 8, 4, 13, 6, 12, 4, 7, 6, 13, 8, 15, 14, 8, 7, 13, 9, 11, 12, 3, 5, 7, 9, 9, 7, 10, 13, 8, 11, 21, 4, 6, 9, 9, 7, 7, 7, 12, 7, 16, 10, 10, 14, 10, 16, 13, 15, 15, 7, 10, 14, 12, 4, 11, 10, 8, 12, 9, 12, 10, 12, 9, 12, 11, 3, 6, 9, 10, 13, 10, 7, 8, 19, 10, 10, 11, 3, 7, 5, 10, 11, 8, 10, 4, 9, 3, 6, 7, 9, 7, 6, 9, 4, 7, 8, 8, 9, 8, 8, 11, 12, 11, 8, 14, 7, 8, 8, 8, 13, 5, 11, 9, 7, 8, 9, 10, 8, 12, 8, 5, 9, 14, 9, 13, 8, 8, 8, 12, 6, 8, 9, 6, 14, 11, 23, 12, 20, 8, 6, 3, 10, 13, 8, 6, 11, 5, 7, 9, 6, 9, 8, 9, 10, 8, 13, 9, 8, 12, 13, 12, 12, 10, 8, 8, 14, 6, 9, 15, 9, 10, 10, 6, 10, 9, 12, 14, 7, 12, 7, 11, 12, 8, 12, 7, 16, 16, 10, 7, 16, 10, 11, 6, 5, 5, 8, 10, 17, 17, 14, 11, 9, 6, 10, 5, 10, 8, 12, 10, 11, 10, 5, 8, 7, 6, 11, 13, 9, 8, 11, 14, 14, 15, 9, 15, 12, 11, 9, 9, 9, 10, 7, 15, 16, 9, 8, 9, 10, 9, 11, 9, 7, 5, 6, 12, 9, 12, 7, 9, 10, 6, 8, 5, 8, 13, 10, 12, 9, 15, 8, 15, 12, 8, 8, 11, 7, 4, 7, 4, 7, 9, 6, 12, 12, 8, 6, 4, 8, 13, 9, 7, 11, 7, 6, 8, 10, 7, 12, 10, 11, 10, 12, 13, 11, 10, 9, 4, 9, 12, 11, 16, 15, 17, 9, 11, 12, 13, 10, 13, 9, 11, 6, 9, 12, 17, 9, 12, 6, 13, 10, 15, 5, 12, 11, 10, 11, 6, 10, 5, 6, 9, 9, 9, 8, 11, 13, 9, 11, 17, 9, 6, 4, 10, 8, 12, 16, 8, 11, 5, 6, 11, 6, 13, 15, 10, 14, 6, 5, 9, 16, 4, 7, 10, 11, 12, 6, 7, 12, 13, 20, 12, 3, 9, 10, 6, 7, 13, 6, 9, 2, 10, 3, 13, 7, 16, 8, 6, 11, 8, 11, 9, 11, 11, 4, 5, 9, 7, 7, 7, 10, 6, 14, 9, 6, 8, 10, 5, 9, 12, 10, 5, 10, 11, 15, 6, 9, 8, 13, 7, 10, 7, 6, 11, 7, 13, 10, 8, 8, 6, 12, 9, 11, 9, 14, 12, 8, 10, 13, 9, 11, 11, 9, 14, 13, 12, 9, 4, 13, 15, 6, 10, 10, 9, 8, 11, 12, 10, 8, 15, 9, 9, 10, 6, 19, 12, 10, 9, 6, 6, 13, 8, 15, 12, 17, 12, 10, 6, 8, 9, 9, 9, 20, 12, 11, 11, 8, 11, 9, 7, 9, 16, 9, 13, 11, 14, 10, 10, 5, 12, 12, 11, 9, 11, 12, 6, 14, 7, 5, 10, 8, 11, 13, 14, 9, 9, 13, 8, 7, 17, 7, 9, 10, 4, 9, 9, 8, 3, 12, 4, 8, 4, 9, 18, 10, 13, 4, 13, 7, 13, 10, 13, 7, 10, 10, 6, 7, 9, 14, 8, 13, 12, 16, 8, 11, 14, 13, 8, 4, 19, 12, 11, 14, 14, 12, 16, 8, 10, 13, 11, 10, 8, 9, 12, 12, 7, 5, 7, 9, 3, 7, 2, 10, 11, 11, 5, 6, 13, 8, 12, 8, 17, 8, 8, 10, 8, 8, 11, 7, 8, 9, 9, 8, 14, 7, 11, 4, 8, 11, 15, 13, 10, 5, 11, 8, 10, 10, 12, 10, 10, 11, 8, 10, 15, 23, 7, 11, 10, 17, 9, 6, 6, 9, 7, 11, 9, 6, 7, 10, 9, 12, 10, 9, 10, 12, 8, 5, 9, 4, 12, 13, 8, 12, 5, 12, 11, 7, 9, 9, 11, 14, 17, 6, 7, 4, 8, 6, 9, 10, 15, 8, 8, 9, 12, 15, 14, 9, 7, 9, 5, 12, 7, 8, 9, 10, 8, 11, 9, 10, 7, 7, 8, 10, 4, 11, 7, 3, 6, 11, 9, 10, 13, 8, 14, 7, 12, 6, 9, 9, 13, 10, 7, 13, 8, 7, 10, 12, 6, 12, 7, 10, 8, 11, 7, 7, 3, 11, 8, 13, 12, 9, 13, 11, 12, 12, 12, 8, 8, 10, 7, 9, 6, 13, 12, 8, 8, 12, 14, 12, 14, 11, 10, 7, 13, 13, 11, 9, 8, 16, 12, 5, 15, 14, 12, 9, 16, 12, 9, 13, 11, 12, 10, 11, 8, 10, 10, 10, 7, 7, 6, 8, 9, 13, 10, 10, 11, 5, 13, 18, 16, 15, 11, 17, 9, 16, 6, 9, 8, 12, 13, 7, 9, 11, 11, 15, 16, 10, 10, 13, 11, 7, 7, 15, 5, 10, 9, 6, 10, 7, 5, 7, 10, 4, 7, 12, 8, 9, 12, 5, 11, 7, 8, 2, 14, 10, 9, 12, 10, 7, 18, 13, 8, 10, 8, 11, 11, 12, 10, 9, 8, 13, 10, 11, 13, 7, 7, 11, 12, 12, 9, 10, 15, 11, 14, 7, 16, 14, 5, 15, 2, 14, 17, 14, 10, 6, 12, 10, 6, 11, 12, 8, 17, 16, 9, 7, 20, 11, 15, 10, 7, 8, 9, 11, 13, 13, 10, 7, 11, 10, 7, 10, 8, 11, 5, 5, 13, 11, 14, 12, 13, 10, 6, 15, 10, 9, 4, 5, 11, 8, 11, 16, 11, 8, 8, 7, 13, 9, 12, 15, 14, 8, 7, 5, 11, 7, 8, 11, 7, 8, 12, 19, 13, 21, 13, 10, 11, 16, 12, 8, 7, 15, 7, 6, 11, 8, 10, 15, 12, 12, 10, 12, 9, 11, 13, 11, 9, 10, 9, 13, 7, 7, 11, 11, 7, 8, 6, 4, 7, 7, 6, 11, 17, 8, 11, 13, 14, 14, 13, 12, 9, 9, 9, 6, 11, 7, 8, 9, 3, 9, 14, 6, 10, 6, 7, 8, 6, 9, 15, 14, 12, 13, 14, 11, 14, 14, 13, 6, 9, 8, 8, 6, 10, 11, 8, 13, 4, 5, 10, 5, 8, 9, 12, 14, 9, 3, 8, 8, 11, 14, 15, 13, 7, 9, 12, 14, 7, 9, 9, 12, 8, 12, 3, 7, 5, 11, 13, 17, 13, 13, 11, 11, 8, 11, 15, 19, 17, 9, 11, 8, 6, 10, 8, 8, 14, 11, 12, 12, 10, 11, 11, 7, 9, 10, 12, 9, 8, 11, 13, 17, 9, 12, 8, 7, 14, 5, 5, 8, 5, 11, 10, 9, 8, 16, 8, 11, 6, 8, 13, 13, 14, 19, 14, 14, 16, 15, 20, 8, 5, 10, 15, 16, 8, 13, 13, 8, 11, 6, 9, 8, 7, 7, 8, 5, 13, 14, 13, 12, 14, 4, 5, 13, 8, 16, 10, 9, 7, 9, 6, 9, 7, 6, 2, 5, 9, 8, 9, 7, 10, 22, 9, 10, 9, 8, 11, 8, 10, 4, 14, 10, 8, 16, 10, 8, 5, 7, 7, 10, 13, 9, 13, 14, 8, 6, 15, 15, 11, 8, 10, 14, 5, 7, 10, 10, 19, 11, 15, 15, 10, 11, 9, 8, 16, 5, 8, 8, 4, 7, 9, 7, 10, 9, 6, 7, 5, 7, 9, 3, 13, 9, 8, 9, 17, 20, 10, 10, 8, 9, 8, 18, 7, 11, 7, 11, 9, 8, 8, 8, 12, 8, 11, 12, 11, 12, 9, 19, 15, 11, 15, 9, 10, 7, 9, 6, 8, 10, 16, 9, 7, 8, 7, 9, 10, 12, 8, 8, 9, 11, 14, 12, 10, 10, 8, 7, 12, 9, 10, 8, 11, 15, 12, 13, 12, 13, 16, 16, 8, 13, 11, 13, 8, 9, 21, 7, 8, 15, 12, 9, 11, 12, 10, 5, 4, 12, 15, 7, 20, 15, 11, 4, 12, 15, 14, 16, 11, 14, 16, 9, 13, 8, 9, 13, 6, 8, 8, 11, 5, 8, 10, 7, 9, 8, 8, 11, 11, 10, 14, 8, 11, 10, 5, 12, 4, 10, 12, 11, 13, 10, 6, 10, 12, 10, 14, 19, 18, 12, 12, 10, 11, 8, 2, 10, 14, 9, 7, 8, 12, 8, 8, 11, 11, 10, 6, 14, 8, 6, 11, 10, 6, 3, 6, 7, 9, 9, 16, 4, 6, 7, 7, 8, 5, 11, 9, 9, 9, 6, 8, 10, 3, 6, 13, 5, 12, 11, 16, 10, 10, 9, 15, 13, 8, 15, 11, 12, 4, 14, 8, 7, 12, 7, 14, 14, 12, 7, 16, 14, 14, 10, 10, 17, 6, 8, 5, 16, 15, 12, 10, 9, 10, 4, 8, 5, 8, 9, 9, 9, 9, 10, 12, 13, 7, 15, 12, 13, 7, 8, 9, 9, 10, 10, 11, 16, 12, 12, 11, 8, 10, 6, 12, 7, 9, 5, 7, 11, 7, 5, 9, 8, 12, 4, 11, 6, 11, 8, 7, 11, 8, 11, 17, 15, 5, 11, 23, 6, 16, 10, 6, 11, 10, 4, 8, 4, 10, 8, 16, 7, 13, 14, 12, 11, 12, 13, 12, 16, 5, 9, 22, 20, 20, 20, 5, 9, 7, 9, 12, 10, 4, 4, 2, 7, 7, 6, 4, 3, 7, 6, 5, 4, 4, 6, 9, 13, 9, 16, 14, 13, 10, 9, 4, 12, 9, 6, 9, 20, 16, 17, 6, 10, 8, 6, 2, 15, 8, 6, 15, 13, 12, 7, 10, 8, 10, 15, 9, 11, 13, 17, 13, 14, 3, 8, 6, 12, 10, 13, 8, 12, 12, 6, 12, 13, 6, 10, 12, 14, 10, 9, 6, 8, 7, 7, 13, 11, 13, 12, 10, 9, 8, 7, 3, 7, 14, 8, 5, 8, 16, 17, 16, 12, 6, 10, 15, 14, 6, 11, 12, 10, 3, 8, 14, 11, 10, 12, 10, 6, 3, 14, 4, 10, 7, 8, 11, 11, 11, 6, 8, 11, 13, 10, 13, 10, 7, 6, 10, 5, 8, 7, 7, 11, 10, 8, 9, 7, 8, 11, 9, 8, 13, 11, 7, 5, 12, 9, 4, 11, 9, 11, 12, 9, 5, 6, 5, 9, 9, 12, 8, 3, 8, 2, 5, 9, 7, 4, 9, 9, 8, 7, 5, 5, 8, 9, 8, 8, 6, 5, 3, 5, 9, 8, 9, 14, 10, 8, 9, 13, 16, 9, 5, 8, 12, 8, 4, 5, 9, 9, 8, 8, 6, 4, 9, 6, 7, 11, 11, 8, 14, 11, 15, 8, 11, 10, 7, 13, 8, 12, 11, 12, 4, 12, 11, 15, 16, 12, 17, 13, 13, 12, 13, 12, 5, 8, 9, 7, 6, 9, 14, 11, 13, 14, 10, 8, 9, 14, 10, 5, 5, 10, 9, 17, 4, 11, 10, 4, 13, 12, 7, 17, 9, 12, 9, 11, 10, 9, 12, 15, 15, 9, 7, 5, 5, 6, 13, 6, 13, 5, 7, 6, 8, 3, 8, 10, 8, 10, 9, 7, 6, 9, 12, 15, 16, 14, 7, 12, 9, 10, 10, 12, 14, 13, 13, 11, 7, 8, 14, 13, 14, 9, 11, 11, 10, 21, 13, 6, 17, 12, 14, 10, 6, 10, 10, 13, 11, 10, 14, 11, 10, 12, 8, 13, 5, 5, 6, 12, 16, 9, 17, 15, 9, 8, 8, 5, 10, 11, 4, 8, 7, 7, 13, 8, 15, 13, 7, 17, 13, 15, 14, 10, 8, 12, 10, 14, 11, 5, 9, 6, 13, 13, 11, 12, 15, 10, 16, 10, 15, 11, 15, 10, 11, 10, 13, 10, 11, 10, 9, 11, 10, 5, 10, 10, 18, 13, 10, 13, 11, 10, 15, 12, 12, 15, 16, 12, 7, 12, 17, 11, 10, 9, 8, 4, 11, 13, 5, 11, 9, 14, 12, 9, 7, 8, 11, 13, 9, 10, 8, 4, 7, 9, 5, 6, 11, 9, 9, 9, 12, 10, 10, 13, 17, 6, 11, 7, 12, 11, 10, 12, 9, 12, 11, 7, 5, 10, 5, 7, 9, 8, 10, 10, 10, 11, 3, 6, 8, 12, 6, 11, 13, 13, 13, 14, 9, 7, 4, 17, 8, 6, 11, 10, 7, 6, 8, 12, 7, 8, 12, 9, 9, 12, 9, 9, 4, 10, 9, 5, 15, 9, 12, 8, 10, 3, 11, 7, 13, 10, 11, 12, 11, 8, 11, 3, 12, 7, 4, 3, 8, 6, 8, 8, 11, 7, 6, 9, 20, 13, 6, 4, 7, 10, 7, 11, 11, 4, 14, 11, 7, 11, 8, 6, 6, 7, 7, 5, 14, 8, 9, 9, 12, 17, 7, 12, 11, 11, 15, 3, 14, 12, 10, 4, 9, 7, 7, 14, 10, 6, 13, 10, 8, 9, 13, 10, 12, 7, 14, 8, 12, 7, 7, 7, 9, 4, 6, 9, 9, 4, 7, 11, 7, 7, 4, 8, 4, 10, 4, 14, 6, 9, 7, 5, 13, 11, 8, 4, 5, 10, 9, 8, 14, 8, 6, 11, 8, 12, 15, 6, 13, 10, 12, 10, 7, 11, 15, 3, 11, 14, 11, 13, 6, 12, 17, 11, 10, 3, 13, 12, 11, 9, 7, 12, 6, 8, 15, 9, 7, 17, 14, 13, 9, 8, 9, 3, 12, 10, 6, 11, 13, 6, 5, 14, 6, 9, 8, 11, 11, 7, 9, 8, 13, 9, 9, 8, 13, 7, 13, 11, 12, 9, 10, 8, 8, 9, 11, 22, 9, 15, 17, 12, 3, 12, 10, 8, 13, 9, 8, 9, 9, 15, 13, 6, 11, 11, 12, 15, 9, 10, 18, 12, 10, 10, 11, 10, 3, 7, 10, 7, 11, 10, 10, 13, 8, 13, 15, 15, 6, 9, 13, 6, 11, 8, 11, 5, 11, 9, 19, 16, 8, 8, 12, 10, 16, 7, 12, 8, 7, 13, 7, 4, 9, 11, 9, 13, 12, 12, 6, 6, 9, 7, 6, 6, 16, 8, 7, 8, 8, 5, 4, 10, 6, 7, 12, 14, 6, 9, 10, 6, 13, 12, 7, 10, 10, 14, 6, 14, 11, 14, 9, 10, 6, 13, 11, 9, 6, 7, 10, 9, 12, 12, 11, 11, 7, 12, 9, 11, 11, 5, 9, 19, 10, 9, 13, 16, 8, 5, 11, 6, 9, 14, 12, 6, 8, 6, 6, 6, 10, 6, 5, 5, 9, 6, 6, 8, 9, 10, 7, 3, 7, 4, 10, 11, 13, 11, 12, 9, 6, 6, 11, 9, 11, 10, 11, 10, 7, 9, 12, 8, 7, 7, 15, 11, 8, 8, 8, 11, 11, 9, 14, 10, 12, 16, 6, 9, 12, 10, 9, 12, 10, 11, 10, 9, 5, 10, 10, 7, 6, 8, 8, 6, 9, 6, 10, 6, 11, 9, 10, 14, 16, 13, 7, 14, 13, 6, 13, 11, 12, 9, 9, 10, 9, 9, 20, 12, 15, 8, 6, 11, 7, 3, 6, 11, 5, 5, 6, 12, 8, 11, 1, 12, 7, 12, 11, 8, 6, 6, 13, 6, 12, 11, 5, 10, 14, 7, 8, 9, 18, 12, 9, 10, 3, 1, 7, 4, 4, 7, 8, 7, 6, 3, 7, 17, 11, 13, 9, 6, 13, 13, 15, 4, 3, 10, 13, 8, 5, 10, 7, 6, 17, 11, 8, 9, 9, 6, 10, 9, 6, 8, 7, 11, 11, 11, 7, 4, 4, 11, 5, 8, 15, 11, 18, 7, 14, 10, 11, 11, 9, 14, 7, 17, 9, 15, 13, 12, 9, 9, 8, 7, 17, 10, 11, 13, 14, 13, 8, 8, 10, 5, 11, 9, 5, 9, 6, 11, 7, 4, 5, 7, 10, 7, 8, 12, 7, 6, 4, 5, 7, 12, 9, 2, 5, 6, 11, 3, 8, 13, 13, 13, 14, 7, 9, 12, 8, 12, 12, 11, 11, 4, 10, 8, 3, 6, 9, 6, 9, 6, 5, 11, 6, 8, 6, 12, 12, 10, 12, 13, 11, 9, 8, 13, 10, 12, 12, 10, 15, 5, 10, 11, 10, 4, 9, 10, 10, 12, 14, 7, 7, 10, 13, 13, 12, 7, 8, 14, 9, 9, 4, 6, 12, 11, 9, 8, 12, 4, 10, 10, 10, 4, 9, 4, 9, 4, 7, 15, 11, 10, 13, 5, 5, 10, 6, 10, 9, 7, 10, 10, 6, 6, 9, 19, 12, 16, 10, 10, 12, 14, 17, 12, 19, 8, 6, 16, 9, 20, 16, 10, 7, 7, 17, 8, 8, 6, 8, 10, 9, 15, 15, 12, 16, 4, 12, 12, 5, 5, 11, 8, 9, 9, 14, 8, 5, 9, 7, 14, 10, 6, 10, 10, 14, 18, 9, 13, 11, 8, 10, 8, 14, 11, 10, 22, 9, 5, 9, 10, 12, 11, 15, 11, 14, 14, 7, 12, 10, 7, 3, 7, 8, 5, 8, 16, 13, 8, 9, 7, 8, 9, 13, 13, 6, 14, 5, 14, 7, 10, 12, 16, 8, 13, 14, 7, 10, 9, 13, 10, 13, 10, 16, 6, 7, 8, 8, 10, 7, 15, 10, 15, 6, 13, 9, 11, 8, 9, 6, 8, 16, 9, 5, 9, 9, 10, 8, 7, 6, 8, 4, 7, 14, 8, 8, 10, 5, 3, 8, 11, 8, 12, 12, 6, 10, 8, 7, 9, 4, 11, 5, 6, 7, 7, 10, 11, 6, 10, 13, 8, 9, 8, 12, 10, 13, 8, 8, 11, 12, 8, 11, 4, 9, 8, 9, 10, 8, 9, 8, 9, 6, 6, 6, 8, 6, 9, 7, 12, 9, 7, 8, 8, 10, 8, 9, 17, 10, 10, 12, 6, 11, 10, 8, 10, 6, 10, 12, 8, 17, 15, 5, 11, 9, 7, 11, 8, 12, 12, 7, 8, 9, 8, 7, 4, 9, 4, 9, 8, 15, 14, 15, 10, 6, 12, 6, 15, 6, 7, 12, 13, 9, 14, 7, 11, 10, 10, 10, 8, 8, 10, 12, 8, 10, 11, 11, 7, 9, 9, 9, 10, 9, 12, 11, 7, 12, 5, 9, 13, 3, 6, 11, 6, 18, 12, 15, 8, 11, 9, 7, 7, 7, 9, 12, 10, 7, 8, 11, 9, 7, 7, 8, 10, 20, 16, 15, 12, 13, 12, 15, 9, 5, 7, 9, 11, 7, 7, 10, 0, 0, 0, 0, 0, 3, 3, 3, 4, 4, 4, 5, 6, 6, 10, 10, 16, 1, 8, 1, 2, 3, 4, 4, 5, 5, 6, 9, 11, 14, 14, 19, 1, 8, 14, 2, 6, 4, 7, 7, 11, 14, 4, 6, 10, 11, 12, 14, 15, 16, 2, 5, 8, 11, 11, 15, 8, 7, 2, 4, 6, 7, 8, 8, 8, 9, 10, 10, 10, 13, 13, 14, 14, 15, 16, 2, 8, 2, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 13, 14, 14, 14, 14, 14, 14, 15, 15, 5, 6, 7, 7, 9, 17, 6, 8, 4, 12, 16, 17, 18, 21, 2, 9, 9, 11, 6, 6, 7, 2, 8, 10, 10, 11, 12, 12, 12, 13, 16, 19, 19, 2, 6, 8, 8, 10, 2, 10, 10, 2, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 19, 2, 8, 2, 5, 5, 6, 6, 7, 7, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 11, 16, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 13, 13, 13, 14, 14, 16, 19, 17, 5, 7, 5, 7, 7, 8, 10, 10, 11, 15, 9, 17, 20, 2, 2, 6, 10, 2, 5, 10, 12, 7, 9, 9, 14, 16, 16, 17, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14, 15, 20, 21, 22, 3, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 19, 19, 19, 20, 20, 22, 3, 9, 6, 7, 9, 9, 10, 10, 11, 3, 5, 5, 12, 3, 6, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 17, 19, 23, 25, 3, 7, 8, 12, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 19, 25, 3, 6, 6, 7, 7, 8, 9, 10, 11, 11, 16, 7, 8, 8, 8, 10, 11, 11, 11, 12, 14, 14, 15, 15, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 17, 17, 19, 3, 7, 8, 9, 9, 9, 10, 11, 11, 12, 13, 15, 16, 24, 3, 3, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 14, 14, 15, 15, 16, 17, 20, 6, 14, 12, 14, 3, 3, 6, 7, 7, 7, 7, 7, 8, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15, 15, 25, 5, 7, 7, 8, 9, 9, 11, 11, 11, 11, 12, 13, 14, 15, 16, 16, 17, 3, 5, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 13, 13, 14, 15, 15, 15, 16, 16, 18, 8, 17, 4, 6, 7, 7, 7, 7, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 3, 4, 8, 3, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 19, 19, 19, 20, 20, 21, 24, 3, 5, 8, 8, 9, 10, 12, 13, 14, 14, 15, 16, 16, 17, 17, 3, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 15, 15, 16, 16, 17, 17, 18, 3, 11, 9, 12, 5, 9, 10, 10, 12, 14, 15, 21, 8, 8, 9, 11, 12, 22, 3, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 16, 16, 17, 17, 20, 5, 9, 7, 8, 12, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 19, 20, 3, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 19, 3, 15, 3, 8, 10, 6, 6, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 16, 17, 17, 17, 18, 20, 20, 13, 13, 14, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 13, 14, 8, 9, 9, 9, 11, 11, 11, 12, 12, 14, 16, 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 12, 12, 12, 12, 13, 15, 16, 10, 5, 8, 11, 12, 12, 13, 13, 13, 14, 14, 8, 9, 12, 16, 16, 17, 4, 6, 6, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 12, 13, 13, 14, 14, 16, 18, 18, 20, 21, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 14, 9, 10, 11, 12, 13, 14, 15, 15, 9, 13, 6, 8, 9, 11, 11, 12, 12, 12, 13, 14, 10, 11, 12, 14, 17, 10, 10, 12, 12, 12, 13, 15, 16, 16, 22, 5, 6, 7, 7, 9, 10, 10, 11, 13, 4, 11, 13, 12, 13, 15, 9, 15, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 17, 17, 17, 17, 17, 16, 7, 11, 12, 13, 13, 16, 9, 9, 12, 13, 16, 16, 4, 13, 13, 17, 12, 15, 16, 8, 10, 10, 10, 11, 11, 13, 14, 7, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 15, 15, 15, 16, 16, 16, 18, 21, 30, 4, 11, 13, 16, 8, 8, 9, 11, 12, 4, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 12, 12, 13, 14, 16, 21, 7, 7, 9, 10, 10, 10, 10, 10, 10, 11, 13, 13, 14, 16, 16, 17, 17, 24, 4, 6, 8, 9, 12, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 19, 18, 21, 11, 12, 17, 19, 8, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 18, 7, 8, 9, 9, 9, 10, 12, 13, 17, 9, 10, 10, 12, 13, 14, 14, 16, 17, 17, 10, 16, 23, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 20, 14, 9, 12, 13, 9, 9, 10, 10, 11, 12, 12, 12, 13, 13, 15, 15, 16, 17, 18, 22, 9, 11, 12, 13, 17, 10, 11, 7, 7, 8, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 17, 18, 18, 22, 5, 7, 7, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 18, 18, 18, 18, 21, 23, 11, 12, 8, 8, 9, 9, 10, 11, 13, 13, 14, 14, 14, 15, 5, 8, 9, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 17, 19, 24, 5, 9, 11, 12, 9, 6, 9, 10, 12, 12, 13, 14, 15, 15, 16, 16, 22, 12, 8, 11, 11, 11, 12, 15, 16, 12, 9, 10, 10, 12, 12, 12, 12, 13, 15, 15, 16, 16, 16, 18, 20, 21, 6, 10, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 21, 24, 26, 6, 14, 17, 17, 10, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 19, 8, 9, 11, 12, 10, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13, 14, 15, 17, 18, 19, 10, 10, 11, 13, 13, 19, 11, 11, 13, 15, 15, 16, 9, 10, 10, 11, 11, 12, 12, 13, 14, 14, 14, 15, 15, 15, 15, 15, 16, 18, 6, 15, 9, 11, 12, 14, 14, 15, 15, 16, 17, 6, 12, 14, 14, 17, 25, 11, 19, 9, 12, 13, 13, 23, 11, 15, 10, 11, 9, 10, 10, 10, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 19, 20, 20, 21, 7, 16, 10, 13, 14, 18, 18, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 19, 19, 19, 19, 19, 20, 21, 22, 22, 23, 24, 7, 12, 13, 13, 17, 17, 11, 11, 12, 12, 13, 13, 14, 15, 13, 18, 12, 11, 12, 12, 14, 14, 16, 16, 16, 19, 19, 20, 22, 10, 13, 13, 13, 14, 14, 15, 15, 17, 8, 12, 20, 8, 10, 10, 13, 14, 18, 18, 14, 14, 15, 16, 17, 18, 18, 21, 24, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 14, 14, 15, 15, 16, 18, 18, 18, 19, 19, 13, 13, 14, 14, 14, 15, 15, 17, 17, 18, 18, 19, 19, 22, 14, 14, 15, 16, 16, 17, 19, 12, 15, 18, 22, 22, 10, 13, 14, 15, 15, 16, 16, 16, 18, 19, 20, 23, 25, 14, 15, 17, 13, 16, 16, 17, 19, 19, 21, 23, 17, 17, 17, 18, 18, 19, 20, 20, 20, 20, 21, 17, 18, 20, 23, 23, 16, 17, 23 }
    ' unsigned offset;    if ( c1 < 0xB0 || c1 > 0xF7        || c2 < 0xA1 || c2 > 0xFE )    {        // not a valid gb2312 Chinese character        return -1;    }    offset = ((unsigned)c1-0xB0) * (0xFE-0xA0) + ((unsigned)c2-0xA1);    return gb2312_stroke_count[ offset ];
    区码 ＝ 取代码 (取文本左边 (汉字, 1), )
    位码 ＝ 取代码 (取文本中间 (汉字, 2, 1), )
    .如果真 (区码 ＜ 176 或 区码 ＞ 247 或 位码 ＜ 161 或 位码 ＞ 254)
        返回 (-1)
    .如果真结束
    索引 ＝ (区码 － 176) × (254 － 160) ＋ (位码 － 161)
    返回 (数据 [索引 ＋ 1])

.子程序 文本_取中间_批量, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
    .参数 源文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面标识文本, 文本型, , 3的前面为“2”
    .参数 后面标识文本, 文本型, , 3的后面为“4”
    .参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
    .参数 是否不区分大小写, 逻辑型, 可空, 是否区分大小写
    .参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要;如取出的文本大于50的不要;留空为不限制(下面参数中的加入的后缀不算在其中，标志文本为真那么标志算在其中)
    .参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
    .参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
    .参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出? 默认为假，不取出！
    .参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出? 默认为假，不取出！
    .参数 起始位置, 整数型, 可空
    .局部变量 数组数量, 整数型
    .局部变量 已经找到的, 整数型
    .局部变量 StartPos, 整数型
    .局部变量 EndPos, 整数型
    .局部变量 Search, 文本型
    .局部变量 中间长度, 整数型

    清除数组 (存放取出文本的数组)
    StartPos ＝ 起始位置
    .循环判断首 ()
        StartPos ＝ 寻找文本 (源文本, 前面标识文本, StartPos, 是否不区分大小写)
        .如果 (StartPos ≠ -1)
            StartPos ＝ StartPos ＋ 取文本长度 (前面标识文本)
            EndPos ＝ 寻找文本 (源文本, 后面标识文本, StartPos, 是否不区分大小写)
            .如果 (EndPos ≠ -1)
                中间长度 ＝ EndPos － StartPos
                Search ＝ 取文本中间 (源文本, StartPos, 中间长度)
                Search ＝ 为取出的文本加上前缀 ＋ Search ＋ 为取出的文本加上后缀
                
                .如果真 (连前面标识文本一起取出 ＝ 真)
                    Search ＝ 前面标识文本 ＋ Search
                .如果真结束
                .如果真 (连后面标识文本一起取出 ＝ 真)
                    Search ＝ Search ＋ 后面标识文本
                .如果真结束
                
                .如果 (文本长度大于此数的不要 ＝ 0)
                    加入成员 (存放取出文本的数组, Search)
                .否则
                    .如果真 (取文本长度 (Search) ＜ 文本长度大于此数的不要)
                        加入成员 (存放取出文本的数组, Search)
                    .如果真结束
                    
                .如果结束
                处理事件 ()
            .否则
                跳出循环 ()
            .如果结束
            处理事件 ()
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .循环判断尾 (StartPos ≠ -1)
    
    返回 (取数组成员数 (存放取出文本的数组))

.子程序 文本_取中间_批量_正则方式, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
    .参数 源文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面标识文本, 文本型, , 3的前面为“2”
    .参数 后面标识文本, 文本型, , 3的后面为“4”
    .参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
    .参数 是否区分大小写, 逻辑型, 可空, 是否区分大小写
    .参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要，如取出的文本大于50的不要。留空为不限制
    .参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
    .参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
    .参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出?  默认为假，不取出！
    .参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出?  默认为假，不取出！
    .局部变量 局_计次, 整数型
    .局部变量 局_文本, 文本型
    .局部变量 正则, 正则表达式类

    清除数组 (存放取出文本的数组)
    正则.创建 (正则元字符转义 (前面标识文本) ＋ “([\s\S]*?)” ＋ 正则元字符转义 (后面标识文本), 源文本)
    .判断开始 (文本长度大于此数的不要 ≠ 0)
        .计次循环首 (正则.取匹配数量 (), 局_计次)
            局_文本 ＝ 正则.取子匹配文本 (局_计次, 1)
            .如果真 (取文本长度 (局_文本) ≤ 文本长度大于此数的不要)
                局_文本 ＝ 为取出的文本加上前缀 ＋ 局_文本 ＋ 为取出的文本加上后缀
                .如果真 (连前面标识文本一起取出)
                    局_文本 ＝ 前面标识文本 ＋ 局_文本
                .如果真结束
                .如果真 (连后面标识文本一起取出)
                    局_文本 ＝ 局_文本 ＋ 后面标识文本
                .如果真结束
                加入成员 (存放取出文本的数组, 局_文本)
            .如果真结束
            
        .计次循环尾 ()
    .默认
        ' 取匹配到的全部数据，不筛选
        .计次循环首 (正则.取匹配数量 (), 局_计次)
            局_文本 ＝ 正则.取子匹配文本 (局_计次, 1)
            局_文本 ＝ 为取出的文本加上前缀 ＋ 局_文本 ＋ 为取出的文本加上后缀
            .如果真 (连前面标识文本一起取出)
                局_文本 ＝ 前面标识文本 ＋ 局_文本
            .如果真结束
            .如果真 (连后面标识文本一起取出)
                局_文本 ＝ 局_文本 ＋ 后面标识文本
            .如果真结束
            加入成员 (存放取出文本的数组, 局_文本)
        .计次循环尾 ()
    .判断结束
    返回 (取数组成员数 (存放取出文本的数组))

.子程序 正则元字符转义, 文本型
    .参数 要处理的文本, 文本型
    .局部变量 局_文本, 文本型

    局_文本 ＝ 文本_替换 (要处理的文本, , , , “?”, “\?”, “*”, “\*”, “+”, “\+”, “[”, “\[”, “]”, “\]”)
    局_文本 ＝ 文本_替换 (局_文本, , , , “(”, “\(”, “)”, “\)”, “{”, “\{”, “}”, “\}”, “#引号”, #引号)
    局_文本 ＝ 子文本替换 (局_文本, #换行符, “\n”, , , 真)
    返回 (局_文本)

.子程序 文本区分_只取汉字, 文本型, 公开, 在一大串网页源码中 只取出汉字
    .参数 源文本, 文本型, , 要取出汉字的源文本
    .参数 是否正则, 逻辑型, 可空, 可空，默认为假 不使用正则方式
    .参数 是否去除空格和空行, 逻辑型, 可空, 可为空，默认为假。
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型
    .局部变量 局_源文本, 文本型

    .如果 (是否正则)
        正则.创建 (“[^\x20-\x7f]”, 源文本)
        .计次循环首 (正则.取匹配数量 (), 局_计次)
            局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
        .计次循环尾 ()
        .如果真 (是否去除空格和空行)
            正则.创建 (“\s”, 局_临时文本)
            局_临时文本 ＝ 正则.替换 (“”)
        .如果真结束
        返回 (局_临时文本)
    .否则
        局_源文本 ＝ 源文本
        .如果真 (是否去除空格和空行)
            局_源文本 ＝ 文本_替换 (源文本, , , , #换行符, “”, “ ”, “”)
        .如果真结束
        返回 (_只取汉字 (源文本))
    .如果结束
    ' 中文编码范围，中文汉字的正则也许用的着。
    ' 双字节字符编码范围：
    ' 一、 GBK (GB2312/GB18030)
    ' \x00-\xff          →GBK双字节编码范围
    ' \x20-\x7f         →ASCII
    ' \xa1-\xff 中文 →gb2312 取出所有中文
    ' \x80-\xff 中文 →gbk  取出所有中文
    
    ' 二、 UTF-8 (Unicode)
    
    ' \u4e00-\u9fa5     →(中文) 取出所有中文
    ' \x3130-\x318F    →(韩文)  取出所有韩文
    ' \xAC00-\xD7A3   →(韩文)  取出所有韩文
    ' \u0800-\u4e00   →(日文)   取出所有日文
    

.子程序 _只取汉字, 文本型, 公开
    .参数 字符串, 文本型
    .局部变量 字节集长度, 整数型
    .局部变量 字节集, 字节集
    .局部变量 取出位置, 整数型
    .局部变量 文本, 文本型

    字节集 ＝ 到字节集 (字符串)
    字节集长度 ＝ 取字节集长度 (字节集)
    取出位置 ＝ 1
    .判断循环首 (取出位置 ＜ 字节集长度)
        .判断开始 (字节集 [取出位置] ≥ 176 且 字节集 [取出位置 ＋ 1] ≥ 161 且 字节集 [取出位置] ≤ 247 且 字节集 [取出位置 ＋ 1] ≤ 254) ' 判断GBK/2: GB2312 汉字
            文本 ＝ 文本 ＋ 到文本 (取字节集中间 (字节集, 取出位置, 2))
            取出位置 ＝ 取出位置 ＋ 2
        .默认
            .判断开始 (字节集 [取出位置] ＞ 127 且 字节集 [取出位置 ＋ 1] ＞ 127) ' 判断是否全角字符)
                取出位置 ＝ 取出位置 ＋ 2
            .默认
                取出位置 ＝ 取出位置 ＋ 1
            .判断结束
            
        .判断结束
        
    .判断循环尾 ()
    返回 (文本)
    

.子程序 文本区分_只取字母, 文本型, 公开, 在一大串网页源码中 只取字母
    .参数 源文本, 文本型, , 要取出字母的源文本
    .参数 大小写类型, 整数型, 可空, 默认为0  0=取大小写  1只取小写  2只取大写
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型

    .判断开始 (大小写类型 ＝ 0)
        正则.创建 (“[a-zA-Z]”, 源文本, 真)
    .判断 (大小写类型 ＝ 1)
        正则.创建 (“[a-z]”, 源文本, 真)
    .判断 (大小写类型 ＝ 2)
        正则.创建 (“[A-Z]”, 源文本, 真)
    .默认
        
    .判断结束
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    返回 (局_临时文本)

.子程序 文本区分_只取符号, 文本型, 公开, 在一大串网页源码中 只取符号
    .参数 源文本, 文本型, , 要取出符号的源文本
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型

    正则.创建 (“[^0-9a-z\u4e00-\u9fa5]”, 源文本)
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    返回 (局_临时文本)

.子程序 文本区分_只取数字, 文本型, 公开, 在一大串网页源码中 只取数字
    .参数 源文本, 文本型, , 要取出数字的源文本
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型

    正则.创建 (“[0-9]”, 源文本)
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    返回 (局_临时文本)

.子程序 文本_朗读, , 公开, 朗读一段指定的文本
    .参数 朗读的文本, 文本型, 可空
    .参数 百度语音引擎, 逻辑型, 可空, 可为空，默认使用微软语音引擎。
    .参数 音频数据, 字节集, 可空
    .参数 音频文件, 文本型, 可空, 如：C:\mp3，C:\MAV等等
    .参数 保存朗读文本至文件, 文本型, 可空, 只针对“朗读的文本”和“音频数据”有效，请提供要保存至的文件夹路径，如：C:\
    .参数 朗读方式, 逻辑型, 可空, 真=支持库方式  假=API方式  默认为假  API方式
    .局部变量 局_语音, 字节集
    .局部变量 局_文件名, 文本型
    .局部变量 局_引擎地址, 文本型

    局_文件名 ＝ “”
    .如果真 (是否为空 (保存朗读文本至文件) ＝ 假 且 目录_是否存在 (保存朗读文本至文件))
        .如果真 (取文本左边 (保存朗读文本至文件, 1) ≠ “\”)
            保存朗读文本至文件 ＝ 保存朗读文本至文件 ＋ “\”
        .如果真结束
        
    .如果真结束
    .判断开始 (删首尾空 (朗读的文本) ≠ “”)
        局_文件名 ＝ 目录_取临时目录 () ＋ 校验_取md5 (到字节集 (朗读的文本)) ＋ “.mp3”
        .如果真 (文件_是否存在 (局_文件名) ＝ 假)
            .如果 (百度语音引擎)
                局_引擎地址 ＝ “http://tts.baidu.com/text2audio?lan=zh&ie=UTF-8&text=” ＋ 编码_URL编码 (朗读的文本, , 真)
            .否则
                局_引擎地址 ＝ “http://api.microsofttranslator.com/V2/Http.svc/Speak?language=zh-CN&appid=05DBC69E5594C137B9E22680F92F8E5E115A7817&text=” ＋ 编码_URL编码 (朗读的文本, , 真) ＋ “&format=audio/mp3&options=MaxQuality”
            .如果结束
            局_语音 ＝ 网页_访问J (局_引擎地址)
            写到文件 (局_文件名, 局_语音)
        .如果真结束
        
        .如果真 (是否为空 (保存朗读文本至文件) ＝ 假)
            .如果 (取字节集长度 (局_语音) ＝ 0)
                文件_复制 (局_文件名, 保存朗读文本至文件 ＋ 朗读的文本 ＋ “.mp3”, 0)
            .否则
                写到文件 (保存朗读文本至文件 ＋ 朗读的文本 ＋ “.mp3”, 局_语音)
            .如果结束
            
        .如果真结束
        
    .判断 (是否为空 (音频数据) ＝ 假)
        局_文件名 ＝ 目录_取临时目录 () ＋ 校验_取md5 (音频数据) ＋ “.mp3”
        .如果真 (文件_是否存在 (局_文件名) ＝ 假)
            写到文件 (局_文件名, 音频数据)
        .如果真结束
        
        .如果真 (是否为空 (保存朗读文本至文件) ＝ 假)
            写到文件 (保存朗读文本至文件 ＋ “音频数据.mp3”, 音频数据)
        .如果真结束
        
        
    .判断 (文件_是否存在 (音频文件))
        局_文件名 ＝ 音频文件
        
    .默认
        输出调试文本 (“朗读的文本、音频数据和音频文件必须提供一个”)
    .判断结束
    
    .如果真 (文件_是否存在 (局_文件名))
        .判断开始 (朗读方式)
            播放MP3 (1, 局_文件名)
        .默认
            音乐_播放 (局_文件名, 文本_取随机汉字 (10, ))
        .判断结束
        
        
    .如果真结束
    

.子程序 文本_朗读Ex, 逻辑型, 公开, 本命令由【sizaizuotian】提供接口
    .参数 朗读文本, 文本型
    .参数 保存朗读文本至文件, 文本型, 可空
    .参数 朗读方式, 逻辑型, 可空, 真=支持库方式  假=API方式  默认为假  API方式
    .局部变量 局_朗读内容, 文本型
    .局部变量 局_接口地址, 文本型
    .局部变量 局_朗读文件, 字节集
    .局部变量 局_临时文件, 文本型
    .局部变量 局_保存结果, 逻辑型

    局_朗读内容 ＝ 编码_URL编码 (朗读文本, , 真)
    局_接口地址 ＝ “http://fanyi.baidu.com/gettts?lan=zh&text=” ＋ 局_朗读内容 ＋ “&spd=5&source=web.mp3”
    局_朗读文件 ＝ 网页_访问_对象 (局_接口地址)
    .如果 (是否为空 (保存朗读文本至文件) ＝ 假)
        局_保存结果 ＝ 写到文件 (保存朗读文本至文件, 局_朗读文件)
        返回 (局_保存结果)
    .否则
        局_临时文件 ＝ 目录_取临时目录 () ＋ 校验_取md5 (到字节集 (局_朗读文件)) ＋ “.mp3”
        局_保存结果 ＝ 写到文件 (局_临时文件, 局_朗读文件)
        .判断开始 (朗读方式)
            播放MP3 (1, 局_临时文件)
        .默认
            音乐_播放 (局_临时文件, 文本_取随机汉字 (10, ))
        .判断结束
        
        返回 (局_保存结果)
    .如果结束
    返回 (真)
    

.子程序 文本_指针到文本A, 文本型, 公开, 返回指定内存指针所指向地址处的文本，注意调用本命令前一定要确保所提供的内存指针真实有效，且指向一个以零字符结束的文本串。
    .参数 内存文本指针, 整数型

    返回 (lstrcat (内存文本指针, 0))

.子程序 文本_指针到文本W, 文本型, 公开, 取内存中Unicode字符串文本。返回指定内存指针所指向地址处的文本，注意调用本命令前一定要确保所提供的内存指针真实有效，且指向一个以零字符结束的文本串。 
    .参数 Unicode内存指针
    .局部变量 tmp, 字节型, , "0"
    .局部变量 tmpLen

    .如果真 (Unicode内存指针 ≠ 0)
        tmpLen ＝ lstrlen (Unicode内存指针) × 2 ＋ 8
        .如果真 (tmpLen ≠ 0)
            重定义数组 (tmp, 假, tmpLen － 1)
            RtlMoveMemory_整数型 (取数据_通用型_数组 (tmp), Unicode内存指针, tmpLen)
            返回 (编码_Unicode到Ansi (到字节集 (tmp)))
        .如果真结束
        
    .如果真结束
    返回 (“”)
    

.子程序 文本_加密c, 字节集, 公开, 支持密钥加密，成功返回加密后文本，失败返回空。
    .参数 欲加密文本, 文本型
    .参数 密码, 文本型, 可空, 可为空，默认为 “bbs.125.la”
    .局部变量 lHHash
    .局部变量 lHkey
    .局部变量 lHCryptprov
    .局部变量 lCryptLength
    .局部变量 lCryptBufLen
    .局部变量 sCryptBuffer, 字节集
    .局部变量 bresult, 逻辑型

    .如果真 (取文本长度 (欲加密文本) ≠ 0)
        bresult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 0)
        .如果真 (bresult ＝ 假) ' 如果没有默认密钥容器，然后创建一个
            bresult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 8)
            .如果真 (bresult ＝ 假)
                返回 ({ })
            .如果真结束
            
        .如果真结束
        密码 ＝ 选择 (是否为空 (密码), “bbs.125.la”, 密码)
        CryptCreateHash (lHCryptprov, 32771, 0, 0, lHHash)
        CryptHashData (lHHash, 到字节集 (密码), 取文本长度 (密码), 0)
        CryptDeriveKey (lHCryptprov, 26625, lHHash, 0, lHkey)
        CryptDestroyHash (lHHash)
        
        lCryptLength ＝ 取文本长度 (欲加密文本)
        lCryptBufLen ＝ lCryptLength
        sCryptBuffer ＝ 取空白字节集 (lCryptLength)
        sCryptBuffer ＝ 到字节集 (欲加密文本)
        
        bresult ＝ CryptEncrypt (lHkey, 0, 1, 0, sCryptBuffer, lCryptLength, lCryptBufLen)
        CryptDestroyKey (lHkey)
        CryptDestroyHash (lHHash)
        CryptReleaseContext (lHCryptprov, 0)
    .如果真结束
    返回 (选择 (bresult, sCryptBuffer, { }))

.子程序 文本_解密c, 文本型, 公开, 支持密钥解密，成功返回解密后文本，失败返回空。
    .参数 加密后文本, 字节集
    .参数 密码, 文本型, 可空, 可为空，默认为 “bbs.125.la”
    .局部变量 lHCryptprov
    .局部变量 lHHash
    .局部变量 lHkey
    .局部变量 bResult, 逻辑型
    .局部变量 sCryptBuffer, 字节集
    .局部变量 lCryptBufLen
    .局部变量 lCryptPoint

    .如果真 (取字节集长度 (加密后文本) ≠ 0)
        bResult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 0)
        .如果真 (bResult ＝ 假)
            bResult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 8)
            .如果真 (bResult ＝ 假)
                返回 (“”)
            .如果真结束
            
        .如果真结束
        密码 ＝ 选择 (是否为空 (密码), “bbs.125.la”, 密码)
        CryptCreateHash (lHCryptprov, 32771, 0, 0, lHHash)
        CryptHashData (lHHash, 到字节集 (密码), 取文本长度 (密码), 0)
        CryptDeriveKey (lHCryptprov, 26625, lHHash, 0, lHkey)
        CryptDestroyHash (lHHash)
        
        lCryptBufLen ＝ 取字节集长度 (加密后文本)
        sCryptBuffer ＝ 取空白字节集 (lCryptBufLen)
        sCryptBuffer ＝ 加密后文本
        bResult ＝ CryptDecrypt (lHkey, 0, 1, 0, sCryptBuffer, lCryptBufLen)
        
        CryptDestroyKey (lHkey)
        CryptDestroyHash (lHHash)
        CryptReleaseContext (lHCryptprov, 0)
    .如果真结束
    返回 (选择 (bResult, 到文本 (sCryptBuffer), “”))
    
    
    
    
    

.子程序 文本_加密, 文本型, 公开, 失败返回空文本
    .参数 参数_待加密文本, 文本型, , 待加密文本
    .参数 参数_加密的密码, 文本型, , 加密的密码<建议5位以上的数字>
    .局部变量 局_计次, 整数型
    .局部变量 局_过度字节集, 字节集
    .局部变量 局_待加密文本, 字节集

    局_待加密文本 ＝ 到字节集 (参数_待加密文本)
    .计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
        局_过度字节集 ＝ 局_过度字节集 ＋ 到字节集 (到字节 (位异或 (局_待加密文本 [局_计次], 3600)))
    .计次循环尾 ()
    返回 (字节集_字节集到十六进制 (局_过度字节集) ＋ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_加密的密码)), 3, 9)))

.子程序 文本_解密, 文本型, 公开, 失败返回空文本
    .参数 参数_待解密文本, 文本型, , 待解密文本
    .参数 参数_解密的密码, 文本型, , 解密的密码<建议5位以上的数字>
    .局部变量 局_计次, 整数型
    .局部变量 局_过度字节集, 字节集
    .局部变量 局_待加密文本, 字节集

    .如果真 (取文本右边 (参数_待解密文本, 9) ≠ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_解密的密码)), 3, 9)))
        返回 (“”)
    .如果真结束
    局_待加密文本 ＝ 字节集_十六进制到字节集 (取文本左边 (参数_待解密文本, 取文本长度 (参数_待解密文本) － 9))
    .计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
        局_过度字节集 ＝ 局_过度字节集 ＋ 到字节集 (到字节 (位异或 (局_待加密文本 [局_计次], 3600)))
    .计次循环尾 ()
    返回 (到文本 (局_过度字节集))

.子程序 文本_是否为数字, 逻辑型, 公开, 中间不能有空格,判断指定文本是否是数字
    .参数 参_文本, 文本型
    .局部变量 i, 整数型
    .局部变量 Len, 整数型
    .局部变量 asc, 整数型

    
    Len ＝ 取文本长度 (参_文本)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (参_文本, i)
        .判断开始 (asc ＜ 48) ' a=97
            返回 (假)
        .判断 (asc ＞ 57) ' z=122
            返回 (假)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (真)
    

.子程序 文本_自动补零, 文本型, 公开, 当指定文本长度不足时前面自动补零，通用用于数据库序列号
    .参数 参_欲补齐文本, 文本型
    .参数 参_补齐长度

    返回 (取重复文本 (参_补齐长度 － 取文本长度 (参_欲补齐文本), “0”) ＋ 参_欲补齐文本)

.子程序 文本_是否小写字母, 逻辑型, 公开, 中间不能有空格,By:邓学彬(泪闯天涯)
    .参数 字符串, 文本型
    .局部变量 Len, 整数型
    .局部变量 i, 整数型
    .局部变量 asc, 整数型

    Len ＝ 取文本长度 (字符串)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (字符串, i)
        .判断开始 (asc ＜ 97) ' a=97
            返回 (假)
        .判断 (asc ＞ 122) ' z=122
            返回 (假)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_是否大写字母, 逻辑型, 公开, 中间不能有空格,By:邓学彬(泪闯天涯)
    .参数 字符串, 文本型
    .局部变量 Len, 整数型
    .局部变量 i, 整数型
    .局部变量 asc, 整数型

    Len ＝ 取文本长度 (字符串)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (字符串, i)
        .判断开始 (asc ＜ 65) ' A=65
            返回 (假)
        .判断 (asc ＞ 90) ' Z=90
            返回 (假)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_取某位置文本, 文本型, 公开, 取某位置下的文本，如果指定位置超出文本长度，返回空文本。
    .参数 文本, 文本型
    .参数 位置, 整数型
    .参数 取出文本类型, 逻辑型, 参考 可空, 得到指定位置的文本类型，全角为真，半角为假。
    .局部变量 _局部变量1, 文本型

    ' https://bbs.125.la/thread-14428295-1-1.html
    .如果真 (位置 ＞ 取文本长度 (文本) 或 位置 ≤ 0)
        返回 (“”)
    .如果真结束
    _局部变量1 ＝ 取文本中间 (文本, 位置, 2)
    .如果真 (取代码 (_局部变量1, ) ＜ 0)
        _局部变量1 ＝ 取文本中间 (文本, 位置 － 1, 2)
        .如果真 (取代码 (_局部变量1, ) ＜ 0)
            取出文本类型 ＝ 真
            返回 (_局部变量1)
        .如果真结束
        取出文本类型 ＝ 真
        返回 (取文本中间 (文本, 位置, 2))
    .如果真结束
    取出文本类型 ＝ 假
    返回 (取文本中间 (文本, 位置, 1))

