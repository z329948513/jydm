.版本 2

.程序集 类_HOOK_EX
.程序集变量 集_回调地址, 整数型
.程序集变量 集_回调指针, 整数型
.程序集变量 集_回调指针ex, 整数型
.程序集变量 集_原代码, 字节集
.程序集变量 集_原长度, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    ' 本类收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14327228

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    卸载 ()

.子程序 安装, 逻辑型, 公开, 将某个地址指向某个新地址，俗称hook。如果hook api 新地址参数必须全部为指针型(即整数型)，否则会有不可预知的错误。    如hook指令(即任意位置，非函数。此情况注意新地址取真实地址，否则状态可能被更改，和堆栈平衡。)，请勿使用静态回调功能。    开启回调：调用方法 回调() 或 回调ex() 即可全静态回调原函数，无需频繁安装与卸载，减少资源浪费CPU消耗。
    .参数 参_源地址, 整数型
    .参数 参_新地址, 整数型
    .参数 参_关闭回调, 逻辑型, 可空, 默认为假，开启静态回调 【非hook函数头部请勿开启。。用于不需要频繁安装与卸载的情况下，如果需要频繁安装与卸载，请关闭。】如果开启可使用方法 回调() 或者 回调ex()  直接回调
    .局部变量 局_回调代码, 字节集
    .局部变量 局_原代码, 字节集
    .局部变量 局_函数代码, 字节集
    .局部变量 局_理想长度, 整数型
    .局部变量 局_新代码, 字节集
    .局部变量 局_回调头部, 字节集
    .局部变量 局_参数个数, 整数型
    .局部变量 局_回调参数入栈, 字节集
    .局部变量 局_回调参数修改, 字节集
    .局部变量 i, 整数型
    .局部变量 局_回调开栈, 字节集
    .局部变量 局_回调保存, 字节集
    .局部变量 局_回调计数, 字节集
    .局部变量 局_回调源地址, 字节集
    .局部变量 局_回调写入加恢复, 字节集
    .局部变量 局_返回地址入栈, 字节集
    .局部变量 局_函数清栈加返回, 字节集

    .如果真 (集_回调地址 ＞ 0)
        返回 (假)
    .如果真结束
    局_新代码 ＝ { 104 } ＋ 到字节集 (参_新地址) ＋ { 195 }
    局_函数代码 ＝ 指针到字节集 (参_源地址, 12)
    .如果真 (参_关闭回调) ' 未开启回调直接修改。
        集_原长度 ＝ 6
        集_回调地址 ＝ 参_源地址 ＋ 6
        集_原代码 ＝ 取字节集左边 (局_函数代码, 6)
        返回 (内存_修改内存 (参_源地址, 局_新代码, 6))
    .如果真结束
    局_理想长度 ＝ 内存_取指令对其长度 (6, 局_函数代码)
    .如果真 (局_理想长度 ＜ 6)
        返回 (假)
    .如果真结束
    局_原代码 ＝ 取字节集左边 (局_函数代码, 局_理想长度)
    局_原代码 ＝ 内存_跳转偏移处理 (局_原代码, 参_源地址)
    集_原长度 ＝ 局_理想长度
    集_回调地址 ＝ 参_源地址 ＋ 局_理想长度
    集_原代码 ＝ 局_原代码
    局_回调代码 ＝ { 97, 201, 201 } ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
    集_回调指针 ＝ 内存_拷贝字节集 (局_回调代码)
    集_回调指针ex ＝ 内存_拷贝字节集 (取空白字节集 (1024))
    局_参数个数 ＝ 程序_取参数个数 (参_新地址)
    .判断开始 (局_参数个数 ＞ 0)
        局_回调头部 ＝ { 97, 201 }
        局_回调开栈 ＝ { 129, 236 } ＋ 到字节集 (到整数 (局_参数个数 × 4)) ' { 129, 196, 16, 0, 0, 0 }
        局_回调保存 ＝ { 81, 87, 86 }
        局_回调计数 ＝ { 199, 193 } ＋ 到字节集 (局_参数个数) ' {199,193,4,0,0,0}
        局_回调源地址 ＝ { 141, 188, 36, 12, 0, 0, 0 } ' { 141, 188, 36, 12, 0, 0, 0 }
        局_回调写入加恢复 ＝ { 141, 181, 8, 0, 0, 0, 243, 165, 94, 95, 89 }
        局_返回地址入栈 ＝ { 104 } ＋ 到字节集 (到整数 (集_回调指针ex ＋ 512))
        局_回调代码 ＝ 局_回调头部 ＋ 局_回调开栈 ＋ 局_回调保存 ＋ 局_回调计数 ＋ 局_回调源地址 ＋ 局_回调写入加恢复 ＋ 局_返回地址入栈 ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
        内存_写到内存 (集_回调指针ex, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
        ' 恢复代码
        局_回调源地址 ＝ { 141, 180, 36, 12, 0, 0, 0 }
        局_回调写入加恢复 ＝ { 141, 189, 8, 0, 0, 0, 243, 165, 94, 95, 89 }
        局_函数清栈加返回 ＝ { 129, 196 } ＋ 到字节集 (到整数 (局_参数个数 × 4)) ＋ { 194, 4, 0 }
        局_回调代码 ＝ 局_回调开栈 ＋ 局_回调保存 ＋ 局_回调计数 ＋ 局_回调源地址 ＋ 局_回调写入加恢复 ＋ 局_函数清栈加返回
        内存_写到内存 (集_回调指针ex ＋ 512, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
    .默认
        局_回调头部 ＝ { 97, 201 }
        局_返回地址入栈 ＝ { 104 } ＋ 到字节集 (到整数 (集_回调指针ex ＋ 512))
        局_回调代码 ＝ 局_回调头部 ＋ 局_返回地址入栈 ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
        内存_写到内存 (集_回调指针ex, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
        ' 返回代码
        局_回调代码 ＝ { 194, 4, 0 }
        内存_写到内存 (集_回调指针ex ＋ 512, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
    .判断结束
    返回 (内存_修改内存 (参_源地址, 局_新代码, 6))
    
    ' 调用前：
    ' sub esp,10
    ' push ecx
    ' push edi
    ' push esi
    ' mov ecx,4
    ' lea edi,[esp+0xc]
    ' lea esi,[ebp+8]
    ' rep movsd
    ' pop esi
    ' pop edi
    ' pop ecx
    ' push 0
    ' 调用后:
    ' sub esp,10
    ' push ecx
    ' push edi
    ' push esi
    ' mov ecx,4
    ' lea esi,[esp+0xc]
    ' lea edi,[ebp+8]
    ' rep movsd
    ' pop esi
    ' pop edi
    ' pop ecx
    ' add esp,10
    ' retn
    
    

.子程序 卸载, , 公开, 对象被销毁前自动调用,无特殊情况无需使用。
    .如果真 (集_回调地址 ＞ 0)
        内存_修改内存 (集_回调地址 － 集_原长度, 集_原代码, 6)
        集_回调地址 ＝ 0
        集_回调指针 ＝ 0
        集_原代码 ＝ { }
        集_原长度 ＝ 0
    .如果真结束
    

.子程序 回调, , 公开, 【静态回掉，需在安装时开启了回调功能。仅适用于函数hook】使用该方法后 将忽略该调用该方法处往后的一切代码 包括返回值。  如果对返回值和参数有要求可使用 回调ex()
    置入代码 ({ 96 })
    到整数 (集_回调指针)
    置入代码 ({ 80, 195 })

.子程序 回调ex, 整数型, 公开, 【静态回调，需在安装时开启了回调功能。仅适用于函数hook】使用该方法后，返回值为原函数返回值，如原函数返回的非整数型，那么此返回值可能是一个指针。如原函数会改动参数，那么改动后的参数便是函数内的参数，直接读取即可。 如果对返回值和参数无要求可使用 回调()
    置入代码 ({ 96 })
    到整数 (集_回调指针ex)
    置入代码 ({ 80, 195 })
    返回 (0)
    

.子程序 取原代码, 字节集, 公开, 返回原始代码。
    返回 (集_原代码)
    

