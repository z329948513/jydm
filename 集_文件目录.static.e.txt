.版本 2

.程序集 集_文件目录
.程序集变量 程序集_文件数组, 文本型, , "0"
.程序集变量 集_目录, 文本型

.子程序 文件_是否被占用, 逻辑型, 公开
    .参数 文件路径, 文本型
    .局部变量 hFile, 整数型

    .如果真 (文件是否存在 (文件路径))
        hFile ＝ CreateFileA (文件路径, #GENERIC_WRITE, 0, 0, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, 0)
        .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
            CloseHandle (hFile)
            返回 (假)
        .如果真结束
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 文件_创建稀疏文件, 整数型, 公开, 成功返回文件句柄
    .参数 参_文件名, 文本型
    .局部变量 局_文件句柄, 整数型

    .如果真 (文件_是否是稀疏文件 (参_文件名) ＝ 假)
        返回 (0)
    .如果真结束
    .如果真 (文件是否存在 (参_文件名) ＝ 假)
        局_文件句柄 ＝ 打开文件 (参_文件名, #改写, )
        写出数据 (局_文件句柄, { 0 })
        关闭文件 (局_文件句柄)
    .如果真结束
    局_文件句柄 ＝ CreateFileA (参_文件名, 位或 (#GENERIC_READ_, #GENERIC_WRITE), 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE), 0, #OPEN_EXISTING, 0, 0)
    DeviceIoControl1 (局_文件句柄, #FSCTL_SET_SPARSE, 0, 0, 0, 0, 0, 0)
    返回 (局_文件句柄)

.子程序 文件_是否是稀疏文件, 逻辑型, 公开
    .参数 参_文件名, 文本型
    .局部变量 局_文件属性, 整数型

    局_文件属性 ＝ GetFileAttributesA (参_文件名)
    .如果真 (局_文件属性 ＝ -1)
        返回 (假)
    .如果真结束
    .如果 (位与 (局_文件属性, #FILE_ATTRIBUTE_SPARSE_FILE) ＝ 512)
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    

.子程序 文件_取图标, 字节集, 公开, 返回指定文件路径文件的图标
    .参数 窗口句柄, 整数型, , 当前程序的窗口句柄
    .参数 文件路径, 文本型, , 文件的完整路径
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 背景色, 整数型, 可空
    .局部变量 ImgHandle, 整数型
    .局部变量 Bin, 字节集

    .如果真 (是否为空 (背景色))
        背景色 ＝ #品红
    .如果真结束
    ImgHandle ＝ 文件_取图标句柄 (文件路径)
    Bin ＝ 图片_通过句柄取图标 (窗口句柄, ImgHandle, 宽度, 高度, 背景色)
    DestroyIcon (ImgHandle)
    返回 (Bin)

.子程序 文件_文件名是否可用, 逻辑型, 公开
    .参数 参_文件名, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 i, 整数型

    .如果真 (取文本长度 (参_文件名) ＝ 255)
        返回 (假)
    .如果真结束
    局_数组 ＝ 分割文本 (#常量_过滤字符, “ ”, )
    .计次循环首 (取数组成员数 (局_数组), i)
        .如果真 (寻找文本 (参_文件名, 局_数组 [i], , 假) ≠ -1)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文件_取文件信息, 文本型, 公开, 取指定文件相关休息，默认取备注
    .参数 文件路径, 文本型
    .参数 类型, 整数型, 可空, “1备注”, “2公司名”, “3描述”, “4文件版本”, “5内部名称”, “6版权”, “7合法商标”, “8原文件名”, “9个人用编译版说明”, “10产品名称”, “11产品版本”, “12特殊编译版说明”
    .局部变量 temp1, 文本型
    .局部变量 temp2, 文本型
    .局部变量 buf, 字节集
    .局部变量 vsize, 整数型
    .局部变量 nsize, 整数型
    .局部变量 temp4, 整数型
    .局部变量 nbuf, 文本型
    .局部变量 temp3, 字节集
    .局部变量 buff, 文本型
    .局部变量 txt, 文本型, , "2"

    vsize ＝ GetFileVersionInfoSize (文件路径, 0)
    .如果真 (vsize ＞ 0)
        
        buf ＝ 取空白字节集 (vsize)
        GetFileVersionInfo (文件路径, 0, vsize, buf)
        .如果真 (VerQueryValue_x (buf, “\VarFileInfo\Translation”, temp4, nsize) ＝ 0)
            
            返回 (“”)
        .如果真结束
        temp3 ＝ 取空白字节集 (nsize)
        RtlMoveMemory_字节集传址1 (temp3, temp4, nsize)
        nbuf ＝ 取重复文本 (8 － 取文本长度 (取十六进制文本 (取字节集数据 (temp3, 3, ))), “0”) ＋ 取十六进制文本 (取字节集数据 (temp3, 3, ))
        
        nbuf ＝ 取文本右边 (nbuf, 4) ＋ 取文本左边 (nbuf, 4)
        txt ＝ { “\Comments”, “\CompanyName”, “\FileDescription”, “\FileVersion”, “\InternalName”, “\LegalCopyright”, “\LegalTrademarks”, “\OriginalFilename”, “\PrivateBuild”, “\ProductName”, “\ProductVersion”, “\SpecialBuild” }
        
        .如果真 (是否为空 (类型))
            类型 ＝ 1
        .如果真结束
        
        .如果真 (VerQueryValue_x (buf, “\StringFileInfo\” ＋ nbuf ＋ txt [类型], temp4, nsize) ≠ 0)
            temp3 ＝ 取空白字节集 (nsize)
            RtlMoveMemory_字节集传址1 (temp3, temp4, nsize)
            temp1 ＝ 取字节集数据 (temp3, #文本型, )
        .如果真结束
        
    .如果真结束
    返回 (temp1)
    

.子程序 文件_取文件版本号, 文本型, 公开, 返回指定文件的版本号
    .参数 FullFileName, 文本型
    .参数 错误信息, 文本型, 参考 可空
    .局部变量 size, 整数型
    .局部变量 文件版本字节集, 字节集
    .局部变量 lVerPointer, 整数型
    .局部变量 返回长度, 整数型

    .局部变量 bytebuffer, 字节型, , "261"
    .局部变量 HexNumber, 整数型
    .局部变量 Lang_Charset_String, 文本型
    .局部变量 临时_文本, 文本型
    .局部变量 rc, 整数型
    .局部变量 文件版本, 文本型

    size ＝ GetFileVersionInfoSize (FullFileName, 0)
    .如果真 (size ≤ 0)
        错误信息 ＝ “GetFileVersionInfoSize（获取信息长度）失败”
        返回 (“”)
    .如果真结束
    文件版本字节集 ＝ 取空白字节集 (size)
    
    .如果真 (GetFileVersionInfo (FullFileName, 0, size, 文件版本字节集) ＝ 假)
        错误信息 ＝ “GetFileVersionInfo（获取信息）失败”
        返回 (“”)
    .如果真结束
    
    .如果真 (VerQueryValue (文件版本字节集, “\VarFileInfo\Translation”, lVerPointer, 返回长度) ＝ 假)
        错误信息 ＝ “VerQueryValue（查询Version）失败”
        返回 (“”)
    .如果真结束
    RtlMoveMemory_整数型 (取数据_通用型_数组 (bytebuffer), lVerPointer, 返回长度)
    HexNumber ＝ bytebuffer [3] ＋ bytebuffer [4] × 256 ＋ bytebuffer [1] × 65536 ＋ bytebuffer [2] × 16777216
    rc ＝ 到长整数 (bytebuffer [1] ＋ bytebuffer [2] × 256)
    Lang_Charset_String ＝ 取十六进制文本 (HexNumber)
    
    .判断循环首 (取文本长度 (Lang_Charset_String) ＜ 8)
        Lang_Charset_String ＝ “0” ＋ Lang_Charset_String
    .判断循环尾 ()
    
    临时_文本 ＝ 取空白文本 (261)
    临时_文本 ＝ “\StringFileInfo\” ＋ Lang_Charset_String ＋ “\FileVersion”
    .如果 (VerQueryValue (文件版本字节集, 临时_文本, lVerPointer, 返回长度))
        文件版本 ＝ 取空白文本 (返回长度)
        lstrcpy (文件版本, lVerPointer)
    .否则
        文件版本 ＝ “”
    .如果结束
    
    返回 (文件版本)
    

.子程序 目录_处理, 文本型, 公开, 检测最后一个字符是否为“\”如果不是则加上，某些支持库或组件要求必须结尾有\等符号才能识别为目录。源码由雪山凌狐提供
    .参数 要处理的目录, 文本型, , 传入要检测和处理的目录路径
    .局部变量 返回值, 文本型

    返回值 ＝ 要处理的目录
    .如果真 (取文本右边 (要处理的目录, 1) ≠ “\”)
        返回值 ＝ 返回值 ＋ “\”
    .如果真结束
    返回 (返回值)

.子程序 文件_枚举EX, , 公开, 遍历特定目录特定后缀名的所有文件，结果在回调函数中输出，源码由雪山凌狐提供
    .参数 查找的目录, 文本型, , 程序内部会自动给目录结尾加上“\”
    .参数 后缀名, 文本型, 可空, 默认为“*”，即查找所有后缀名文件，如果传入空文本参数，则同样视为遍历所有后缀名文件
    .参数 是否遍历子目录, 逻辑型, 可空, 默认为假，即仅遍历根目录的文件
    .参数 回调函数, 子程序指针, 可空, 指定一个外部的子程序可以在每次找出一个文件的时候运行，该函数的第一个参数为查找到的文件名，第二个参数为文件的完整路径
    .局部变量 文件名, 文本型
    .局部变量 文件目录, 文本型
    .局部变量 完整路径, 文本型
    .局部变量 前缀, 文本型

    ' 初始化可空参数
    .如果真 (是否为空 (后缀名) 或 后缀名 ＝ “”)
        后缀名 ＝ “*”
    .如果真结束
    .如果真 (是否为空 (是否遍历子目录))
        是否遍历子目录 ＝ 假
    .如果真结束
    
    .如果 (寻找文本 (后缀名, “*.”, , 假) ≠ -1)
        前缀 ＝ “”
    .否则
        前缀 ＝ “*.”
    .如果结束
    
    
    
    ' 规范化传入的目录名
    .如果真 (取文本右边 (查找的目录, 1) ≠ “\”)
        查找的目录 ＝ 查找的目录 ＋ “\”
    .如果真结束
    
    ' 初始化查找
    文件名 ＝ 寻找文件 (查找的目录 ＋ 前缀 ＋ 后缀名, #只读文件 ＋ #隐藏文件 ＋ #系统文件 ＋ #存档文件)
    ' 循环查找内容
    .判断循环首 (文件名 ≠ “”)
        
        ' 回调运行
        ' 调用子程序 (回调函数, , , 文件名, 查找的目录 ＋ 文件名)
        完整路径 ＝ 查找的目录 ＋ 文件名
        
        .如果真 (后缀名 ≠ “*”)
            ' .如果真 (文件_取扩展名 (完整路径) ≠ “.” ＋ 后缀名)
                ' 到循环尾 ()
            ' .如果真结束
            
        .如果真结束
        
        程序_Call (到整数 (回调函数), lstrcpyn_文本型 (文件名, 文件名, 0), lstrcpyn_文本型 (完整路径, 完整路径, 0))
        
        ' 再次查找
        文件名 ＝ 寻找文件 (, #只读文件 ＋ #隐藏文件 ＋ #系统文件 ＋ #存档文件)
    .判断循环尾 ()
    
    ' 子目录文件查找
    .如果真 (是否遍历子目录)
        文件目录 ＝ 寻找文件 (查找的目录 ＋ “*.*”, #子目录)
        
        .判断循环首 (文件目录 ≠ “”)
            .如果真 (文件目录 ≠ “.” 且 文件目录 ≠ “..”)
                ' 递归调用，精髓所在
                文件_枚举EX (查找的目录 ＋ 文件目录, 后缀名, 真, 回调函数)
                处理事件 ()
            .如果真结束
            
            文件目录 ＝ 寻找文件 (, #子目录)
            
        .判断循环尾 ()
        
    .如果真结束
    

.子程序 文件_打开, 整数型, 公开, 文件必须存在，成功返回文件句柄，失败返回-1
    .参数 文件路径, 文本型
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。
    .局部变量 hFile, 整数型

    .如果 (执行模式 ＝ 0)
        hFile ＝ CreateFileA (文件路径, 位或 (#GENERIC_READ, #GENERIC_WRITE), 0, 0, #OPEN_EXISTING, #FILE_FLAG_SEQUENTIAL_SCAN, 0)
    .否则
        hFile ＝ 打开文件 (文件路径, #读写, #无限制)
    .如果结束
    返回 (hFile)

.子程序 文件_关闭, , 公开, 关闭后,将文件号设置为0
    .参数 文件号, 整数型, 参考
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。

    .如果真 (文件号 ＞ 0)
        .如果 (执行模式 ＝ 0)
            CloseHandle (文件号)
        .否则
            关闭文件 (文件号)
        .如果结束
        
    .如果真结束
    

.子程序 文件_重启电脑后替换, , 公开, 感谢【微凉清风】提供此函数
    .参数 用于替换的文件路径, 文本型
    .参数 被替换目标文件路径, 文本型
    .参数 是否删除源文件, 逻辑型, 可空, 可空，默认为假。是否删除“用于替换的文件路径”

    .如果真 (是否删除源文件 ＝ 真)
        MoveFileExA (用于替换的文件路径, 字符 (0), 4) ' #MOVEFILE_DELAY_UNTIL_REBOOT
    .如果真结束
    MoveFileExA (用于替换的文件路径, 被替换目标文件路径, 4) ' #MOVEFILE_DELAY_UNTIL_REBOOT

.子程序 文件_写出字节集, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 文件号, 整数型, , 由  文件_打开 函数返回文件句柄，不支持 易自带 打开文件(）命令。
    .参数 要写入的数据, 字节集
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。
    .局部变量 t, 字节集

    .如果真 (文件号 ＞ 0)
        t ＝ 取空白字节集 (取字节集长度 (要写入的数据))
        RtlMoveMemory_字节集2 (t, 要写入的数据, 取字节集长度 (要写入的数据))
        .如果真 (执行模式 ＝ 0)
            返回 (WriteFile (文件号, t, 取字节集长度 (要写入的数据), 0, 0))
        .如果真结束
        返回 (写出字节集 (文件号, 要写入的数据))
    .如果真结束
    返回 (假)

.子程序 文件_读入字节集, 整数型, 公开, 成功 = 非0    失败 = 0
    .参数 参_文件号, 整数型
    .参数 参_读入的字节集, 字节集
    .参数 参_读入长度, 整数型, 可空, 调用 文件_取实际大小 获取
    .参数 参_读入字符数, 整数型, 可空, 默认1024

    .如果真 (是否为空 (参_读入长度))
        GetFileSizeEx (参_文件号, 参_读入长度)
    .如果真结束
    
    .如果真 (是否为空 (参_读入字符数))
        参_读入字符数 ＝ 1024
    .如果真结束
    参_读入的字节集 ＝ 取空白字节集 (参_读入长度)
    返回 (ReadFile (参_文件号, 参_读入的字节集, 参_读入长度, 参_读入字符数, 0))

.子程序 文件_移动读写位置, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 文件号, 整数型
    .参数 移动距离, 整数型
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。

    .如果真 (执行模式 ＝ 0)
        .如果 (SetFilePointer (文件号, 移动距离, 0, 0) ＝ -1)
            输出调试文本 (“设置文件指针失败-API：” ＋ 到文本 (移动距离))
            返回 (假)
        .否则
            返回 (真)
        .如果结束
        
    .如果真结束
    返回 (移动读写位置 (文件号, #文件首, 移动距离))

.子程序 文件_下载, , 公开, 用windows自带的下载方式来下载文件；
    .参数 网络文件地址, 文本型
    .局部变量 局_长度, 整数型
    .局部变量 局_缓冲区, 字节集

    局_长度 ＝ MultiByteToWideChar (1, 2, 取指针文本_ (网络文件地址), -1, 0, 0) × 2
    .如果真 (局_长度 ＞ 0)
        局_缓冲区 ＝ 取空白字节集 (局_长度)
        MultiByteToWideChar (1, 2, 取指针文本_ (网络文件地址), -1, 取指针_字节集型 (局_缓冲区), 局_长度)
        DoFileDownload (局_缓冲区)
    .如果真结束
    

.子程序 文件_执行, 逻辑型, 公开, 执行文件夹或文件或命令(成功返回真,失败返回假)
    .参数 文件名, 文本型, , 欲操作(文件)或(文件夹的名称)或(网址)
    .参数 命令行, 文本型, 可空, 执行文件的命令行,没有则设为空
    .参数 窗口方式, 整数型, 可空, 可空为0:普通激活方式  1 隐藏窗口 2 最小化窗口

    .判断开始 (窗口方式 ＝ 1)
        窗口方式 ＝ 0
    .判断 (窗口方式 ＝ 2)
        窗口方式 ＝ 7
    .默认
        窗口方式 ＝ 1
    .判断结束
    .如果 (ShellExecuteA (0, “open”, 文件名, 命令行, “”, 窗口方式) ＝ 2)
        返回 (假)
    .否则
        返回 (真)
    .如果结束
    

.子程序 文件_定位, 逻辑型, 公开, 成功则打开文件所在目录并选中文件，失败返回假,本命令为初级命令！
    .参数 文件路径, 文本型, , 需提供文件绝对路径
    .参数 编辑模式, 逻辑型, 可空, 重命名模式。
    .局部变量 lngPidl, 整数型
    .局部变量 lngRet, 整数型
    .局部变量 strFile, 文本型
    .局部变量 返回值, 逻辑型

    .如果真 (文件_是否存在 (文件路径) ＝ 假)
        返回 (假)
    .如果真结束
    lngPidl ＝ SHCreateFromPath (文件路径)
    .如果真 (lngPidl ＝ 0)
        返回 (假)
    .如果真结束
    lngRet ＝ SHOpenFolderAndSelectItems (lngPidl, 0, 0, 选择 (编辑模式, 1, 0))
    SHFree (lngRet)
    返回 (lngRet ＝ 0)

.子程序 文件_取尺寸, 文本型, 公开, 直接大于2G以上超大文件
    .参数 参_文件名, 文本型, , 文件的完整路径
    .参数 参_格式化, 逻辑型, 可空, 格式化以B、KB、GB返回
    .局部变量 m_hfile
    .局部变量 m_fileSize, 长整数型
    .局部变量 m_objsfo, 对象
    .局部变量 m_objFile, 对象
    .局部变量 m_return, 文本型
    .局部变量 m_sbuffer, 文本型

    m_hfile ＝ _lopen (参_文件名, 0)
    GetFileSizeEx (m_hfile, m_fileSize)
    _lclose (m_hfile)
    .如果真 (m_fileSize ＝ 0)
        CoInitialize (0)
        m_objsfo.创建 (“scripting.FileSystemObject”, )
        m_objFile ＝ m_objsfo.对象型方法 (“GetFile”, 参_文件名)
        m_fileSize ＝ m_objFile.读属性 (“Size”, ).取数值 ()
        m_objFile.清除 ()
        m_objFile.清除 ()
        CoUninitialize ()
    .如果真结束
    .如果真 (参_格式化)
        m_sbuffer ＝ 取空白文本 (20)
        StrFormatByteSize64A (m_fileSize, m_sbuffer, 20)
        .如果真 (m_sbuffer ＝ “0 字节”)
            m_sbuffer ＝ “0”
        .如果真结束
        .如果真 (寻找文本 (m_sbuffer, “字节”, , 假) ≠ 0)
            m_sbuffer ＝ 子文本替换 (m_sbuffer, “字节”, “B”, , , 真)
        .如果真结束
        m_return ＝ m_sbuffer
    .如果真结束
    返回 (选择 (参_格式化, m_return, 到文本 (m_fileSize)))

.子程序 文件_取实际大小, 长整数型, 公开, 获取一个文件在磁盘上实际占据的字节数，如文件右键属性中的大小，显示就是实际压缩过的尺寸
    .参数 文件路径, 文本型
    .局部变量 局_整数结构, ULARGE_INTEGER
    .局部变量 局_文件大小, 长整数型

    ' https://bbs.125.la/thread-14484380-1-1.html
    局_整数结构.LowPart ＝ GetCompressedFileSize (文件路径, 局_整数结构.HighPart)
    .如果 (局_整数结构.LowPart ＜ 0) ' 文件大小在2-4G之间时低位是负值
        局_整数结构.LowPart ＝ 位与 (局_整数结构.LowPart, 2147483647) ' 将低位和（01111111111111111111111111111111）位与，去掉负号
        局_文件大小 ＝ 局_整数结构.HighPart × 4294967296 ＋ 2147483648 ＋ 局_整数结构.LowPart ' 再加上2G和高位得到文件实际大小
    .否则
        局_文件大小 ＝ 局_整数结构.HighPart × 4294967296 ＋ 局_整数结构.LowPart
    .如果结束
    返回 (局_文件大小)

.子程序 文件_关联, , 公开, 关联指定后缀名到指定文件 (打开该后缀名文件,该后缀名文件路径将作为参数传递给指定文件)
    .参数 程序路径, 文本型, , 可空，关联到程序的路径，如果留空将取消关联。
    .参数 后缀, 文本型, , 欲关联的后缀名,多个后缀用|分开 (如: asp|htm|html)
    .参数 ICO图标路径, 文本型, 可空, 被关联文件的图标 可空为执行文件(程序)图标，也可以直接指向一个其它一个可执行的文件。
    .参数 文件类型, 文本型, 可空, 关联文件的说明 被关联文件属性中的文件类型
    .参数 关联名, 文本型, 可空, 可空为后缀
    .局部变量 所有后缀, 文本型, , "0"
    .局部变量 a, 整数型
    .局部变量 局_关联名, 文本型

    所有后缀 ＝ 分割文本 (后缀, “|”, )
    .如果 (删首尾空 (程序路径) ＝ “”) ' 取消关联
        .计次循环首 (取数组成员数 (所有后缀), a)
            局_关联名 ＝ 取文本注册项 (#根类, “.” ＋ 所有后缀 [a] ＋ “\”, )
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\DefaultIcon”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\Shell\Open\Command”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\Shell\Open”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\Shell”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “”)
            写注册项 (1, “.” ＋ 所有后缀 [a] ＋ “\”, “”)
        .计次循环尾 ()
        
    .否则
        .如果真 (ICO图标路径 ＝ “”)
            ICO图标路径 ＝ 程序路径
        .如果真结束
        .如果真 (关联名 ＝ “”)
            关联名 ＝ 后缀
        .如果真结束
        写注册项 (1, 关联名 ＋ “\”, 文件类型) ' 关联文件说明
        写注册项 (1, 关联名 ＋ “\EditFlags”, 2) ' 别的关联文件也有,估计不能少.
        写注册项 (1, 关联名 ＋ “\Shell\Open\Command\”, #引号 ＋ 程序路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号) ' 以关联后缀文件的路径作为执行文件(程序)的命令行
        写注册项 (1, 关联名 ＋ “\DefaultIcon\”, ICO图标路径 ＋ “,0”)
        .计次循环首 (取数组成员数 (所有后缀), a)
            写注册项 (1, “.” ＋ 所有后缀 [a] ＋ “\”, 关联名) ' 关联后缀到htxt中
        .计次循环尾 ()
    .如果结束
    SHChangeNotify (134217728, 0, 0, 0)
    ' SHCNE_ASSOCCHANGED=134217728 一个文件类型关联发生了变化。SHCNF_IDLIST必须指定在uFlags参数。dwItem1和dwItem2不使用，必须为NULL。

.子程序 文件_取关联, 文本型, 公开, 写入一个后缀，取得此后缀文档打开方式，失败则返回空文本
    .参数 后缀, 文本型, , 文件后缀，如"txt","*.txt",".txt"三者都可以
    .局部变量 程序名, 文本型
    .局部变量 打开方式, 文本型

    后缀 ＝ 子文本替换 (后缀, “*”, , , , 真)
    后缀 ＝ 子文本替换 (后缀, “.”, , , , 真)
    程序名 ＝ 取文本注册项 (#根类, “.” ＋ 后缀 ＋ “\”, )
    .如果真 (取文本长度 (程序名) ＝ 0)
        返回 (“”)
    .如果真结束
    打开方式 ＝ 取文本注册项 (#根类, 程序名 ＋ “\shell\”, “open”)
    程序名 ＝ 取文本注册项 (#根类, 程序名 ＋ “\shell\” ＋ 打开方式 ＋ “\command\”, )
    返回 (程序名)

.子程序 文件_取目录, 文本型, 公开, 取得文件所在目录的路径,如：局_项数组:\012\3600.exe 成功将返回 局_项数组:\012\
    .参数 路径文件名, 文本型, , 文件的完整地址

    返回 (取文本左边 (路径文件名, 倒找文本 (路径文件名, “\”, , 假)))

.子程序 文件_取大小, 整数型, 公开, 1000K与1024K可不一样哦
    .参数 文件名, 文本型
    .局部变量 大小, 整数型

    .如果真 (文件是否存在 (文件名) ＝ 假) ' 没有文件就返回 0 或-1
        返回 (-1)
    .如果真结束
    大小 ＝ 取绝对值 (取文件尺寸 (文件名))
    .如果 (大小 ％ 1024 ≠ 0)
        大小 ＝ 大小 ＼ 1024 ＋ 1
    .否则
        大小 ＝ 大小 ＼ 1024
    .如果结束
    返回 (大小)

.子程序 文件_相差数, 整数型, , 返回两个目录中相差的文件数
    .参数 服务器目录, 文本型, , 目录不以\结尾会自动添加
    .参数 本地目录, 文本型, , 目录不以\结尾会自动添加
    .局部变量 文件名, 文本型
    .局部变量 子目录, 文本型
    .局部变量 返回数, 整数型

    服务器目录 ＝ 服务器目录 ＋ “\”
    本地目录 ＝ 本地目录 ＋ “\”
    创建目录 (本地目录)
    处理事件 ()
    文件名 ＝ 寻找文件 (服务器目录 ＋ “*.*”, 39)
    .判断循环首 (文件名 ≠ “”)
        .如果真 (文件是否存在 (本地目录 ＋ 文件名) ＝ 假)
            返回数 ＝ 返回数 ＋ 1
        .如果真结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    子目录 ＝ 寻找文件 (服务器目录 ＋ “*.*”, 16)
    .判断循环首 (子目录 ≠ “”)
        .如果真 (子目录 ≠ “.” 且 子目录 ≠ “..”)
            返回数 ＝ 返回数 ＋ 文件_相差数 (服务器目录 ＋ 子目录, 本地目录 ＋ 子目录)
        .如果真结束
        子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    返回 (返回数)
    

.子程序 文件_循环删除, , 公开, 删除指定的文件
    .参数 文件名, 文本型
    .参数 超时, 整数型, 可空, 毫秒，默认3秒
    .局部变量 用时, 整数型

    .如果真 (超时 ＝ 0)
        超时 ＝ 3000
    .如果真结束
    用时 ＝ 取启动时间 ()
    .判断循环首 (文件是否存在 (文件名))
        置文件属性 (文件名, 0)
        删除文件 (文件名)
        .如果真 (取启动时间 () － 用时 ≥ 超时)
            跳出循环 ()
        .如果真结束
        
    .判断循环尾 ()

.子程序 文件_创建, 整数型, 公开, 瞬间创建一个指定大小的文件，最大能创建 2,147,483,647 字节大小的文件。成功返回1，失败返回错误代码;
    .参数 文件路径, 文本型
    .参数 要创建的大小, 整数型, , 单位为字节,最大能创建 2,147,483,647 字节大小的文件
    .局部变量 hFile, 整数型
    .局部变量 iRet, 整数型

    目录_创建 (文件_取目录 (文件路径))
    hFile ＝ CreateFileA (文件路径, #GENERIC_WRITE, 0, 0, #OPEN_ALWAYS, #FILE_ATTRIBUTE_ARCHIVE, 0)
    .如果真 (hFile ＝ #INVALID_HANDLE) ' 创建文件失败返回值是-1
        返回 (GetLastError ()) ' 失败返回错误代码
    .如果真结束
    
    要创建的大小 ＝ SetFilePointer (hFile, 要创建的大小, 0, 0)
    .如果 (要创建的大小 ＞ -1) ' 表示创建成功
        .判断开始 (SetEndOfFile (hFile) ＝ 0) ' 设置文件结尾失败;
            iRet ＝ GetLastError ()
        .默认
            iRet ＝ 1
        .判断结束
        
    .否则
        iRet ＝ GetLastError ()
    .如果结束
    
    CloseHandle (hFile)
    ' 最后无论如何要关闭文件;
    .如果真 (iRet ≠ 1) ' 如果不等于1,证明步骤失败;要删除对应的文件.不然会剩下一个空文件;
        删除文件 (文件路径)
    .如果真结束
    返回 (iRet)

.子程序 文件_取格式, 整数型, 公开, 0=exe/dll；1=e/e局_项数组；3=rar；4=zip；5=7z；6=jpg；7=gif；8=swf；失败返回-1
    .参数 文件字节集, 字节集, , 可以用读入文件获取文件字节集
    .参数 返回文本格式, 文本型, 参考 可空, 可留空；装载文本格式的变量；如是exe格式的直接返回exe,失败返回空文本
    .局部变量 局_文件字节集, 字节集

    局_文件字节集 ＝ 取字节集右边 (文件字节集, 30)
    .判断开始 (寻找字节集 (局_文件字节集, 到字节集 (“MZ”), ) ≠ -1)
        返回文本格式 ＝ “exe/dll”
        返回 (0)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“CNWTEPRG”), ) ≠ -1)
        返回文本格式 ＝ “e/ec”
        返回 (1)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“Rar”), ) ≠ -1)
        返回文本格式 ＝ “rar”
        返回 (3)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“PK”), ) ≠ -1)
        返回文本格式 ＝ “zip”
        返回 (4)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“7z”), ) ≠ -1)
        返回文本格式 ＝ “7z”
        返回 (5)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“Content-Type: image/jpeg”), ) ≠ -1)
        返回文本格式 ＝ “jpg”
        返回 (6)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“GIF89a”), ) ≠ -1)
        返回文本格式 ＝ “gif”
        返回 (7)
    .判断 (寻找字节集 (局_文件字节集, 到字节集 (“FWS”), ) ≠ -1)
        返回文本格式 ＝ “swf”
        返回 (8)
    .默认
        
    .判断结束
    返回 (-1)
    
    

.子程序 文件_复制, 逻辑型, 公开, 成功返回真，失败返回假。本命令为初级命令
    .参数 被复制文件名, 文本型, , 被复制文件名
    .参数 复制到文件名, 文本型, , 复制到文件名
    .参数 是否覆盖, 整数型, 可空, 可空。默认为直接覆盖。0=覆盖，非0不覆盖

    返回 (CopyFileA (被复制文件名, 复制到文件名, 是否覆盖))

.子程序 文件_取时间, 逻辑型, 公开, 返回文件的创建时间、修改时间、访问时间；
    .参数 文件名, 文本型
    .参数 创建时间, 文本型, 参考 可空, 存放创建时间的变量
    .参数 最后修改时间, 文本型, 参考 可空, 存放修改时间的变量
    .参数 最后访问时间, 文本型, 参考 可空, 存放访问时间的变量
    .局部变量 局_文件句柄, 整数型
    .局部变量 局_逻辑返回值, 逻辑型
    .局部变量 局_创建utc时间, 文件时间
    .局部变量 局_访问utc时间, 文件时间
    .局部变量 局_修改utc时间, 文件时间
    .局部变量 局_创建本地时间, 文件时间
    .局部变量 局_访问本地时间, 文件时间
    .局部变量 局_修改本地时间, 文件时间
    .局部变量 局_创建系统时间, 精易_时间
    .局部变量 局_访问系统时间, 精易_时间
    .局部变量 局_修改系统时间, 精易_时间
    .局部变量 日期, 文本型
    .局部变量 时间, 文本型

    局_文件句柄 ＝ CreateFileA (文件名, 2147483648, 1, 0, 3, 0, 0)
    .如果真 (局_文件句柄 ≠ -1)
        局_逻辑返回值 ＝ GetFileTime (局_文件句柄, 局_创建utc时间, 局_访问utc时间, 局_修改utc时间)
        FileTimeToLocalFileTime (局_创建utc时间, 局_创建本地时间)
        FileTimeToLocalFileTime (局_访问utc时间, 局_访问本地时间)
        FileTimeToLocalFileTime (局_修改utc时间, 局_修改本地时间)
        
        FileTimeToSystemTime (局_创建本地时间, 局_创建系统时间)
        FileTimeToSystemTime (局_访问本地时间, 局_访问系统时间)
        FileTimeToSystemTime (局_修改本地时间, 局_修改系统时间)
        
        日期 ＝ 取空白文本 (255)
        时间 ＝ 取空白文本 (255)
        GetDateFormatA (0, 0, 局_创建系统时间, “yyyy-MM-dd”, 日期, 取文本长度 (日期))
        GetTimeFormatA (0, 0, 局_创建系统时间, “HH:mm:ss”, 时间, 取文本长度 (时间))
        创建时间 ＝ 日期 ＋ “ ” ＋ 时间
        
        日期 ＝ 取空白文本 (255)
        时间 ＝ 取空白文本 (255)
        GetDateFormatA (0, 0, 局_访问系统时间, “yyyy-MM-dd”, 日期, 取文本长度 (日期))
        GetTimeFormatA (0, 0, 局_访问系统时间, “HH:mm:ss”, 时间, 取文本长度 (时间))
        .如果 (时间 ＝ “00:00:00”)
            时间 ＝ “”
        .否则
            
        .如果结束
        最后访问时间 ＝ 日期 ＋ “ ” ＋ 时间
        
        日期 ＝ 取空白文本 (255)
        时间 ＝ 取空白文本 (255)
        GetDateFormatA (0, 0, 局_修改系统时间, “yyyy-MM-dd”, 日期, 取文本长度 (日期))
        GetTimeFormatA (0, 0, 局_修改系统时间, “HH:mm:ss”, 时间, 取文本长度 (时间))
        最后修改时间 ＝ 日期 ＋ “ ” ＋ 时间
        
        CloseHandle (局_文件句柄)
        返回 (局_逻辑返回值)
    .如果真结束
    返回 (假)

.子程序 文件_置时间, 逻辑型, 公开, 修改文件的创建时间、修改时间、访问时间；成功返回真，失败返回假
    .参数 文件名, 文本型
    .参数 创建时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .参数 最后修改时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .参数 最后访问时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .局部变量 局_文件句柄, 整数型
    .局部变量 局_逻辑返回值, 逻辑型
    .局部变量 局_创建utc时间, 文件时间
    .局部变量 局_访问utc时间, 文件时间
    .局部变量 局_修改utc时间, 文件时间
    .局部变量 局_创建本地时间, 文件时间
    .局部变量 局_访问本地时间, 文件时间
    .局部变量 局_修改本地时间, 文件时间
    .局部变量 局_创建系统时间, 精易_时间
    .局部变量 局_访问系统时间, 精易_时间
    .局部变量 局_修改系统时间, 精易_时间
    .局部变量 局_创建时间1, 日期时间型
    .局部变量 局_访问时间1, 日期时间型
    .局部变量 局_修改时间1, 日期时间型
    .局部变量 现行时间, 精易_时间
    .局部变量 现行时间1, 文件时间
    .局部变量 现行时间2, 文件时间

    局_创建时间1 ＝ 到时间 (创建时间)
    局_修改时间1 ＝ 到时间 (最后修改时间)
    局_访问时间1 ＝ 到时间 (最后访问时间)
    .判断开始 (到文本 (局_创建时间1) ≠ “100年1月1日”)
        局_创建系统时间.年 ＝ 取年份 (局_创建时间1)
        局_创建系统时间.月 ＝ 取月份 (局_创建时间1)
        局_创建系统时间.日 ＝ 取日 (局_创建时间1)
        局_创建系统时间.时 ＝ 取小时 (局_创建时间1)
        局_创建系统时间.分 ＝ 取分钟 (局_创建时间1)
        局_创建系统时间.秒 ＝ 取秒 (局_创建时间1)
        
        SystemTimeToFileTime (局_创建系统时间, 局_创建本地时间)
        LocalFileTimeToFileTime (局_创建本地时间, 局_创建utc时间) ' 将本地文件时间转移为UTC文件时间
    .默认
        
    .判断结束
    .判断开始 (到文本 (局_访问时间1) ≠ “100年1月1日”)
        局_访问系统时间.年 ＝ 取年份 (局_访问时间1)
        局_访问系统时间.月 ＝ 取月份 (局_访问时间1)
        局_访问系统时间.日 ＝ 取日 (局_访问时间1)
        局_访问系统时间.时 ＝ 取小时 (局_访问时间1)
        局_访问系统时间.分 ＝ 取分钟 (局_访问时间1)
        局_访问系统时间.秒 ＝ 取秒 (局_访问时间1)
        SystemTimeToFileTime (局_访问系统时间, 局_访问本地时间)
        LocalFileTimeToFileTime (局_访问本地时间, 局_访问utc时间) ' 将本地文件时间转移为UTC文件时间
    .默认
        
    .判断结束
    .判断开始 (到文本 (局_修改时间1) ≠ “100年1月1日”)
        局_修改系统时间.年 ＝ 取年份 (局_修改时间1)
        局_修改系统时间.月 ＝ 取月份 (局_修改时间1)
        局_修改系统时间.日 ＝ 取日 (局_修改时间1)
        局_修改系统时间.时 ＝ 取小时 (局_修改时间1)
        局_修改系统时间.分 ＝ 取分钟 (局_修改时间1)
        局_修改系统时间.秒 ＝ 取秒 (局_修改时间1)
        SystemTimeToFileTime (局_修改系统时间, 局_修改本地时间)
        LocalFileTimeToFileTime (局_修改本地时间, 局_修改utc时间) ' 将本地文件时间转移为UTC文件时间
    .默认
        
    .判断结束
    局_文件句柄 ＝ CreateFileA (文件名, 1073741824, 2, 0, 3, 0, 0)
    .如果真 (局_文件句柄 ＝ -1)
        返回 (假)
    .如果真结束
    局_逻辑返回值 ＝ SetFileTime (局_文件句柄, 局_创建utc时间, 局_访问utc时间, 局_修改utc时间)
    CloseHandle (局_文件句柄)
    返回 (局_逻辑返回值)

.子程序 文件_取扩展名, 文本型, 公开, 返回一个文件的后缀名,如：.jpg  如果没有后缀,返回空
    .参数 文件名, 文本型, , 需要处理的原始文件名

    返回 (PathFindExtensionA (文件名))

.子程序 文件_去扩展名, 逻辑型, 公开, 改变一个文件的后缀名,如果没有后缀,将自动加上新后缀,返回新文件名
    .参数 原始文件名, 文本型, , 需要处理的原始文件名
    .局部变量 新文件名, 文本型
    .局部变量 是否成功, 逻辑型

    新文件名 ＝ 取文本左边 (原始文件名, 倒找文本 (原始文件名, “.”, , 假) － 1)
    是否成功 ＝ 写到文件 (新文件名, 读入文件 (原始文件名))
    文件_删除 (原始文件名)
    返回 (是否成功)

.子程序 文件_改扩展名, 逻辑型, 公开, 改变一个文件的后缀名,成功返回真，失败返回假。
    .参数 原始文件名, 文本型, , 需要处理的原始文件名
    .参数 新扩展名, 文本型, , 后缀必须包含"."，如“.rar”,否则失败。
    .局部变量 NewPath, 文本型
    .局部变量 suffix, 文本型

    NewPath ＝ 原始文件名
    suffix ＝ PathFindExtensionA (新扩展名)
    .如果真 (取文本长度 (suffix) ＞ 1)
        PathRenameExtensionA (NewPath, suffix)
        返回 (文件_改名 (原始文件名, NewPath))
    .如果真结束
    返回 (假)

.子程序 文件_合并文件, , 公开, 将两个文件进行合并,生成一个新的文件
    .参数 合并文件名, 文本型, , 前一个文件名,最后生成的文件名也是它.
    .参数 被合并文件名, 文本型, , 要追加的文件名.
    .参数 生成文件名, 文本型, 可空, 如果空,以第一个文件名为准

    .判断开始 (是否为空 (生成文件名))
        写到文件 (合并文件名, 读入文件 (合并文件名) ＋ 读入文件 (被合并文件名))
    .默认
        写到文件 (生成文件名, 读入文件 (合并文件名) ＋ 读入文件 (被合并文件名))
    .判断结束
    

.子程序 文件_是否存在, 逻辑型, 公开, 判断指定的文件是否存在
    .参数 文件名, 文本型, , 文件全路径

    返回 (PathFileExistsA (文件名) ＝ 1)

.子程序 文件_取文件名, 文本型, 公开, 如：局_项数组:\123.exe 成功返回123
    .参数 路径文件名, 文本型, , 文件完整地址
    .参数 是否带后缀, 逻辑型, 可空, 默认为假，不带后缀；真为带后缀
    .局部变量 局_文件名, 文本型

    局_文件名 ＝ PathFindFileName (路径文件名)
    .如果真 (取文本右边 (局_文件名, 1) ＝ “\”)
        ' 取出来了一个\,这表示不正确，返回空
        返回 (“”)
    .如果真结束
    
    返回 (选择 (是否带后缀, 局_文件名, 取文本左边 (局_文件名, 取文本长度 (局_文件名) － 取文本长度 (文件_取扩展名 (局_文件名)))))

.子程序 文件_移动, 逻辑型, 公开, 移动指定文件到指定的文件位置
    .参数 欲移动的文件名, 文本型, , 欲移动的文件名
    .参数 移动到的文件名, 文本型, , 移动到的文件名

    返回 (MoveFileA (欲移动的文件名, 移动到的文件名))

.子程序 文件_搜索, , 公开, 可以设置显示标签和自动加入到列表框,可以当成枚举文件命令
    .参数 欲寻找的目录, 文本型, , 如：C:,表示C盘,记得C字后面两点一定要写，目录不以\结尾会自动添加
    .参数 加入的列表框, 列表框
    .参数 文件类型, 文本型, 可空, 可空：默认为*.*,也就是全部类型。 如填 *.txt只找txt类型的文件
    .参数 文件名包含的关键字, 文本型, 可空, 搜索文件名中 包含的关键字。如： 精易论坛.exe 只需要 精易就可以了
    .参数 显示标签, 标签, 可空, 用来显示搜索路径的标签
    .参数 是否带路径, 逻辑型, 可空, 默认为假； 真=带目录路径，如C:\012.txt； 假=不带，如 012.txt；
    .局部变量 局_子目录, 文本型
    .局部变量 局_文件名, 文本型
    .局部变量 LabelDisplay, 逻辑型, , ,  
    .局部变量 Keyword, 逻辑型
    .局部变量 ListBoxDisplay, 逻辑型

    欲寻找的目录 ＝ 选择 (取文本右边 (欲寻找的目录, 1) ≠ “\”, 欲寻找的目录 ＋ “\”, 欲寻找的目录)
    文件类型 ＝ 选择 (是否为空 (文件类型), “*.*”, 文件类型)
    Keyword ＝ 选择 (是否为空 (文件名包含的关键字), 假, 真)
    LabelDisplay ＝ 选择 (是否为空 (显示标签), 假, 真)
    
    局_文件名 ＝ 寻找文件 (欲寻找的目录 ＋ 文件类型, )
    
    .判断循环首 (局_文件名 ≠ “”)
        .如果真 (LabelDisplay)
            显示标签.标题 ＝ 欲寻找的目录 ＋ 局_文件名
            显示标签.刷新显示 ()
        .如果真结束
        .判断开始 (Keyword ＝ 假)
            .判断开始 (是否带路径)
                加入的列表框.加入项目 (欲寻找的目录 ＋ 局_文件名, )
            .默认
                加入的列表框.加入项目 (局_文件名, )
            .判断结束
            
        .判断 (寻找文本 (到小写 (局_文件名), 到小写 (文件名包含的关键字), , 假) ≠ -1)
            .判断开始 (是否带路径)
                加入的列表框.加入项目 (欲寻找的目录 ＋ 局_文件名, )
            .默认
                加入的列表框.加入项目 (局_文件名, )
            .判断结束
            
        .默认
            
        .判断结束
        
        处理事件 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    
    局_子目录 ＝ 寻找文件 (欲寻找的目录 ＋ “*.*”, #子目录)
    .判断循环首 (局_子目录 ≠ “”)
        .如果真 (取文本左边 (局_子目录, 1) ≠ “.”)
            .判断开始 (LabelDisplay)
                文件_搜索 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 加入的列表框, 文件类型, 文件名包含的关键字, 显示标签, 是否带路径)
            .默认
                文件_搜索 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 加入的列表框, 文件类型, 文件名包含的关键字, , 是否带路径)
            .判断结束
            处理事件 ()
        .如果真结束
        局_子目录 ＝ 寻找文件 (, #子目录)
        处理事件 ()
    .判断循环尾 ()

.子程序 文件_搜索1, , 公开, 搜索指定的文件路径中的指定后缀的文件并加入到列表框中  在一个子程序中多次调用此命令需清除文件数组后再调用
    .参数 欲寻找的目录, 文本型, , 如：C:,表示C盘,记得C字后面两点一定要写
    .参数 欲寻找的文件名, 文本型, , 如果寻找全部文件可以填入*.*或*.txt只找txt文件
    .参数 加入的列表框, 列表框, 可空, 把搜到的加到列表框中
    .参数 是否带路径, 逻辑型, 可空, 默认为假； 真=带目录路径，如C:\012.txt； 假=不带，如 012.txt；
    .参数 文件数组, 文本型, 可空 数组
    .局部变量 局_子目录, 文本型
    .局部变量 局_文件名, 文本型

    .如果真 (取文本右边 (欲寻找的目录, 1) ≠ “\”)
        欲寻找的目录 ＝ 欲寻找的目录 ＋ “\”
    .如果真结束
    局_文件名 ＝ 寻找文件 (欲寻找的目录 ＋ 欲寻找的文件名, )
    .判断循环首 (局_文件名 ≠ “”)
        .如果 (是否为空 (加入的列表框) ＝ 假)
            .判断开始 (是否带路径 ＝ 真)
                加入的列表框.加入项目 (欲寻找的目录 ＋ 局_文件名, )
                加入成员 (文件数组, 欲寻找的目录 ＋ 局_文件名)
            .默认
                加入的列表框.加入项目 (局_文件名, )
                加入成员 (文件数组, 局_文件名)
            .判断结束
            
        .否则
            .判断开始 (是否带路径 ＝ 真)
                加入成员 (文件数组, 欲寻找的目录 ＋ 局_文件名)
            .默认
                加入成员 (文件数组, 局_文件名)
            .判断结束
            
        .如果结束
        处理事件 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    局_子目录 ＝ 寻找文件 (欲寻找的目录 ＋ “*.*”, #子目录)
    .判断循环首 (局_子目录 ≠ “”)
        .如果真 (取文本左边 (局_子目录, 1) ≠ “.”)
            处理事件 ()
            .如果 (是否为空 (加入的列表框) ＝ 假)
                文件_搜索1 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 欲寻找的文件名, 加入的列表框, 是否带路径, 文件数组)
            .否则
                文件_搜索1 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 欲寻找的文件名, , 是否带路径, 文件数组)
            .如果结束
            
        .如果真结束
        局_子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    

.子程序 文件_搜索_深度, , 公开, 无返回值，可以根据目录深度进行回调搜索，从而提高运行效率。
    .参数 欲寻找的目录, 文本型, , 如：C:,表示C盘,记得C字后面两点一定要写，目录不以\结尾会自动添加
    .参数 装载函数, 子程序指针, , 需要一个参数接收回调，名称为;文件路径[文本型].
    .参数 文件类型, 文本型, 可空, 可空：默认为*.*,也就是全部类型。 如填 *.txt只找txt类型的文件
    .参数 目录深度, , 可空, 可空：默认为-1，即不限制目录深度。
    .局部变量 局_文件, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_路径, 文本型

    处理事件 ()
    欲寻找的目录 ＝ 选择 (取文本右边 (欲寻找的目录, 1) ≠ “\”, 欲寻找的目录 ＋ “\”, 欲寻找的目录)
    .如果真 (是否为空 (文件类型))
        文件类型 ＝ “*.*”
    .如果真结束
    .如果真 (是否为空 (目录深度))
        目录深度 ＝ -1
    .如果真结束
    局_文件 ＝ 寻找文件 (欲寻找的目录 ＋ 文件类型, )
    .判断循环首 (局_文件 ≠ “”)
        局_路径 ＝ 欲寻找的目录 ＋ 局_文件
        程序_Call (到整数 (装载函数), lstrcpyn_文本型 (局_路径, 局_路径, 0))
        局_文件 ＝ 寻找文件 (, )
    .判断循环尾 ()
    局_文件 ＝ 寻找文件 (欲寻找的目录 ＋ “*.*”, 16) ' #子目录
    .判断循环首 (局_文件 ≠ “”)
        .如果真 (局_文件 ≠ “.” 且 局_文件 ≠ “..”)
            局_数组 ＝ 分割文本 (欲寻找的目录 ＋ 局_文件, “\”, )
            .如果 (目录深度 ＝ -1)
                文件_搜索_深度 (欲寻找的目录 ＋ 局_文件, 装载函数, 文件类型, 目录深度)
            .否则
                .如果真 (取数组成员数 (局_数组) ＜ 目录深度 ＋ 1)
                    文件_搜索_深度 (欲寻找的目录 ＋ 局_文件, 装载函数, 文件类型, 目录深度)
                .如果真结束
                
            .如果结束
            
        .如果真结束
        局_文件 ＝ 寻找文件 (, 16) ' #子目录
    .判断循环尾 ()

.子程序 文件_枚举, 整数型, 公开, 枚举某个目录下的指定类型文件；成功返回文件数量；
    .参数 欲寻找的目录, 文本型, , 文件目录
    .参数 欲寻找的文件名, 文本型, , 如果寻找全部文件可以填入*.*，或*.txt只找txt文件
    .参数 文件数组, 文本型, 参考 可空 数组, 用于装载文件数组的变量；把寻找到的文件都放在这个数组里，并返回；
    .参数 是否带路径, 逻辑型, 可空, 默认为假； 真=带目录路径，如C:\012.txt； 假=不带，如 012.txt；
    .参数 是否按字母排序, 逻辑型, 可空, 默认为假；真=按字母a-z排序  假=不排序
    .参数 是否遍历子目录, 逻辑型, 可空, 留空默认为假；为真时文件数组不主动清空
    .局部变量 局_文件名, 文本型
    .局部变量 局_目录, 文本型

    .如果真 (是否遍历子目录 ＝ 假)
        清除数组 (文件数组)
    .如果真结束
    局_目录 ＝ 欲寻找的目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    局_文件名 ＝ 寻找文件 (局_目录 ＋ 欲寻找的文件名, )
    .判断循环首 (局_文件名 ≠ “”)
        .如果真 (是否带路径)
            局_文件名 ＝ 局_目录 ＋ 局_文件名
        .如果真结束
        加入成员 (文件数组, 局_文件名)
        系统_处理事件1 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    .如果真 (是否按字母排序)
        数组_排序 (文件数组, 0, )
    .如果真结束
    .如果真 (是否遍历子目录)
        局_文件名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
        .判断循环首 (局_文件名 ≠ “”)
            .如果真 (局_文件名 ≠ “.” 且 局_文件名 ≠ “..”)
                文件_枚举 (局_目录 ＋ 局_文件名, 欲寻找的文件名, 文件数组, 是否带路径, 是否按字母排序, 是否遍历子目录)
                系统_处理事件1 ()
            .如果真结束
            局_文件名 ＝ 寻找文件 (, #子目录)
        .判断循环尾 ()
    .如果真结束
    返回 (取数组成员数 (文件数组))

.子程序 文件_枚举1, , 公开, 如提供搜索目录路径，将会搜索此目录所有在内的文件。
    .参数 目录, 文本型, , 目录，如“D:\”盘，目录不以\结尾会自动添加
    .参数 拓展名, 文本型, , “*.exe”
    .参数 装载函数, 子程序指针, , 二个参数，1=目录【文本型】；2=文件名【文本型】
    .局部变量 文本, 文本型
    .局部变量 文件夹, 文本型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 目录
    .如果真 (取文本右边 (目录, 1) ≠ “\”)
        局_目录 ＝ 目录 ＋ “\”
    .如果真结束
    文本 ＝ 寻找文件 (局_目录 ＋ 拓展名, )
    .判断循环首 (文本 ≠ “”)
        程序_Call (到整数 (装载函数), lstrcpyn_文本型 (局_目录, 局_目录, 0), lstrcpyn_文本型 (文本, 文本, 0))
        文本 ＝ 寻找文件 (, )
    .判断循环尾 ()
    文本 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    .判断循环首 (文本 ≠ “”)
        .如果真 (取文本左边 (文本, 1) ≠ “.”)
            文本 ＝ 局_目录 ＋ 文本
            文件_枚举1 (文本, 拓展名, 装载函数)
        .如果真结束
        文本 ＝ 寻找文件 (, #子目录)
        系统_处理事件1 ()
    .判断循环尾 ()

.子程序 文件_删除, 逻辑型, 公开, 删除指定路径的文件
    .参数 欲删除的文件名, 文本型, , 欲删除的文件名

    返回 (DeleteFileA (欲删除的文件名))

.子程序 文件_删除到回收站, 逻辑型, 公开, 将指定文件删除到回收站,成功返回真,失败返回假[V雪落有声V]
    .参数 欲删除的文件名, 文本型, , 欲删除的全路径文件名
    .参数 删除方式选项, 整数型, 可空, 1: 不询问删除;  2: 不提示错误;  4: 不显示进度。如果被省略，默认值为 0 。
    .局部变量 类型, SHFILEOPSTRUCT
    .局部变量 返回值, 整数型

    类型.wFunc ＝ 3
    类型.pFrom ＝ 到字节集 (欲删除的文件名) ＋ { 0, 0 }
    类型.fFlags ＝ 64
    .如果真 (位与 (1, 删除方式选项) ＝ 1)
        类型.fFlags ＝ 类型.fFlags ＋ 16
    .如果真结束
    .如果真 (位与 (2, 删除方式选项) ＝ 2)
        类型.fFlags ＝ 类型.fFlags ＋ 1024
    .如果真结束
    .如果真 (位与 (4, 删除方式选项) ＝ 4)
        类型.fFlags ＝ 类型.fFlags ＋ 4
    .如果真结束
    返回值 ＝ SHFileOperationA (类型)
    .如果真 (返回值 ＝ 0 且 类型.fAnyOperationsAborted ＝ 0)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 文件_删除配置节, , 公开, 删除指定配置文件中的节
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .局部变量 a, 文本型, , "2"
    .局部变量 b, 整数型, , "2"

    .如果真 (文件是否存在 (配置文件名))
        a [1] ＝ 到文本 (读入文件 (配置文件名))
        b [1] ＝ 寻找文本 (a [1], “[” ＋ 节名称 ＋ “]”, , 假)
        .如果真 (b [1] ＞ -1)
            b [2] ＝ 寻找文本 (a [1], “[”, b [1] ＋ 取文本长度 (节名称) ＋ 1, 假)
            .如果真 (b [2] ＝ -1)
                b [2] ＝ 取文本长度 (a [1])
            .如果真结束
            a [2] ＝ 取文本左边 (a [1], b [1] － 1) ＋ 取文本右边 (a [1], 取文本长度 (a [1]) － b [2] ＋ 1)
            写到文件 (配置文件名, 到字节集 (a [2]))
        .如果真结束
        
    .如果真结束
    

.子程序 文件_删除配置项, , 公开, 删除指定配置文件中的项
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .局部变量 a, 文本型, , "2"
    .局部变量 b, 整数型, , "3"

    .如果真 (文件是否存在 (配置文件名))
        写配置项 (配置文件名, 节名称, 配置项名称, “Mark2928198601074334”)
        a [1] ＝ 到文本 (读入文件 (配置文件名))
        b [2] ＝ 寻找文本 (a [1], “Mark2928198601074334”, 1, 假)
        b [1] ＝ 倒找文本 (a [1], #换行符, b [2], 假)
        b [3] ＝ 寻找文本 (a [1], #换行符, b [2], 假)
        .如果真 (b [3] ＝ -1)
            b [3] ＝ 取文本长度 (a [1])
        .如果真结束
        a [2] ＝ 取文本左边 (a [1], b [1]) ＋ 取文本右边 (a [1], 取文本长度 (a [1]) － b [3])
        写到文件 (配置文件名, 到字节集 (a [2]))
    .如果真结束
    

.子程序 文件_取路径盘符, 文本型, 公开, 如 局_项数组:001\002\01\0104.txt返回 局_项数组:
    .参数 文件或目录名, 文本型
    .局部变量 SFO, 对象

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        返回 (SFO.读文本属性 (“GetDriveName”, 文件或目录名))
    .如果真结束
    CoUninitialize ()
    返回 (“”)

.子程序 文件_到短文件名, 文本型, 公开, 返回短文件名
    .参数 文件名, 文本型
    .局部变量 局_短路径, 文本型

    局_短路径 ＝ 取空白文本 (255)
    GetShortPathNameA (文件名, 局_短路径, 取文本长度 (文件名))
    .如果真 (删首尾空 (局_短路径) ≠ “”)
        返回 (局_短路径)
    .如果真结束
    返回 (文件名)

.子程序 文件_到长文件名, 文本型, 公开, 返回长文件名
    .参数 文件名, 文本型
    .局部变量 局_长路径, 文本型
    .局部变量 局_长度, 整数型

    局_长度 ＝ GetLongPathNameA (文件名, 局_长路径, 0)
    局_长路径 ＝ 取空白文本 (局_长度)
    GetLongPathNameA (文件名, 局_长路径, 局_长度)
    .如果真 (删首尾空 (局_长路径) ≠ “”)
        返回 (局_长路径)
    .如果真结束
    返回 (文件名)

.子程序 文件_改名, 逻辑型, 公开, 重新命名一个文件。成功返回真，失败返回假。本命令为初级命令。
    .参数 文件名, 文本型, , 文件名
    .参数 新文件名, 文本型, , 新文件名

    .如果真 (文件_路径是否规范 (新文件名) ＝ 假)
        输出调试文本 (“文件_改名 - 新文件名不规范，使用不规范的文件名会导致文件被删除。请更改参数[新文件名]”)
        返回 (假)
    .如果真结束
    返回 (文件更名 (文件名, 新文件名))

.子程序 文件_删除某类文件, 整数型, 公开, 支持通配符删除，写法如：删除文件("局_项数组:\","*.*")返回删除文件总数(有些文件由于某种原因可能未被删除)
    .参数 目录名, 文本型, , 最后不带"\",但可自动加上.
    .参数 扩展名, 文本型, , 如"*.BAT"或“ABC*.INI"，可以使用多字符 (*) 和单字符 (?) 通配符
    .参数 是否包含子目录, 逻辑型, 可空, 默认为假，不包含；真，包含。
    .参数 参_删除数量, 整数型, 可空, 此参数没用的,无需填写参数,否则返回的成功删除数量将不准确
    .局部变量 文件名, 文本型
    .局部变量 删除数量, 整数型

    删除数量 ＝ 参_删除数量
    .如果真 (寻找文本 (扩展名, “.”, , 假) ＝ -1)
        提示框J (“扩展名有错,请返回检查,格式请看参数说明”)
        返回 (0)
    .如果真结束
    .如果真 (取文本右边 (目录名, 1) ≠ “\”)
        目录名 ＝ 目录名 ＋ “\”
    .如果真结束
    文件名 ＝ 寻找文件 (目录名 ＋ 扩展名, )
    .判断循环首 (文件名 ≠ “”)
        .如果真 (删除文件 (目录名 ＋ 文件名))
            删除数量 ＝ 删除数量 ＋ 1
        .如果真结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    .如果真 (是否包含子目录)
        文件名 ＝ 寻找文件 (目录名 ＋ “*.*”, #子目录)
        .判断循环首 (文件名 ≠ “”)
            .如果真 (取文本左边 (文件名, 1) ≠ “.”)
                删除数量 ＝ 文件_删除某类文件 (目录名 ＋ 文件名, 扩展名, 是否包含子目录, 删除数量)
            .如果真结束
            文件名 ＝ 寻找文件 (, #子目录)
        .判断循环尾 ()
    .如果真结束
    返回 (删除数量)

.子程序 文件_后缀是否关联, 整数型, 公开, 判断指定后缀名是否被关联(未关联返回-1 关联文件不存在返回0 已经关联返回1)
    .参数 后缀, 文本型, , 欲判断是否已经关联的后缀 ( 如 html )
    .局部变量 路径, 文本型
    .局部变量 a, 整数型
    .局部变量 b, 整数型

    .如果真 (注册项是否存在 (1, “.” ＋ 后缀 ＋ “\”) ＝ 假)
        返回 (-1)
    .如果真结束
    路径 ＝ 取文本注册项 (1, 取文本注册项 (1, “.” ＋ 后缀 ＋ “\”, ) ＋ “\Shell\Open\Command\”, )
    a ＝ 寻找文本 (路径, #引号, , 假)
    .如果 (a ＝ -1)
        a ＝ 寻找文本 (路径, “ ”, , 假)
        .如果真 (a ≠ -1)
            路径 ＝ 取文本左边 (路径, a － 1)
        .如果真结束
        
    .否则
        b ＝ 寻找文本 (路径, #引号, a ＋ 1, 假)
        路径 ＝ 取文本中间 (路径, a ＋ 1, b － a － 1)
    .如果结束
    .如果真 (文件是否存在 (路径) ＝ 假)
        返回 (0)
    .如果真结束
    返回 (1)

.子程序 文件_创建文件目录, 逻辑型, 公开, 根据一个文件名创建出该文件名所包含的所有目录
    .参数 文件名, 文本型, , 完整路径的文件名
    .局部变量 文本, 文本型
    .局部变量 次数, 整数型

    .如果真 (取文本中间 (文件名, 2, 1) ≠ “:”)
        返回 (假)
    .如果真结束
    .判断循环首 (寻找文本 (文件名, “\”, 次数 ＋ 1, 假) ≠ -1)
        次数 ＝ 寻找文本 (文件名, “\”, 次数 ＋ 1, 假)
        文本 ＝ 取文本左边 (文件名, 次数)
        创建目录 (文本)
    .判断循环尾 ()
    返回 (真)

.子程序 文件_取配置节名数组, , 公开, 返回节名数组
    .参数 配置文件名, 文本型
    .参数 节名数组, 文本型, 参考 数组
    .局部变量 a, 文本型, , "2"
    .局部变量 b, 整数型

    .如果 (取反 (文件是否存在 (配置文件名)))
        
    .否则
        b ＝ 打开文件 (配置文件名, #读入, #无限制)
        .判断循环首 (取反 (是否在文件尾 (b, 真)))
            a [1] ＝ 读入一行 (b)
            .如果真 (取文本左边 (a [1], 1) ＝ “[” 且 文本比较 (取文本左边 (a [1], 寻找文本 (a [1], “]”, 1, 真)), “[”, 假) ＞ 0)
                .如果 (a [2] ≠ “”)
                    a [2] ＝ a [2] ＋ “|” ＋ 取文本中间 (a [1], 2, 寻找文本 (a [1], “]”, 1, 真) － 2)
                .否则
                    a [2] ＝ 取文本中间 (a [1], 2, 寻找文本 (a [1], “]”, 1, 真) － 2)
                .如果结束
                
            .如果真结束
            
        .判断循环尾 ()
        关闭文件 (b)
        节名数组 ＝ 分割文本 (a [2], “|”, )
    .如果结束
    

.子程序 文件_取MP3播放时间, 文本型, 公开, Mp3文件的全曲时间,仅支持MP3文件,如果文件不存在，将返回空
    .参数 文件名, 文本型
    .参数 类型, 整数型, 可空, 0；总长度  1；分+秒  2；秒
    .局部变量 局部_缓冲文本, 文本型
    .局部变量 局部_整理路径, 文本型
    .局部变量 局部_长度_秒, 整数型
    .局部变量 局部_长度_分, 整数型
    .局部变量 局部_时长, 文本型

    局部_缓冲文本 ＝ 取空白文本 (128)
    局部_整理路径 ＝ 取空白文本 (256)
    GetShortPathNameA (文件名, 局部_整理路径, 取文本长度 (局部_整理路径))
    mciSendStringA (“open ” ＋ #引号 ＋ 局部_整理路径 ＋ #引号 ＋ “ Alias movie notify”, 局部_缓冲文本, 取文本长度 (局部_缓冲文本), 0) ' Alias movie parent %u Style %u notify
    局部_缓冲文本 ＝ 取空白文本 (128)
    mciSendStringA (“status movie length”, 局部_缓冲文本, 取文本长度 (局部_缓冲文本), 0)
    局部_长度_秒 ＝ 到数值 (局部_缓冲文本) ÷ 1000
    局部_长度_分 ＝ 到整数 (局部_长度_秒 ÷ 60)
    局部_时长 ＝ 文本_自动补零 (到文本 (局部_长度_分), 2) ＋ “:” ＋ 文本_自动补零 (到文本 (局部_长度_秒 － 到数值 (局部_长度_分 × 60)), 2)
    mciSendStringA (“close all”, 字符 (0), 0, #NULL)
    .判断开始 (类型 ＝ 1)
        返回 (局部_时长)
    .判断 (类型 ＝ 2)
        返回 (到文本 (到整数 (局部_长度_秒)))
    .默认
        返回 (局部_缓冲文本)
    .判断结束
    

.子程序 文件_取配置项名数组, 整数型, 公开, 返回指定配置文件中指定的节中所有的配置名称，以“|”为分界，如果配置文件不存在或配置文件中指定节为空将返回空文本
    .参数 配置文件名, 文本型
    .参数 节名名称, 文本型
    .参数 项名数组, 文本型, 参考 数组
    .局部变量 局_源数据, 文本型
    .局部变量 局_节名位置, 整数型
    .局部变量 局_位置, 整数型
    .局部变量 局_项数据, 文本型
    .局部变量 局_项名数据, 文本型
    .局部变量 局_项数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_终止数, 双精度小数型

    .如果 (取反 (文件是否存在 (配置文件名)))
        返回 (0)
    .否则
        局_源数据 ＝ 到文本 (读入文件 (配置文件名))
        局_节名位置 ＝ 寻找文本 (局_源数据, “[” ＋ 节名名称 ＋ “]”, , 假)
        .如果真 (局_节名位置 ＞ -1)
            局_位置 ＝ 寻找文本 (局_源数据, “[”, 局_节名位置 ＋ 取文本长度 (节名名称) ＋ 1, 假)
            .如果真 (局_位置 ＝ -1)
                局_位置 ＝ 取文本长度 (局_源数据)
            .如果真结束
            局_项数据 ＝ 取文本中间 (局_源数据, 局_节名位置 ＋ 取文本长度 (节名名称) ＋ 4, 局_位置 － 局_节名位置 － 取文本长度 (节名名称) － 4)
            .如果真 (寻找文本 (局_项数据, “=”, , 假) ＞ -1)
                局_项数组 ＝ 分割文本 (局_项数据, “=”, )
                .如果 (倒找文本 (局_项数组 [1], #换行符, , 真) ＞ -1)
                    局_项名数据 ＝ 取文本右边 (局_项数组 [1], 取文本长度 (局_项数组 [1]) － 倒找文本 (局_项数组 [1], #换行符, , 真) － 1)
                .否则
                    局_项名数据 ＝ 局_项数组 [1]
                .如果结束
                
                .如果 (取文本右边 (局_源数据, 2) ＝ #换行符)
                    局_终止数 ＝ 取数组成员数 (局_项数组) － 1
                .否则
                    局_终止数 ＝ 取数组成员数 (局_项数组)
                .如果结束
                
                
                .变量循环首 (2, 局_终止数, 1, i)
                    局_项名数据 ＝ 局_项名数据 ＋ “|” ＋ 取文本右边 (局_项数组 [i], 取文本长度 (局_项数组 [i]) － 倒找文本 (局_项数组 [i], #换行符, , 真) － 1)
                .变量循环尾 ()
            .如果真结束
            
        .如果真结束
        项名数组 ＝ 分割文本 (局_项名数据, “|”, )
    .如果结束
    返回 (取数组成员数 (项名数组))

.子程序 文件_取配置项名数组1, 整数型, 公开, 返回指定配置文件中所有已有节名的文本数组。本命令为初级命令。
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .参数 返回的配置项名数组, 文本型, 数组
    .局部变量 sbuffer, 字节集
    .局部变量 Array, 字节集, , "0"
    .局部变量 Lenth
    .局部变量 count
    .局部变量 i
    .局部变量 text, 文本型
    .局部变量 len

    清除数组 (返回的配置项名数组)
    sbuffer ＝ 字节集_取空白字节集 (32767)
    Lenth ＝ GetPrivateProfileSection (节名称, sbuffer, 32767, 配置文件名)
    sbuffer ＝ 取字节集左边 (sbuffer, Lenth)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    .计次循环首 (取数组成员数 (Array), i)
        text ＝ 到文本 (Array [i])
        len ＝ 寻找文本 (text, “=”, , 假)
        .如果真 (len ≠ -1)
            text ＝ 取文本左边 (text, len － 1)
        .如果真结束
        加入成员 (返回的配置项名数组, text)
    .计次循环尾 ()
    返回 (取数组成员数 (Array))

.子程序 文件_取文本编码, 整数型, 公开, 获取指定路径的txt文档的编码格式。成功返回（1：UTF-8，2：Unicode；3：Unicode big endian；4：ANSI），默认返回 4。
    .参数 参_文件路径, 文本型
    .局部变量 局_文件内容, 字节集
    .局部变量 局_文件长度, 整数型
    .局部变量 局_lpiResult, 整数型

    ' https://bbs.125.la/thread-14471247-1-1.html
    局_文件内容 ＝ 读入文件 (参_文件路径)
    局_文件长度 ＝ 取字节集长度 (局_文件内容)
    .判断开始 (局_文件长度 ＞ 2 且 取字节集中间 (局_文件内容, 1, 2) ＝ { 239, 187 }) ' UTF-8
        .如果真 (取字节集中间 (局_文件内容, 3, 1) ＝ { 191 })
            返回 (1)
        .如果真结束
        
    .判断 (取字节集中间 (局_文件内容, 1, 2) ＝ { 255, 254 }) ' Unicode
        返回 (2)
    .判断 (取字节集中间 (局_文件内容, 1, 2) ＝ { 254, 255 }) ' Unicode big endian
        返回 (3)
    .默认
        
    .判断结束
    局_lpiResult ＝ -1
    .判断开始 (IsTextUnicode (局_文件内容, 局_文件长度, 局_lpiResult)) ' Unicode
        返回 (2)
    .判断 (文本_是否UTF8_汇编 (局_文件内容)) ' UTF-8
        返回 (1)
    .默认
        返回 (4) ' ANSI
    .判断结束
    

.子程序 分割符, , , '————————————————————————————————————————————————————————————
    

.子程序 目录_取文件数, 整数型, 公开, 使用FileSystemObje局_项数组t取目录文件数,适合有大量文件的目录
    .参数 参_目录名, 文本型
    .局部变量 FSO, 对象
    .局部变量 GetFolder, 对象
    .局部变量 getfile, 对象
    .局部变量 SubFolders, 对象
    .局部变量 局_返回, 整数型

    CoInitialize (0)
    FSO.创建 (“Scripting.FileSystemObject”, )
    GetFolder ＝ FSO.对象型方法 (“GetFolder”, 参_目录名)
    getfile ＝ GetFolder.读对象型属性 (“Files”, )
    局_返回 ＝ getfile.读数值属性 (“count”, )
    CoUninitialize ()
    返回 (局_返回)

.子程序 目录_删除自身_cmd, , 公开, 利用CMD命令删除自身
    置文件属性 (取运行目录 () ＋ “\” ＋ 取执行文件名 (), 0)
    运行 (“cmd.exe /c del ” ＋ #引号 ＋ 取运行目录 () ＋ “\” ＋ 取执行文件名 () ＋ #引号, 假, #隐藏窗口)
    结束 ()

.子程序 目录_复制文件_cmd, , 公开, 利用CMD命令复制文件
    .参数 要复制的文件名, 文本型
    .参数 复制到的目录名, 文本型

    要复制的文件名 ＝ #引号 ＋ 要复制的文件名 ＋ #引号
    复制到的目录名 ＝ #引号 ＋ 复制到的目录名 ＋ #引号
    运行 (“cmd.exe /c copy /y ” ＋ 要复制的文件名 ＋ “ ” ＋ 复制到的目录名, 假, #隐藏窗口)

.子程序 目录_移动文件_cmd, , 公开, 利用CMD命令移动文件
    .参数 要移动的文件名, 文本型
    .参数 移动到的目录名, 文本型

    要移动的文件名 ＝ #引号 ＋ 要移动的文件名 ＋ #引号
    移动到的目录名 ＝ #引号 ＋ 移动到的目录名 ＋ #引号
    运行 (“cmd.exe /c move /y ” ＋ 要移动的文件名 ＋ “ ” ＋ 移动到的目录名, 假, #隐藏窗口)

.子程序 目录_移动并运行_cmd, , 公开
    .参数 要移动的文件名, 文本型
    .参数 移动到的目录名, 文本型
    .局部变量 临时文本, 文本型
    .局部变量 临时文件名, 文本型

    临时文件名 ＝ 文件_取文件名 (要移动的文件名)
    临时文本 ＝ #移动并运行bat
    临时文本 ＝ 子文本替换 (临时文本, “被移动文件”, 要移动的文件名, , , 真)
    临时文本 ＝ 子文本替换 (临时文本, “目录”, 移动到的目录名, , , 真)
    临时文本 ＝ 子文本替换 (临时文本, “要运行的文件”, 临时文件名, , , 真)
    写到文件 (取运行目录 () ＋ “\123.bat”, 到字节集 (到文本 (临时文本)))
    运行 (取运行目录 () ＋ “\123.bat”, 假, 1)

.子程序 目录_定位, 逻辑型, 公开, 成功则打开文件所在目录并选中文件，失败返回假,本命令为初级命令！
    .参数 文件路径, 文本型, , 需提供文件绝对路径
    .参数 编辑模式, 逻辑型, 可空, 重命名模式。
    .局部变量 lngPidl, 整数型
    .局部变量 lngRet, 整数型
    .局部变量 strFile, 文本型
    .局部变量 返回值, 逻辑型

    .如果真 (文件_是否存在 (文件路径) ＝ 假)
        返回 (假)
    .如果真结束
    lngPidl ＝ SHCreateFromPath (文件路径)
    .如果真 (lngPidl ＝ 0)
        返回 (假)
    .如果真结束
    lngRet ＝ SHOpenFolderAndSelectItems (lngPidl, 0, 0, 选择 (编辑模式, 1, 0))
    SHFree (lngRet)
    返回 (lngRet ＝ 0)

.子程序 目录_改名, 逻辑型, 公开, 重新命名一个目录名称。成功返回真，失败返回假。本命令为初级命令。
    .参数 目录名, 文本型, , 目录名
    .参数 新目录名, 文本型, , 新目录名

    返回 (文件更名 (目录名, 新目录名))

.子程序 目录_复制, , 公开, 复制目录到指定的路径
    .参数 源目录, 文本型, , 如：C:\001\002
    .参数 目标目录, 文本型, , 复制支：d:\2543\545
    .局部变量 SFO, 对象

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        SFO.方法 (“CopyFolder”, 源目录, 目标目录)
    .如果真结束
    CoUninitialize ()

.子程序 目录_浏览, 文本型, 公开, 浏览文件夹内支持创建文件夹 支持显示文件 编辑框 (返回被选择文件或文件夹路径)
    .参数 标题, 文本型, 可空, 设置标题
    .参数 显示文件, 逻辑型, 可空, 默认为假。
    .参数 初始目录, 文本型, 可空, 设置一个初始目录,默认为我的电脑
    .参数 地址栏, 逻辑型, 可空, 是否包含编辑框,可编辑,默认为假
    .参数 新样式, 逻辑型, 可空, 有新建按钮及右键菜单,默认为真
    .参数 父窗口句柄, 整数型, 可空
    .局部变量 BROWSEINFO, 精易_目录浏览
    .局部变量 文本, 文本型

    ' 就因为受不了操作系统支持库！
    标题 ＝ 选择 (是否为空 (标题), “请选择一个文件夹”, 标题)
    新样式 ＝ 选择 (是否为空 (新样式), 真, 新样式)
    显示文件 ＝ 选择 (是否为空 (显示文件), 假, 显示文件)
    BROWSEINFO.hOwner ＝ 父窗口句柄
    BROWSEINFO.lpszTitle ＝ 标题
    BROWSEINFO.lpfn ＝ &回调函数
    BROWSEINFO.ulFlags ＝ 位或 (选择 (地址栏, 16, 0), 选择 (新样式, 64, 0), 选择 (显示文件, 16384, 0))
    文本 ＝ 取空白文本 (512)
    集_目录 ＝ 初始目录
    SHGetPathFromIDListA (SHBrowseForFolderA (BROWSEINFO), 文本)
    文本 ＝ 删首尾空 (文本)
    返回 (文本)

.子程序 回调函数, 整数型, , 浏览文件夹
    .参数 hDlg, 整数型
    .参数 uMsg, 整数型
    .参数 lParam, 整数型
    .参数 lp___Data, 整数型

    .如果真 (uMsg ＝ 1)
        SendMessageA (hDlg, 1126, 1, 取指针文本_ (集_目录))
    .如果真结束
    返回 (1)

.子程序 目录_取父路径, 文本型, 公开, 返回指定文件或目录的上一级目录路径；路径后面包含\
    .参数 文件或目录名, 文本型, , 如：C:\001\002\0.txt则返回C:\001\002\；
    .局部变量 局_位置, 整数型
    .局部变量 局_文本, 文本型

    局_文本 ＝ 文件或目录名
    .如果真 (取文本右边 (局_文本, 1) ＝ “\”)
        局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 1)
    .如果真结束
    局_位置 ＝ 倒找文本 (局_文本, “\”, , 假)
    返回 (取文本左边 (局_文本, 局_位置))

.子程序 目录_取大小, 长整数型, 公开, 取一个文件夹的大小；单位为字节型, 失败返回-1。
    .参数 目录名路径, 文本型, , 如：D:\Program Files
    .局部变量 SFO, 对象
    .局部变量 长度, 变体型
    .局部变量 对象1, 对象
    .局部变量 Length, 长整数型

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        对象1 ＝ SFO.对象型方法 (“GetFolder”, 目录名路径)
        长度 ＝ 对象1.读属性 (“Size”, )
        Length ＝ 到长整数 (长度.取数值 ())
        CoUninitialize ()
        返回 (Length)
    .如果真结束
    返回 (-1)

.子程序 目录_更新, , 公开, 把某个目录下的所有文件复制到另一个目录里
    .参数 源目录, 文本型, , 源目录，目录不以\结尾会自动添加
    .参数 目标目录, 文本型, 可空, 目标目录，目录不以\结尾会自动添加
    .参数 是否覆盖文件, 整数型, 可空, 可空。默认为直接覆盖。0=覆盖，非0不覆盖
    .局部变量 局_子目录, 文本型
    .局部变量 局_文件名, 文本型
    .局部变量 局_旧目录, 文本型
    .局部变量 局_新目录, 文本型

    局_旧目录 ＝ 源目录
    局_新目录 ＝ 目标目录
    .如果真 (取文本右边 (局_旧目录, 1) ≠ “\”)
        局_旧目录 ＝ 局_旧目录 ＋ “\”
    .如果真结束
    .如果真 (取文本右边 (局_新目录, 1) ≠ “\”)
        局_新目录 ＝ 局_新目录 ＋ “\”
    .如果真结束
    .如果真 (目录_是否存在 (局_新目录) ＝ 假)
        目录_创建 (局_新目录)
    .如果真结束
    
    局_文件名 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, )
    .判断循环首 (局_文件名 ≠ “”)
        文件_复制 (局_旧目录 ＋ 局_文件名, 局_新目录 ＋ 局_文件名, 是否覆盖文件)
        处理事件 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    局_子目录 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, #子目录)
    .判断循环首 (局_子目录 ≠ “”)
        .如果真 (取文本左边 (局_子目录, 1) ≠ “.”)
            处理事件 ()
            目录_更新 (局_旧目录 ＋ 局_子目录, 局_新目录 ＋ 局_子目录)
        .如果真结束
        局_子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()

.子程序 目录_同步更新, , 公开, 将目标目录的文件和源目录中的文件进行对比，将不同的文件同步到目标目录里。
    .参数 源目录, 文本型, , 源目录，目录不以\结尾会自动添加
    .参数 目标目录, 文本型, , 欲更新目标的目录，目录不以\结尾会自动添加
    .局部变量 文件名, 文本型
    .局部变量 子目录, 文本型
    .局部变量 局_旧目录, 文本型
    .局部变量 局_新目录, 文本型

    局_旧目录 ＝ 源目录
    局_新目录 ＝ 目标目录
    .如果真 (取文本右边 (局_旧目录, 1) ≠ “\”)
        局_旧目录 ＝ 局_旧目录 ＋ “\”
    .如果真结束
    .如果真 (取文本右边 (局_新目录, 1) ≠ “\”)
        局_新目录 ＝ 局_新目录 ＋ “\”
    .如果真结束
    创建目录 (局_新目录)
    处理事件 ()
    文件名 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, 39)
    .判断循环首 (文件名 ≠ “”)
        .判断开始 (文件_是否存在 (局_新目录 ＋ 文件名) ＝ 假) ' 不存在
            文件_复制 (局_旧目录 ＋ 文件名, 局_新目录 ＋ 文件名)
        .判断 (校验_取md5 (读入文件 (局_新目录 ＋ 文件名)) ≠ 校验_取md5 (读入文件 (局_旧目录 ＋ 文件名)))
            文件_复制 (局_旧目录 ＋ 文件名, 局_新目录 ＋ 文件名, 0)
        .默认
            
        .判断结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    子目录 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, 16)
    .判断循环首 (子目录 ≠ “”)
        .如果真 (子目录 ≠ “.” 且 子目录 ≠ “..”)
            .如果 (目录_是否存在 (局_新目录 ＋ 子目录))
                目录_同步更新 (局_旧目录 ＋ 子目录, 局_新目录 ＋ 子目录)
            .否则
                删除目录 (局_新目录 ＋ 子目录)
            .如果结束
            
        .如果真结束
        子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    

.子程序 目录_创建, 逻辑型, 公开, 创建多级目录，成功返回真，失败返回假。如果指定目录存在也会返回真，不覆盖目录内容。
    .参数 目录路径, 文本型
    .局部变量 m_Path, 文本型

    m_Path ＝ 选择 (取文本右边 (目录路径, 1) ≠ “\”, 目录路径 ＋ “\”, 目录路径)
    返回 (MakeSureDirectoryPathExists (m_Path))

.子程序 目录_清空, , 公开, 删除指定目录下所有文件，子目录或子目录下的文件不会被删除；
    .参数 要删除文件的目录, 文本型, , 如：删除D:\Program Files(也就是Program Files)目录下的全部文件，目录不以\结尾会自动添加
    .参数 文件类型, 文本型, 可空, 默认为清空所有文件；或者清空指定格式(*.txt或*.exe)等等；
    .局部变量 局_目录, 文本型
    .局部变量 局_文件类型, 文本型
    .局部变量 临时_文件名数组, 文本型, , "0"
    .局部变量 i, 整数型

    局_目录 ＝ 要删除文件的目录
    局_文件类型 ＝ 文件类型
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    .如果真 (局_文件类型 ＝ “”)
        局_文件类型 ＝ “*.*”
    .如果真结束
    
    .如果真 (目录_是否符合规范 (局_目录, 真) ＝ 假)
        输出调试文本 (“目录_清空 - 传入的目录不合规范，这样会导致不可预料的情况甚至格盘！请重新提供符合规范的目录路径！注意：不可以直接使用磁盘根目录！”)
        返回 ()
    .如果真结束
    .如果真 (目录_是否存在 (局_目录) ＝ 假)
        输出调试文本 (“该目录不存在，请检查路径后重试”)
        返回 ()
    .如果真结束
    
    .计次循环首 (文件_枚举 (局_目录, 局_文件类型, 临时_文件名数组, 真), i)
        ' 默认不包含子目录，所以不会删除子目录及其中的文件。
        文件_删除到回收站 (临时_文件名数组 [i], 1)
    .计次循环尾 ()

.子程序 目录_强力清空, , 公开, 删除指定目录下所有文件，包括文件夹
    .参数 要删除文件的目录, 文本型, , 如：删除D:\Program Files(也就是Program Files)目录下的全部文件；，目录不以\结尾会自动添加
    .局部变量 局_目录, 文本型

    局_目录 ＝ 要删除文件的目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    
    .如果真 (目录_是否符合规范 (局_目录, 真) ＝ 假)
        输出调试文本 (“目录_强力清空 - 传入的目录不合规范，这样会导致不可预料的情况甚至格盘！请重新提供符合规范的目录路径！注意：不可以直接使用磁盘根目录！”)
        返回 ()
    .如果真结束
    .如果真 (目录_是否存在 (局_目录) ＝ 假)
        输出调试文本 (“该目录不存在，请检查路径后重试”)
        返回 ()
    .如果真结束
    删除目录 (局_目录)
    目录_创建 (局_目录)

.子程序 目录_是否存在, 逻辑型, 公开, 输入一个目录名,判断此目录是否存在
    .参数 欲判断的目录名, 文本型, , 传入的目录名不会被改变

    返回 (PathIsDirectoryA (欲判断的目录名) ＝ 16)

.子程序 目录_是否存在W, 逻辑型, 公开, 判断路径是否存在
    .参数 欲判断的目录名称, 字节集, , 要判断的路径

    返回 (PathIsDirectoryW (欲判断的目录名称))

.子程序 目录_取特定目录, 文本型, 公开, 例子：目录_取特定目录 (#我的文档) 或 目录_取特定目录 (1) 等。本命令返回指定的Windows系统特定目录，所返回目录名以“\”符号结束，如失败返回空文本。本命令为初级命令。
    .参数 类型, , 可空, 留空为桌面； 1: #我的文档;  2: #我的收藏夹;  3: #系统桌面;  4: #系统字体;  5: #开始菜单组;  6: #程序菜单组;  7: #启动菜单组;  8: #程序数据目录;  9: #Windows安装目录;  10: #Windows系统目录;  11: #临时文件目录;  12:系统缓存目录
    .局部变量 临时文本, 文本型
    .局部变量 blOK, 逻辑型
    .局部变量 常数, 整数型
    .局部变量 文本指针, 整数型

    临时文本 ＝ 取空白文本 (260)
    .如果真 (类型 ＝ 0)
        类型 ＝ 3
    .如果真结束
    .判断开始 (类型 ≥ 1 且 类型 ≤ 8)
        常数 ＝ 多项选择 (类型, 5, 6, 16, 20, 11, 2, 7, 26)
        .如果真 (SHGetSpecialFolderPath (0, 临时文本, 常数, 假))
            blOK ＝ 真
        .如果真结束
        
    .判断 (类型 ＝ 9)
        blOK ＝ GetWindowsDirectoryA (临时文本, 260) ＞ 0
    .判断 (类型 ＝ 10)
        blOK ＝ GetSystemDirectoryA (临时文本, 260) ＞ 0
    .判断 (类型 ＝ 11)
        blOK ＝ GetTempPathA (260, 临时文本) ＞ 0
    .判断 (类型 ＝ 12)
        .如果真 (SHGetSpecialFolderPath (0, 临时文本, 32, 假))
            blOK ＝ 真
        .如果真结束
        
    .默认
        
    .判断结束
    .如果真 (blOK)
        .如果真 (取文本右边 (临时文本, 1) ≠ “\”)
            临时文本 ＝ 临时文本 ＋ “\”
        .如果真结束
        返回 (临时文本)
    .如果真结束
    返回 (“”)

.子程序 目录_取特定目录EX, 文本型, 公开, 1 AppDat局_项名数据 2 IE临时目录  3 局_项数组DBurning  4 局_项数组ookies  5 桌面  6 收藏夹  7 字体  8 历史记录  9 Lo局_项数组alAppDat局_项名数据 10 Lo局_项数组alSettings  11 我的音乐  12 我的图片  13 我的视频  14 NetHood  15 我的文档  16 PrintHood  17 开始_程序  18 我最近的文档  19 发送到  20 开始菜单  21 启动文件夹  22 Templates  23 所有用户_管理工具  24 所有用户_AppDat局_项名数据 25 所有用户_桌面  26 所有用户_文档  27 所有用户_收藏夹  28 所有用户_开始_程序  29 所有用户_开始菜单  30 所有用户_启动文件夹  31 所有用户_Templates  32 所有用户_音乐  33 所有用户_图片  34 所有用户_视频  35 临时目录  36 安装目录  37 系统目录  38 用户目录  39 所有用户  40 程序文件  41 所有用户_程序文件  42 系统盘  43 软件安装目录
    .参数 选择类型, 整数型, 可空, [beineimao]
    .局部变量 文本1, 文本型
    .局部变量 类型, 文本型, , "0"
    .局部变量 i, 整数型

    加入成员 (类型, “AppData”)
    加入成员 (类型, “Cache”)
    加入成员 (类型, “CD Burning”)
    加入成员 (类型, “Cookies”)
    加入成员 (类型, “Desktop”)
    加入成员 (类型, “Favorites”)
    加入成员 (类型, “Fonts”)
    加入成员 (类型, “History”)
    加入成员 (类型, “Local AppData”)
    加入成员 (类型, “Local Settings”)
    加入成员 (类型, “My Music”)
    加入成员 (类型, “My Pictures”)
    加入成员 (类型, “My Video”)
    加入成员 (类型, “NetHood”)
    加入成员 (类型, “Personal”)
    加入成员 (类型, “PrintHood”)
    加入成员 (类型, “Programs”)
    加入成员 (类型, “Recent”)
    加入成员 (类型, “SendTo”)
    加入成员 (类型, “Start Menu”)
    加入成员 (类型, “Startup”)
    加入成员 (类型, “Templates”)
    加入成员 (类型, “Common Administrative Tools”)
    加入成员 (类型, “Common AppData”)
    加入成员 (类型, “Common Desktop”)
    加入成员 (类型, “Common Documents”)
    加入成员 (类型, “Common Favorites”)
    加入成员 (类型, “Common Programs”)
    加入成员 (类型, “Common Start Menu”)
    加入成员 (类型, “Common Startup”)
    加入成员 (类型, “Common Templates”)
    加入成员 (类型, “CommonMusic”)
    加入成员 (类型, “CommonPictures”)
    加入成员 (类型, “CommonVideo”)
    加入成员 (类型, “Temp”)
    加入成员 (类型, “WinDir”)
    加入成员 (类型, “System32”)
    加入成员 (类型, “USERPROFILE”)
    加入成员 (类型, “ALLUSERSPROFILE”)
    加入成员 (类型, “ProgramFiles”)
    加入成员 (类型, “CommonProgramFiles”)
    加入成员 (类型, “SystemDrive”)
    加入成员 (类型, “软件安装目录”)
    .如果真 (到小写 (类型 [选择类型]) ＝ “软件安装目录”)
        返回 (取运行目录 ())
    .如果真结束
    .如果真 (读环境变量 (到小写 (类型 [选择类型])) ≠ “”)
        返回 (读环境变量 (到小写 (类型 [选择类型])))
    .如果真结束
    .如果真 (到小写 (类型 [选择类型]) ＝ 到小写 (“System32”))
        返回 (取文本左边 (读环境变量 (“ComSpec”), 倒找文本 (读环境变量 (“ComSpec”), “\”, , 假) － 1))
    .如果真结束
    返回 (取文本注册项 (选择 (到小写 (取文本左边 (到小写 (类型 [选择类型]), 6)) ＝ “common”, #本地机器, #现行用户), “Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\” ＋ 到小写 (类型 [选择类型]), ))

.子程序 目录_取子目录数, 整数型, 公开, 取一个文件夹下面的子目录数量；失败返回-1
    .参数 父文件夹路径, 文本型
    .局部变量 SFO, 对象
    .局部变量 Folder, 对象
    .局部变量 对象, 对象
    .局部变量 局_数量, 整数型

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        Folder ＝ SFO.对象型方法 (“GetFolder”, 父文件夹路径)
        对象 ＝ Folder.读对象型属性 (“SubFolders”, )
        局_数量 ＝ 对象.读数值属性 (“Count”, )
        SFO.清除 ()
        CoUninitialize ()
        返回 (局_数量)
    .如果真结束
    返回 (-1)

.子程序 目录_枚举子目录, 整数型, 公开, 取一个文件夹下级子目录；成功返回子目录数量，失败返回0；
    .参数 父文件夹路径, 文本型, , 如：D:\Program Files；目录分割符请用\，路径不以\结尾会自动添加
    .参数 子目录数组, 文本型, 参考 可空 数组, 用来装载返回的子目录路径；
    .参数 是否带路径, 逻辑型, 可空, 假=不带，真=带;
    .参数 是否按字母排序, 逻辑型, 可空, 默认为假；真=按字母a-z排序  假=不排序
    .局部变量 子目录名, 文本型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 父文件夹路径
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    子目录名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    .判断循环首 (子目录名 ≠ “”)
        .如果真 (取文本左边 (子目录名, 1) ≠ “.”)
            .如果 (是否带路径 ＝ 假)
                加入成员 (子目录数组, 子目录名)
            .否则
                加入成员 (子目录数组, 局_目录 ＋ 子目录名)
            .如果结束
            
        .如果真结束
        
        子目录名 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    .如果真 (是否按字母排序)
        数组_排序 (子目录数组, 0, )
    .如果真结束
    
    返回 (取数组成员数 (子目录数组))

.子程序 目录_枚举子目录1, 整数型, 公开, 取一个文件夹下级子目录；成功返回子目录数量，失败返回0；通过是否枚举子目录参数，可以枚举所有的子目录
    .参数 父文件夹路径, 文本型, , 如：D:\Program Files；目录分割符请用\，路径不以\结尾会自动添加
    .参数 子目录数组, 文本型, 参考 可空 数组, 用来装载返回的子目录路径；
    .参数 是否带路径, 逻辑型, 可空, 可为空默认为真,假=不带，真=带;
    .参数 是否继续向下枚举, 逻辑型, 可空, 为空，默认不枚举。
    .局部变量 子目录名, 文本型
    .局部变量 本级子目录列表, 文本型, , "0"
    .局部变量 目录计数器, 整数型
    .局部变量 目录总数, 整数型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 父文件夹路径
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    子目录名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    是否带路径 ＝ 选择 (是否为空 (是否带路径), 真, 是否带路径)
    .判断循环首 (子目录名 ≠ “”)
        .如果真 (取文本左边 (子目录名, 1) ≠ “.”)
            加入成员 (本级子目录列表, 子目录名)
            .如果 (是否带路径)
                加入成员 (子目录数组, 局_目录 ＋ 子目录名)
            .否则
                加入成员 (子目录数组, 子目录名)
            .如果结束
            
        .如果真结束
        处理事件 ()
        子目录名 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    目录总数 ＝ 取数组成员数 (本级子目录列表)
    .如果真 (是否继续向下枚举)
        .计次循环首 (取数组成员数 (本级子目录列表), 目录计数器)
            .如果真 (目录_是否有子目录 (局_目录 ＋ 本级子目录列表 [目录计数器]))
                目录总数 ＝ 目录总数 ＋ 目录_枚举子目录1 (局_目录 ＋ 本级子目录列表 [目录计数器], 子目录数组, 是否带路径, 是否继续向下枚举)
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    返回 (目录总数)

.子程序 目录_取创建时间, 日期时间型, 公开, 返回创建的时间；
    .参数 目录名, 文本型, 可空
    .局部变量 SFO, 对象
    .局部变量 对象1, 对象
    .局部变量 日期, 日期时间型

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        对象1 ＝ SFO.对象型方法 (“GetFolder”, 目录名)
        日期 ＝ 对象1.读日期属性 (“DateCreated”, )
        CoUninitialize ()
    .如果真结束
    返回 (日期)

.子程序 目录_是否为空, 逻辑型, 公开, 如果为空返回真，否则返回假
    .参数 欲判断的目录路径, 文本型

    返回 (PathIsDirectoryEmptyA (欲判断的目录路径))
    

.子程序 目录_是否有子目录, 逻辑型, 公开, 判断一个目录下有无下级子目录
    .参数 当前目录, 文本型, , 目录不以\结尾会自动添加
    .局部变量 文件名, 文本型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 当前目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    文件名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    .判断循环首 (文件名 ≠ “”)
        .如果真 (文件名 ≠ “” 且 文件名 ≠ “.” 且 文件名 ≠ “..”)
            返回 (真)
        .如果真结束
        文件名 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    返回 (假)

.子程序 目录_设置系统属性, 逻辑型, 公开, 成功返回真，失败返回假； 给一个文件夹正确的属性，成为一个系统文件夹
    .参数 目录名, 文本型

    .判断开始 (目录名 ≠ “”)
        .判断开始 (PathMakeSystemFolderA (目录名) ≠ 0)
            返回 (真)
        .默认
            返回 (假)
        .判断结束
        
    .默认
        返回 (假)
    .判断结束
    

.子程序 目录_取消系统属性, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 目录名, 文本型

    .判断开始 (目录名 ≠ “”)
        .判断开始 (PathUnmakeSystemFolderA (目录名) ≠ 0)
            返回 (真)
        .默认
            返回 (假)
        .判断结束
        
    .默认
        返回 (假)
    .判断结束
    

.子程序 目录_检查系统属性, 逻辑型, 公开, 有系统属性返回真，没有返回假；
    .参数 目录名, 文本型

    .判断开始 (目录名 ≠ “”)
        .判断开始 (PathIsSystemFolderA (目录名, 0) ≠ 0)
            返回 (真)
        .默认
            返回 (假)
        .判断结束
        
    .默认
        返回 (假)
    .判断结束
    

.子程序 目录_取Windows目录, 文本型, 公开, 如：局_项数组:\WINDOWS\
    .局部变量 局_文本, 文本型

    局_文本 ＝ 取空白文本 (255)
    GetWindowsDirectoryA (局_文本, 255)
    .如果真 (取文本右边 (局_文本, 1) ≠ “\”)
        局_文本 ＝ 局_文本 ＋ “\”
    .如果真结束
    返回 (局_文本)

.子程序 目录_取system32目录, 文本型, 公开, 如：局_项数组:\WINDOWS\system32\
    .局部变量 局_文本, 文本型

    局_文本 ＝ 取空白文本 (255)
    GetSystemDirectoryA (局_文本, 255)
    .如果真 (取文本右边 (局_文本, 1) ≠ “\”)
        局_文本 ＝ 局_文本 ＋ “\”
    .如果真结束
    返回 (局_文本)

.子程序 目录_取临时目录, 文本型, 公开, 取出Temp目录,如:局_项数组:\DO局_项数组UME~1\ADMINI~1\LO局_项数组ALS~1\Temp\
    .局部变量 目录名, 文本型

    目录名 ＝ 取空白文本 (255)
    GetTempPathA (255, 目录名)
    返回 (目录名)

.子程序 目录_取尾部目录名或文件名, 文本型, 公开, 如果是目录:局_项数组:\001\002则返回 002；  如果是文件:局_项数组:\001\002\0.txt则返回 0.txt
    .参数 文件或目录名, 文本型, , 如果参数尾部包含\,将会被去掉
    .局部变量 局_文件名, 文本型
    .局部变量 success

    局_文件名 ＝ 取空白文本 (256)
    success ＝ GetFileTitleA (文件或目录名, 局_文件名, 256)
    返回 (选择 (success ＝ 0, 局_文件名, “”))

.子程序 目录_取运行目录, 文本型, 公开,  取当前被执行的易程序文件所处的目录。
    .局部变量 局_缓冲区, 文本型
    .局部变量 局_返回值

    局_缓冲区 ＝ 取空白文本 (255)
    局_返回值 ＝ GetModuleFileNameExA (GetCurrentProcess (), 0, 局_缓冲区, 255)
    返回 (选择 (局_返回值 ＞ 0, 取文本左边 (局_缓冲区, 倒找文本 (局_缓冲区, “\”, , 假)), “”))

.子程序 目录_取当前目录, 文本型, 公开, 返回一个文本，用来代表当前的目录。如果失败，返回空文本。
    .局部变量 局_缓冲区, 文本型
    .局部变量 局_返回值

    局_缓冲区 ＝ 取空白文本 (256)
    局_返回值 ＝ GetCurrentDirectory (256, 局_缓冲区)
    返回 (选择 (局_返回值 ＞ 0, 删首尾空 (局_缓冲区), “”))

.子程序 目录_取桌面目录, 文本型, 公开, 获取系统桌面的路径
    返回 (目录_取特定目录 (3))

.子程序 目录_是否符合规范, 逻辑型, 公开, 【严格】检查目录是否合规范，不和规范的目录返回假。判断标准:盘符:\目录
    .参数 要检查的目录, 文本型, , 需要检查的完整的目录路径，不接受相对路径
    .参数 是否禁止为根目录, 逻辑型, 可空, 如果设置为真，如果是盘符根目录返回假。默认为真。
    .局部变量 临时_要检查的目录, 文本型
    .局部变量 盘符, 文本型
    .局部变量 盘符代码, 整数型
    .局部变量 返回逻辑, 逻辑型

    .局部变量 文件名, 文本型

    临时_要检查的目录 ＝ 要检查的目录
    .判断循环首 (寻找文本 (临时_要检查的目录, “\\”, , 假) ＞ 0)
        临时_要检查的目录 ＝ 子文本替换 (临时_要检查的目录, “\\”, “\”, , , 真)
    .判断循环尾 ()
    
    .判断循环首 (寻找文本 (临时_要检查的目录, “//”, , 假) ＞ 0)
        临时_要检查的目录 ＝ 子文本替换 (要检查的目录, “//”, “/”, , , 真)
    .判断循环尾 ()
    
    盘符 ＝ 到大写 (取文本左边 (临时_要检查的目录, 1))
    盘符代码 ＝ 取代码 (盘符, 1)
    .如果真 (盘符代码 ＜ 65 或 盘符代码 ＞ 90)
        ' 不是A-Z之间的，标识这不是一个正常的盘符。
        返回 (假)
    .如果真结束
    
    返回逻辑 ＝ 寻找文本 (临时_要检查的目录, “:\”, , 假) ≠ -1
    ' 表示没有":\",盘符后面的分隔符
    .如果真 (返回逻辑 ＝ 假)
        返回逻辑 ＝ 寻找文本 (临时_要检查的目录, “:/”, , 假) ≠ -1
        ' 同时要检查反斜杠。如果也没有，则返回不合法
        .如果真 (返回逻辑 ＝ 假)
            返回 (假)
        .如果真结束
        
    .如果真结束
    
    .如果真 (是否禁止为根目录)
        临时_要检查的目录 ＝ 子文本替换 (临时_要检查的目录, “\\”, “\”, , , 真)
        临时_要检查的目录 ＝ 子文本替换 (临时_要检查的目录, “//”, “/”, , , 真)
        .如果真 (取文本长度 (临时_要检查的目录) ＝ 3)
            ' D:\   只有根目录会等于3.
            返回 (假)
        .如果真结束
        
    .如果真结束
    
    返回 (真)

.子程序 文件_创建映射对象, 整数型, 公开, 成功返回映射对象句柄,失败返回0
    .参数 映射对象名, 文本型, , 映射对象名,可随意填写
    .参数 映射对象的值, 整数型, , 映射对象的值,为整数型
    .局部变量 局_映射句柄, 整数型
    .局部变量 局_视图地址, 整数型

    局_映射句柄 ＝ CreateFileMappingA (-1, 0, 4, 0, 4, 映射对象名) ' 4的整数倍-对齐
    局_视图地址 ＝ MapViewOfFile (局_映射句柄, 6, 0, 0, 0)
    RtlMoveMemory_Eint_int (局_视图地址, 映射对象的值, 4)
    ' _取消文件映射对象 (局_视图地址)
    返回 (局_视图地址)

.子程序 文件_读取映射对象, 整数型, 公开, 读取映射对象的值
    .参数 映射对象名, 文本型, , 用【文件_创建映射对象】命令分创建时的映射对象名
    .局部变量 局_映射句柄, 整数型
    .局部变量 局_视图地址, 整数型, 静态
    .局部变量 局_值, 整数型

    .如果真 (局_视图地址 ＝ 0)
        局_映射句柄 ＝ OpenFileMappingA (6, 0, 映射对象名)
        局_视图地址 ＝ MapViewOfFile (局_映射句柄, 6, 0, 0, 0)
    .如果真结束
    .如果真 (局_视图地址 ≠ 0)
        RtlMoveMemory_整数传址1 (局_值, 局_视图地址, 4)
    .如果真结束
    返回 (局_值)

.子程序 文件_句柄取路径, 文本型, 公开, 根据文件句柄获取文件所在路径，失败返回空文本。
    .参数 文件句柄
    .局部变量 Status
    .局部变量 isb, IO_STATUS_BLOCK
    .局部变量 fni, FILE_NAME_INFORMATION
    .局部变量 stFileInfo, BY_HANDLE_FILE_INFORMATION
    .局部变量 hMem
    .局部变量 NameLength
    .局部变量 Name, 文本型
    .局部变量 diskCount
    .局部变量 temp, 字节集
    .局部变量 i, 整数型
    .局部变量 disk, 文本型
    .局部变量 tmp, 字节集
    .局部变量 diskData, 字节集
    .局部变量 dwVolumeSerialNumber, 整数型

    .如果 (GetFileInformationByHandle (文件句柄, stFileInfo)) ' 根据句柄取文件信息，主要是取磁盘序列号
        diskData ＝ 取空白字节集 (256)
        diskCount ＝ GetLogicalDriveStringsA (256, diskData) ' 枚举逻辑磁盘
        .变量循环首 (0, diskCount ÷ 4 － 1, 1, i)
            disk ＝ 到文本 (取字节集中间 (diskData, 4 × i ＋ 1, 4))
            .如果真 (GetVolumeInformation (disk, 字符 (0), 0, dwVolumeSerialNumber, 0, 0, 字符 (0), 0)) ' 判断磁盘序列号是否与取出来的序列号相等。
                .如果真 (dwVolumeSerialNumber ＝ stFileInfo.dwVolumeSerialNumber)
                    跳出循环 ()
                .如果真结束
                
            .如果真结束
            处理事件 ()
        .变量循环尾 ()
        disk ＝ 取文本左边 (disk, 2)
    .否则
        返回 (“”)
    .如果结束
    hMem ＝ GlobalAlloc (64, 528)
    Status ＝ ZwQueryInformationFile (文件句柄, isb, hMem, 528, 9) ' #FileNameInformation取文件名称信息
    .如果真 (Status ＝ 0)
        NameLength ＝ 取字节集数据 (指针到字节集 (hMem, 4), #整数型, )
        Name ＝ 编码_Unicode到Ansi (指针到字节集 (hMem ＋ 4, NameLength))
    .如果真结束
    GlobalFree (hMem)
    返回 (disk ＋ Name)

.子程序 文件_取属性, 整数型, 公开, 返回一个文件或目录的属性。此属性值由以下常量或其和构成： 1、#只读文件； 2、#隐藏文件；  4、#系统文件； 16、#子目录；32、#存档文件 。要判断是否设置了某个属性，在返回值与想要得知的属性值之间使用“位与”命令进行比较。如果所得的结果不为零，则表示设置了这个属性值。如果取文件属性失败，将返回 -1。
    .参数 文件名, 文本型

    返回 (GetFileAttributes (文件名))

.子程序 文件_取类型, 文本型, 公开, 获取文件类型，如.exe文件，则返回“应用程序”，失败则返回空。
    .参数 文件路径, 文本型
    .局部变量 Fileinfo, SHFILEINFO

    线程_初始化COM库 ()
    SHGetFileInfo (文件路径, 0, Fileinfo, 348, 1024) ' #SHGFI_TYPENAME)
    线程_取消COM库 ()
    返回 (到文本 (Fileinfo.szTypeName))

.子程序 文件_取图标句柄, 整数型, 公开, 获取文件的图标句柄
    .参数 路径, 文本型
    .局部变量 sInfo, SHFILEINFO

    线程_初始化COM库 ()
    SHGetFileInfo (路径, 128, sInfo, 348, 256)
    线程_取消COM库 ()
    返回 (sInfo.hIcon)

.子程序 文件_路径是否规范, 逻辑型, 公开, 用于【严格】检查完整路径是否规范。检查规则：盘符:\目录名\二级目录名\文件名.文件后缀
    .参数 要检查的完整路径, 文本型
    .参数 是否不检查后缀, 逻辑型, 可空, 用于指定是否检查文件的后缀，如果为假，则忽略文件后缀。默认为真
    .局部变量 盘符, 文本型
    .局部变量 盘符代码, 整数型
    .局部变量 返回逻辑, 逻辑型

    .局部变量 文件名, 文本型

    .如果真 (是否为空 (是否不检查后缀))
        是否不检查后缀 ＝ 真
    .如果真结束
    盘符 ＝ 到大写 (取文本左边 (要检查的完整路径, 1))
    盘符代码 ＝ 取代码 (盘符, 1)
    .如果真 (盘符代码 ＜ 65 或 盘符代码 ＞ 90)
        ' 不是A-Z之间的，标识这不是一个正常的盘符。
        返回 (假)
    .如果真结束
    
    返回逻辑 ＝ 寻找文本 (要检查的完整路径, “:\”, , 假) ≠ -1
    ' 表示没有":\",盘符后面的分隔符
    .如果真 (返回逻辑 ＝ 假)
        返回逻辑 ＝ 寻找文本 (要检查的完整路径, “:/”, , 假) ≠ -1
        ' 同时要检查反斜杠。如果也没有，则返回不合法
        .如果真 (返回逻辑 ＝ 假)
            返回 (假)
        .如果真结束
        
    .如果真结束
    
    文件名 ＝ 文件_取文件名 (要检查的完整路径, 真)
    .如果真 (文件名 ＝ “”)
        返回 (假)
    .如果真结束
    
    .如果真 (内部_命名规则过滤 (文件名))
        返回 (假)
    .如果真结束
    
    .如果真 (是否不检查后缀 ＝ 假)
        盘符代码 ＝ 倒找文本 (文件名, “.”, , 假)
        返回 (盘符代码 ＞ 1 且 盘符代码 ＜ 取文本长度 (文件名))
        ' 还有一个情况，以.开头的文件名，所以要判断>1才可以
    .如果真结束
    
    返回 (文件名 ≠ “”)
    

.子程序 内部_命名规则过滤, 逻辑型
    .参数 文件名, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_计次, 整数型

    局_数组 ＝ { “?”, “/”, “\”, “<”, “>”, “*”, “|”, “:” }
    加入成员 (局_数组, #引号)
    .计次循环首 (9, 局_计次)
        .如果真 (寻找文本 (文件名, 局_数组 [局_计次], , 假) ≠ -1)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)
    

