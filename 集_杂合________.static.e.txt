.版本 2

.程序集 集_杂合________
.程序集变量 FLSAList, Stroks, , "0"

.子程序 ADD__, 整数型, , 加法指令 返回值=操作数1+操作数2+操作数3
    .参数 操作数1, 整数型
    .参数 操作数2, 整数型
    .参数 操作数3, 整数型, 可空

    ' 0045E3BF      8B45 0C       mov     eax, dword ptr [ebp+C]
    ' 0045E3C2      0345 10       add     eax, dword ptr [ebp+10]
    ' 0045E3C5      0145 08       add     dword ptr [ebp+8], eax
    ' 8B 45 0C 03 45 10 01 45 08
    置入代码 ({ 139, 69, 12, 3, 69, 16, 1, 69, 8 })
    返回 (操作数1)

.子程序 取字节集指针, 整数型
    .参数 参_字节集, 字节集, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 131, 248, 0, 116, 3, 131, 192, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 SUB__, 整数型, , 减法指令 返回值=操作数1-操作数2-操作数3
    .参数 操作数1, 整数型
    .参数 操作数2, 整数型
    .参数 操作数3, 整数型, 可空

    ' 0045E379      8B45 0C       mov     eax, dword ptr [ebp+C]
    ' 0045E37C      0345 10       add     eax, dword ptr [ebp+10]
    ' 0045E37F      2945 08       sub     dword ptr [ebp+8], eax
    ' 8B 45 0C 03 45 10 29 45 08
    置入代码 ({ 139, 69, 12, 3, 69, 16, 41, 69, 8 })
    返回 (操作数1)

.子程序 递增, 整数型, , 对提供的整数型变量值+1,注意:不支持字节型,短整数型,长整数型等的操作
    .参数 整数变量, 整数型, 参考, 此参数必须为整数型变量,会被+1保存回去.显示为符号整数型

    ' 0040113B    51              push    ecx
    ' 0040113C    B8 01000000     mov     eax, 1
    ' 00401141    8B4D 08         mov     ecx, dword ptr [ebp+8]
    ' 00401144    F0:0FC101       lock xadd dword ptr [ecx], eax
    ' 00401148    40              inc     eax
    ' 00401149    59              pop     ecx
    ' 0040114A    C9              leave
    ' 0040114B    C2 0400         retn    4
    ' 51 B8 01 00 00 00 8B 4D 08 F0 0F C1 01 40 59 C9 C2 04 00
    置入代码 ({ 81, 184, 1, 0, 0, 0, 139, 77, 8, 240, 15, 193, 1, 64, 89, 201, 194, 4, 0 })
    返回 (0)
    ' 004034A8    F0:FF00               lock inc dword ptr [eax]

.子程序 递减, 整数型, , 对提供的整数型变量值-1,注意:不支持字节型,短整数型,长整数型等的操作
    .参数 整数变量, 整数型, 参考, 此参数必须为整数型变量,会被-1保存回去.显示为符号整数型

    ' 0040113B    51              push    ecx
    ' 0040113C    B8 FFFFFFFF     mov     eax, -1
    ' 00401141    8B4D 08         mov     ecx, dword ptr [ebp+8]
    ' 00401144    F0:0FC101       lock xadd dword ptr [ecx], eax
    ' 00401148    48              dec     eax
    ' 00401149    59              pop     ecx
    ' 0040114A    C9              leave
    ' 0040114B    C2 0400         retn    4
    ' 51 B8 FF FF FF FF 8B 4D 08 F0 0F C1 01 48 59 C9 C2 04 00
    置入代码 ({ 81, 184, 255, 255, 255, 255, 139, 77, 8, 240, 15, 193, 1, 72, 89, 201, 194, 4, 0 })
    返回 (0)
    ' 004034A8    F0:FF08               lock dec dword ptr [eax]

.子程序 转换_转数据大小为标准显示, 文本型, 公开, '最高支持pb位 以科学的方式显示文件大小 不清楚在32位下的反应 注意返回虽然是kbtb什么的 但实际是kib mib 进制为1024 1000是标准的kb mb的进制位 KiB  一共四种 1Kb表示1000个bit 1Kib表示1024个bit 1KB表示1000个Byte字节 KiB表示1024个Byte字节
    .参数 b, 文本型, , ‘文本型的b大小 不是bit比特 是Byte字节 如取文件大小返回的就是byte
    .局部变量 小数文本, 双精度小数型
    .局部变量 预处理数, 双精度小数型

    ' 源码采纳地址：https://bbs.125.la/thread-14311769-1-1.html
    ' 1024=1kb
    ' 1048576=1mb
    ' 1073741824=1gb
    ' 1099511627776=1tb
    ' 1.1259e+15=1pb
    ' 1024  kb
    ' 1024*1024 mb
    ' 1024*1024*1024 gb
    ' 1024*1024*1024*1024 tb
    ' 1024*1024*1024*1024*1024 pb
    ' 1024*1024*1024*1024*1024*1024 eb
    ' 先判断是否大于 大于则按文本处理转换后返回
    .如果真 (取文本长度 (b) ＞ 19 或 到整数 (取文本左边 (b, 10)) ＞ 9223372036 或 到整数 (取文本右边 (b, 9)) ＞ 854775807) ' 超过小数最大尾数会出错 或处理结果超过最大长整数
        .如果 (取文本长度 (b) ＝ 19) ' 如果是19位但超过了最大长整数就除10处理 文本处理方式
            小数文本 ＝ 到数值 (取文本左边 (b, 18) ＋ “.” ＋ 取文本右边 (b, 1))
            预处理数 ＝ 小数文本 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024
            返回 (到文本 (四舍五入 (预处理数 × 10, 2)) ＋ “eb”)
        .否则
            小数文本 ＝ 到数值 (取文本左边 (b, 19) ＋ “.” ＋ 取文本右边 (b, 取文本长度 (b) － 19)) ' 转换到双精度小数型
            预处理数 ＝ 小数文本 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024
            .计次循环首 (取文本长度 (b) － 19, )
                预处理数 ＝ 预处理数 × 10
            .计次循环尾 ()
            返回 (到文本 (四舍五入 (预处理数, 2)) ＋ “eb”)
        .如果结束
        
    .如果真结束
    ' 正式按整数处理
    .如果真 (到长整数 (b) ＜ 1024) ' 小于这个则为  b
        返回 (b ＋ “b”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1048576) ' 小于这个则为  kb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024, 2)) ＋ “kb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1073741824) ' 小于这个则为 mb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024, 2)) ＋ “mb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1099511627776) ' 小于这个则为  gb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “gb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1.1259e+015) ' 小于这个则为  tb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “tb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1.1529e+018) ' 小于这个则为  pb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “pb”)
    .如果真结束
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “eb”)

.子程序 控制台_快速编辑模式, , 公开, 禁用快速编辑模式可以防止鼠标点击暂停控制台程序
    .参数 参_是否禁止, 逻辑型, 可空, 默认禁止
    .局部变量 局_句柄, 整数型
    .局部变量 局_标志值, 整数型

    局_句柄 ＝ GetStdHandle (-10)
    GetConsoleMode (局_句柄, 取变量地址_整数 (局_标志值))
    .如果真 (是否为空 (参_是否禁止))
        参_是否禁止 ＝ 真
    .如果真结束
    .如果 (参_是否禁止)
        局_标志值 ＝ 位与 (局_标志值, 位取反 (位与 (2147483647, 96)))
    .否则
        局_标志值 ＝ 位或 (局_标志值, 96)
    .如果结束
    SetConsoleMode (局_句柄, 局_标志值)
    

.子程序 取错误信息文本_API, 文本型, 公开, GetLastError
    .局部变量 局_错误值, 整数型
    .局部变量 局_错误信息文本, 文本型
    .局部变量 计数器, 整数型

    局_错误值 ＝ GetLastError ()
    局_错误信息文本 ＝ 取空白文本 (512)
    FormatMessageA (#FORMAT_MESSAGE_FROM_SYSTEM, #FORMAT_MESSAGE_IGNORE_INSERTS, 局_错误值, 0, 局_错误信息文本, 取文本长度 (局_错误信息文本), 0)
    返回 (“错误码:” ＋ 到文本 (局_错误值) ＋ “|” ＋ 删首尾空 (局_错误信息文本))

.子程序 类_取内部方法地址, 整数型, 公开, 返回方法地址，只能类内部使用
    .参数 方法序号, 整数型, , 方法序号,从1开始
    .局部变量 方法地址, 整数型

    方法地址 ＝ HeapAlloc (GetProcessHeap (), 0, 14)
    置入代码 ({ 139, 69, 0, 139, 64, 8, 139, 200, 139, 93, 8, 75, 107, 219, 4, 139, 0, 139, 0, 3, 195, 139, 24, 139, 69, 252, 102, 199, 0, 91, 184, 137, 88, 2, 198, 64, 6, 104, 137, 72, 7, 102, 199, 64, 11, 83, 255, 198, 64, 13, 224 })
    返回 (方法地址)

.子程序 类_释放内部方法地址, 逻辑型, 公开
    .参数 方法地址, 整数型, , 取类内部方法地址（）的返回值

    返回 (HeapFree (GetProcessHeap (), 0, 方法地址) ≠ 0)

.子程序 整数转浮点数, 文本型, 公开, 整数数值转为十六进制浮点数文本带空格
    .参数 局_整数参数, 整数型, , 整数参数
    .局部变量 局_浮点数, 双精度小数型
    .局部变量 局_浮点数据地址, 整数型
    .局部变量 局_汇编转进制, 汇编类
    .局部变量 局_浮点数字节集, 字节集

    局_浮点数 ＝ 到数值 (局_整数参数)
    局_浮点数据地址 ＝ 取变量地址_整数 (局_浮点数)
    局_浮点数字节集 ＝ 指针到字节集 (局_浮点数据地址, 8)
    返回 (局_汇编转进制.转为十六进制 (局_浮点数字节集))

.子程序 __set, 整数型, , 请确保指针的合法性,写到内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移
    .参数 value, 整数型, , 写入值

    置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 25, 139, 85, 16, 137, 20, 25, 201, 194, 12, 0 })
    ' mov ebx,[ebp+8]
    ' mov ecx,[ebp+12]
    ' mov eax,[ebx+ecx]
    ' mov edx,[ebp+16]
    ' mov [ebx+ecx],edx
    ' leave
    ' ret 12
    返回 (0)

.子程序 __get, 整数型, , 请确保指针的合法性,读取内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移

    置入代码 ({ 139, 69, 8, 139, 93, 12, 139, 4, 24, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' mov ebx,[ebp+12]
    ' mov eax,[eax+ebx]
    ' leave
    ' ret 8
    返回 (0)

.子程序 CallObject, 整数型, , 调用对象
    .参数 对象指针, 整数型
    .参数 方法索引, 整数型
    .参数 附加参数1, 整数型, 可空
    .参数 附加参数2, 整数型, 可空
    .参数 附加参数3, 整数型, 可空
    .参数 附加参数4, 整数型, 可空
    .参数 附加参数5, 整数型, 可空
    .参数 附加参数6, 整数型, 可空
    .参数 附加参数7, 整数型, 可空
    .参数 附加参数8, 整数型, 可空
    .参数 附加参数9, 整数型, 可空
    .局部变量 pThis, 整数型

    .如果真 (取反 (IsBadReadPtr (对象指针, 4)))
        指针到变量 (对象指针, pThis)
        .如果真 (取反 (IsBadCodePtr (pThis)))
            返回 (调用子程序_ (__get (pThis, 方法索引 × 4), 对象指针, 附加参数1, 附加参数2, 附加参数3, 附加参数4, 附加参数5, 附加参数6, 附加参数7, 附加参数8, 附加参数9))
        .如果真结束
        
    .如果真结束
    返回 (0)

.子程序 SafeRelease, 整数型, , 释放对象,调用对象的第二个方法
    .参数 pObj, 整数型, 参考, 释放后把原来的对象清0
    .局部变量 index, 整数型
    .局部变量 pThis, 整数型
    .局部变量 ret, 整数型

    .如果真 (pObj ≠ 0)
        ret ＝ CallObject (pObj, 2, , , , , , , , , ) ' 调用对象的第二个方法
        pObj ＝ 0
    .如果真结束
    返回 (ret)
    ' index ＝ 2   '精易模块的调用方法,应该都一样,这个变量请放在第一个位置,还有参数的参考要去掉
    ' 置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    ' 返回 (0)

.子程序 调用子程序_, 整数型, , call
    .参数 调用地址, 整数型
    .参数 参数1, 整数型, 可空
    .参数 参数2, 整数型, 可空
    .参数 参数3, 整数型, 可空
    .参数 参数4, 整数型, 可空
    .参数 参数5, 整数型, 可空
    .参数 参数6, 整数型, 可空
    .参数 参数7, 整数型, 可空
    .参数 参数8, 整数型, 可空
    .参数 参数9, 整数型, 可空
    .参数 参数10, 整数型, 可空
    .参数 参数11, 整数型, 可空
    .参数 参数12, 整数型, 可空
    .参数 参数13, 整数型, 可空
    .参数 参数14, 整数型, 可空
    .参数 参数15, 整数型, 可空

    .如果真 (IsBadCodePtr (调用地址))
        返回 (0)
    .如果真结束
    置入代码 ({ 86, 190, 15, 0, 0, 0, 141, 77, 8, 141, 76, 241, 252, 139, 65, 4, 133, 192, 116, 2, 255, 49, 78, 131, 233, 8, 133, 246, 117, 239, 255, 85, 8, 94, 201, 194, 124, 0 })
    返回 (0)

.子程序 取数据_通用型, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样,注意: 字节集数据需要+8,前8位是标准,字节集型数据建议使用 取指针_字节集型()
    .参数 数据, 通用型, 参考, 不建议传递字节集型变量

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_通用型, 整数型, 公开, 取到的是变量在栈中的地址,和 取变量地址() 一样
    .参数 变量, 通用型, 参考, 基本支持所有类型

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_通用型_数组, 整数型, 公开, 取到的是变量在栈中的地址,和 取变量地址() 一样
    .参数 变量, 通用型, 参考 数组

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_文本型, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样
    .参数 文本, 文本型, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_字节集型, 整数型, 公开, 取到的是变量堆地址,和 取变量数据地址() 一样
    .参数 字节集, 字节集, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 15, 132, 3, 0, 0, 0, 131, 192, 8, 201, 194, 4, 0 })
    返回 (0)
    

.子程序 取数据_通用型_数组, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样
    .参数 数据, 通用型, 参考 数组, 基本支持所有类型

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 10, 139, 24, 193, 227, 2, 131, 192, 4, 1, 216, 201, 194, 4, 0 })
    返回 (0)

.子程序 指针到变量, , , 本函数用于指针转基本数据类型.(字节,短整数,整数,小数,逻辑,子程序指针).请确保指针的合法性
    .参数 指针, 整数型
    .参数 变量, 通用型, 参考

    置入代码 ({ 139, 93, 8, 139, 69, 12, 255, 51, 143, 0, 201, 194, 8, 0 })

.子程序 指针转移, 整数型, 公开, 设置将第一个参数转移到第二个同类型的变量去处理,此时操作第二个变量相当于操作第一个变量,功能类似于核心库的 事件转移(),成功返回还原指针时需要的地址,调用此函数后在必须调用 指针还原() 来还原指针,否则90%以上的几率会崩溃,调用后在没有还原指针之前不能操作第一个变量
    .参数 源指针, 整数型, , 被操作的指针,一般是exe传给dll的,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .参数 转移到, 整数型, , 把源指针转移到这里,这样操作这个变量相当于操作源变量,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .局部变量 pMem, 整数型

    pMem ＝ 指针_到整数 (转移到) ' 记录第二个变量原来的数据地址,在还原时要把这个地址还原回去
    __set (转移到, 0, 指针_到整数 (源指针)) ' 把源指针放到局部变量里,让局部变量指向源指针
    返回 (pMem)
    

.子程序 指针还原, , 公开, 调用此函数前必须先调用 指针转移() 
    .参数 源指针, 整数型, , 被操作的指针,一般是exe传给dll的,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .参数 转移到, 整数型, , 把源指针转移到这里,这样操作这个变量相当于操作源变量,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .参数 还原指针, 整数型, , 指针转移() 函数返回的指针

    __set (源指针, 0, 指针_到整数 (转移到)) ' 因为操作后局部变量的指针会发生改变,所以要重新取一下地址,放到源指针里,这样的话源指针指向的是局部变量修改后的地址
    __set (转移到, 0, 还原指针) ' 把原来的局部变量数据还原,因为局部变量在子程序执行完后会释放,把原来的指针还回去,让他释放原来的指针

.子程序 A2W, 字节集, , ansi转unicode,
    .参数 转换文本, 文本型
    .参数 代码, 整数型, 可空, 默认936 中文
    .局部变量 uLen, 整数型
    .局部变量 bin, 字节集
    .局部变量 dwLen, 整数型

    .如果真 (转换文本 ＝ “”)
        返回 ({ 0, 0 })
    .如果真结束
    .如果真 (是否为空 (代码))
        代码 ＝ 936
    .如果真结束
    dwLen ＝ 取文本长度 (转换文本)
    uLen ＝ MultiByteToWideChar (代码, 0, 取指针_文本型 (转换文本), dwLen, 0, 0) × 2
    bin ＝ 取空白字节集 (uLen ＋ 2)
    .如果真 (uLen ＞ 0)
        MultiByteToWideChar (代码, 0, 取指针_文本型 (转换文本), dwLen, 取指针_字节集型 (bin), uLen)
    .如果真结束
    返回 (bin)

.子程序 A2W_指针, 整数型, , 返回的指针需要释放
    .参数 A, 整数型, , 窄字符指针
    .参数 Alen, 整数型, , 窄字符长度(如需返回0,0结尾的传入Alen+1)或者-1
    .参数 CodePage, 整数型, , #CP_
    .参数 Wlen, 整数型, 参考, 宽字符长度
    .局部变量 W, 整数型

    连续赋值 (0, Wlen)
    Wlen ＝ MultiByteToWideChar (CodePage, 0, A, Alen, W, 0)
    W ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Wlen × 2)
    .如果真 (W ＝ 0)
        返回 (0)
    .如果真结束
    MultiByteToWideChar (CodePage, 0, A, Alen, W, Wlen)
    返回 (W)

.子程序 W2A_指针, 整数型, , 返回的指针需要释放
    .参数 W, 整数型, , 宽字符指针
    .参数 Wlen, 整数型, , 宽字符长度
    .参数 CodePage, 整数型, , #CP_
    .参数 Alen, 整数型, 参考, 窄字符长度
    .局部变量 A, 整数型

    连续赋值 (0, Alen)
    Alen ＝ WideCharToMultiByte (CodePage, 0, W, Wlen, 0, 0, 0, 0)
    A ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Alen)
    .如果真 (A ＝ 0)
        返回 (0)
    .如果真结束
    WideCharToMultiByte (CodePage, 0, W, Wlen, A, Alen, 0, 0)
    返回 (A)

.子程序 到窄文本, 文本型, , 把U码转换成A码
    .参数 源宽文本, 字节集
    .局部变量 长度, 整数型
    .局部变量 TEMP, 字节集

    .如果 (SEH_安装简单SEH ())
        长度 ＝ 取字节集长度 (源宽文本)
        TEMP ＝ 取空白字节集 (长度)
        WideCharToMultiByte (0, 0, 取指针_字节集型 (源宽文本), 长度 ＼ 2, 取指针_字节集型 (TEMP), 长度, 0, 0)
    .否则
        TEMP ＝ { }
    .如果结束
    SEH_删除简单SEH ()
    返回 (到文本 (TEMP))

.子程序 SEH_安装简单SEH, 逻辑型, , 如果真(SEH_简单SEH())   配对函数 SEH_删除SEH()
    .参数 保留参数, 子程序指针, 可空

    保留参数 ＝ &SEH_简单SEH接口
    ' 0042866B    8B45 08               mov     eax, dword ptr [ebp+8]           ; EAX=简单SEH接口
    ' 0042866E    C9                    leave                                    ; 平衡堆栈
    ' 0042866F    83EC 60               sub     esp, 60                          ; 申请浮点寄存器
    ' 00428672    9C                    pushfd                                   ; 保存标志寄存器
    ' 00428673    60                    pushad                                   ; 保存通用寄存器
    ' 00428674    FFB424 84000000       push    dword ptr [esp+84]               ; 保存安装返回
    ' 0042867B    6A 00                 push    0                                ; 保存用户接口
    ' 0042867D    50                    push    eax                              ; SEH_接口
    ' 0042867E    DD7424 30             fsave   (108-byte) ptr [esp+30]          ; 备份浮点寄存器
    ' 77EC2FD4    9B                    wait
    ' 00428682    64:FF35 00000000      push    dword ptr fs:[0]                 ; 保存 原SEH栈
    ' 00428689    64:8925 00000000      mov     dword ptr fs:[0], esp            ; 设置 现SEH栈
    ' 00428690    B8 01000000           mov     eax, 1                           ; EAX=1=安装成功
    ' 00428695    FF6424 0C             jmp     dword ptr [esp+C]                ; 安装 SEH 返回
    ' 8B 45 08 C9 83 EC 60 9C 60 FF B4 24 84 00 00 00 6A 00 50 DD 74 24 30 9B 64 FF 35 00 00 00 00 64 89
    ' 25 00 00 00 00 B8 01 00 00 00 FF 64 24 0C
    置入代码 ({ 139, 69, 8, 201, 131, 236, 96, 156, 96, 255, 180, 36, 132, 0, 0, 0, 106, 0, 80, 221, 116, 36, 48, 155, 100, 255, 53, 0, 0, 0, 0, 100, 137, 37, 0, 0, 0, 0, 184, 1, 0, 0, 0, 255, 100, 36, 12 })
    返回 (真)

.子程序 SEH_简单SEH接口, 整数型, , 该子程序供  如果真(SEH_安装简单SEH(&SEH_SEH简单处理))  使用
    .参数 异常代码, 整数型
    .参数 堆栈结构, 整数型
    .参数 线程环境, 整数型
    .参数 调度环境, 整数型, , DispatcherContext

    ' 00401095    8B45 08                mov     eax, dword ptr [ebp+8]           ; 接口 参数1 异常结构
    ' 00401098    8138 250000C0          cmp     dword ptr [eax], C0000025        ; 不可处理异常?
    ' 0040109E    74 45                  je      short 004010E5                   ; 不可处理  跳
    ' 004010A0    8378 04 00             cmp     dword ptr [eax+4], 0             ; 可处理异常?
    ' 004010A4    75 3F                  jnz     short 004010E5                   ; 不可处理 跳
    ' 004010A6    E8 00000000            call    004010AB                         ; 计算2次处理偏移
    ' 004010AB    58                     pop     eax                              ; 计算2次处理偏移
    ' 004010AC    83C0 06                add     eax, 6                           ; 计算2次处理偏移
    ' 004010AF    EB 1C                  jmp     short 004010CD                   ; 转到1次处理
    ' 004010B1    64:8925 00000000       mov     dword ptr fs:[0], esp            ; 2次处理代码
    ' 004010B8    83C4 10                add     esp, 10                          ; 2次处理代码
    ' 004010BB    61                     popad                                    ; 2次处理代码
    ' 004010BC    9D                     popfd                                    ; 2次处理代码
    ' 004010BD    DD2424                 frstor  (108-byte) ptr [esp]             ; 2次处理代码
    ' 77EC2FD4    9B                     wait
    ' 004010C0    64:8B25 00000000       mov     esp, dword ptr fs:[0]            ; 2次处理代码
    ' 004010C7    33C0                   xor     eax, eax                         ; 2次处理  安装假
    ' 004010C9    FF6424 0C              jmp     dword ptr [esp+C]                ; 2次处理完成返回
    ' 004010CD    51                     push    ecx                              ; 1次处理 备份ECX
    ' 004010CE    8B4D 10                mov     ecx, dword ptr [ebp+10]          ; 接口 参数3 线程环境
    ' 004010D1    8981 B8000000          mov     dword ptr [ecx+B8], eax          ; 新EIP = 2次处理
    ' 004010D7    8B45 0C                mov     eax, dword ptr [ebp+C]           ; 接口 参数2 异常堆栈
    ' 004010DA    8981 C4000000          mov     dword ptr [ecx+C4], eax          ; 新ESP =现异常栈
    ' 004010E0    59                     pop     ecx                              ; 1次处理 恢复ECX
    ' 004010E1    33C0                   xor     eax, eax                         ; EAX=0 异常已处理
    ' 004010E3    EB 05                  jmp     short 004010EA                   ; 跳到  返回
    ' 004010E5    B8 01000000            mov     eax, 1                           ; EAX=1 异常未处理
    ' 77682FDA    8945 08                mov     dword ptr [ebp+8], eax           ; 保存返回值
    
    ' 8B 45 08 81 38 25 00 00 C0 74 46 83 78 04 00 75 40 E8 00 00 00 00 58 83 C0 06 EB 1D 64 89 25 00
    ' 00 00 00 83 C4 10 61 9D DD 24 24 9B 64 8B 25 00 00 00 00 33 C0 FF 64 24 0C 51 8B 4D 10 89 81 B8
    ' 00 00 00 8B 45 0C 89 81 C4 00 00 00 59 33 C0 EB 05 B8 01 00 00 00 89 45 08
    置入代码 ({ 139, 69, 8, 129, 56, 37, 0, 0, 192, 116, 70, 131, 120, 4, 0, 117, 64, 232, 0, 0, 0, 0, 88, 131, 192, 6, 235, 29, 100, 137, 37, 0, 0, 0, 0, 131, 196, 16, 97, 157, 221, 36, 36, 155, 100, 139, 37, 0, 0, 0, 0, 51, 192, 255, 100, 36, 12, 81, 139, 77, 16, 137, 129, 184, 0, 0, 0, 139, 69, 12, 137, 129, 196, 0, 0, 0, 89, 51, 192, 235, 5, 184, 1, 0, 0, 0, 137, 69, 8 })
    返回 (异常代码)

.子程序 SEH_删除简单SEH, , , 与 SEH_安装简单SEH() 配对使用
    .参数 保留参数, 子程序指针, 可空

    保留参数 ＝ &SEH_简单SEH接口
    ' 00401106    51                    push    ecx                              ; 备份 寄存器
    ' 00401107    64:8B0D 00000000      mov     ecx, dword ptr fs:[0]            ; 指向现异常栈
    ' 0040110E    81F9 FFFF0000         cmp     ecx, 0FFFF                       ; 是否有效栈址
    ' 00401114    7E 2A                 jle     short 0040113F                   ; 无效栈址 跳
    ' 00401116    8B41 04               mov     eax, dword ptr [ecx+4]           ; 获取异常接口
    ' 00401119    3B45 08               cmp     eax, dword ptr [ebp+8]           ; 判断异常接口
    ' 0040111C    74 04                 je      short 00401122                   ; 简单接口 跳
    ' 0040111E    8B09                  mov     ecx, dword ptr [ecx]             ; 下个异常栈指
    ' 00401120  ^ EB EC                 jmp     short 0040110E                   ; 继续循环判断
    ' 00401122    8B45 04               mov     eax, dword ptr [ebp+4]           ; EAX=返回地址
    ' 00401125    8BE1                  mov     esp, ecx                         ; ESP=本层SEH栈
    ' 00401127    64:8F05 00000000      pop     dword ptr fs:[0]                 ; 恢复上层SEH栈
    ' 0040112E    83C4 0C               add     esp, 0C                          ; ESP  指向备份
    ' 00401131    894424 1C             mov     dword ptr [esp+1C], eax          ; 保存返回地址
    ' 00401135    61                    popad                                    ; 恢复通用寄存器
    ' 00401136    9D                    popfd                                    ; 恢复标志寄存器
    ' 00401137    DD2424                frstor  (108-byte) ptr [esp]             ; 恢复浮点寄存器
    ' 77EC2FD4    9B                    wait
    ' 0040113A    83C4 6C               add     esp, 6C                          ; 弹掉浮点栈数据
    ' 0040113D  ^ FFE0                  jmp     eax                              ; 主要代码段返回
    ' 0040113F    59                    pop     ecx                              ; 恢复 寄存器
    ' 00401140    90                    nop                                      ; 无符合接口 返回
    ' 51 64 8B 0D 00 00 00 00 81 F9 FF FF 00 00 7E 2A 8B 41 04 3B 45 08 74 04 8B 09 EB EC 8B 45 04 8B
    ' E1 64 8F 05 00 00 00 00 83 C4 0C 89 44 24 1C 61 9D DD 24 24 9B 83 C4 6C FF E0 59 90
    
    置入代码 ({ 81, 100, 139, 13, 0, 0, 0, 0, 129, 249, 255, 255, 0, 0, 126, 42, 139, 65, 4, 59, 69, 8, 116, 4, 139, 9, 235, 236, 139, 69, 4, 139, 225, 100, 143, 5, 0, 0, 0, 0, 131, 196, 12, 137, 68, 36, 28, 97, 157, 221, 36, 36, 155, 131, 196, 108, 255, 224, 89, 144 })

.子程序 提示框J, 整数型, 公开, 跟系统自带的信息框()一样，不同的是 窗口“总在最前”属性设置为真也能显示出来；
    .参数 提示信息, 文本型, 可空
    .参数 按钮, 整数型, 可空, 可空：默认为 #确认钮；0、#确认钮； 1、#确认取消钮； 2、#放弃重试忽略钮； 3、#取消是否钮； 4、#是否钮； 5、#重试取消钮；16、#错误图标； 32、#询问图标； 48、#警告图标； 64、#信息图标；524288、#文本右对齐
    .参数 窗口标题, 文本型, 可空, 可空：默认为“友情提醒”；
    .参数 父窗口句柄, 整数型, 可空, 可空:默认为自动程序
    .参数 超时时间, 整数型, 可空, 超过指定的时间后，信息框将自动关闭。可空：默认为5秒超时，单位为毫秒。
    .局部变量 局_返回值, 整数型

    ' 0、#确认钮； 1、#确认取消钮； 2、#放弃重试忽略钮； 3、#取消是否钮；     4、#是否钮； 5、#重试取消钮
    ' 16、#错误图标； 32、#询问图标； 48、#警告图标； 64、#信息图标
    ' 0、#程序等待； 4096、#系统等待
    ' 65536、#位于前台； 524288、#文本右对齐
    .如果真 (是否为空 (父窗口句柄))
        父窗口句柄 ＝ 进程_ID取窗口句柄J (GetCurrentProcessId (), , , 1000, )
    .如果真结束
    .如果真 (是否为空 (窗口标题))
        窗口标题 ＝ “友情提醒”
    .如果真结束
    .如果真 (是否为空 (按钮))
        按钮 ＝ #确认钮
    .如果真结束
    .如果真 (是否为空 (超时时间))
        超时时间 ＝ 10000
    .如果真结束
    局_返回值 ＝ MessageBoxTimeoutA (父窗口句柄, 提示信息, 窗口标题, 按钮, 0, 超时时间)
    返回 (局_返回值 － 1)

.子程序 E数据库_快速查询, , 公开, 在易数据库已打开的情况下,对某字段进行快速查询,勤快的人可把记录分成两个数组，用多线程分开查询，应该更快。把记录添加完了在显示控件，这样就快多了
    .参数 查询的字段名, 文本型, , 必须为文本型字段
    .参数 查询内容, 文本型, 可空, 可以为空,为空即为查询空记录
    .参数 返回记录号数组名, 整数型, 数组, 本数据内容将直接返回结果
    .局部变量 次数, 整数型
    .局部变量 数组, 文本型, , "3"
    .局部变量 数组1, 整数型, , "3"

    到首记录 ()
    .计次循环首 (取记录数 (), )
        加入成员 (数组, 读 (查询的字段名))
        加入成员 (数组1, 取记录号 ())
        跳过 ()
    .计次循环尾 ()
    次数 ＝ 1
    .计次循环首 (取数组成员数 (数组), 次数)
        .如果真 (数组 [次数] ＝ 查询内容)
            输出调试文本 (数组 [次数])
            加入成员 (返回记录号数组名, 数组1 [次数])
        .如果真结束
        
    .计次循环尾 ()

.子程序 E数据库_修复易数据库, 逻辑型, 公开, 修复一个被破坏的易语言数据库
    .参数 易数据库名, 文本型, , 易数据库全路径文件名
    .参数 错误信息, 文本型, 可空, 如果修复失败，返回对应的错误文本。如果本参数为空，则不记录错误信息。
    .局部变量 备份文件, 文本型
    .局部变量 记录数1, 长整数型
    .局部变量 记录数2, 长整数型
    .局部变量 文件号, 整数型
    .局部变量 可否打开, 逻辑型
    .局部变量 当前库, 文本型, , , 已经打开的当前数据库。

    ' 非正常关机时，常常可能导致易数据库损坏，其出错信息一般为：数据库尺寸错误。具体指：数据库文件头的记录数与数据库实际的记录数不相符，一般是相差一个记录（前者>后者）。所以尝试做这个模块，通过修改数据库文件头记录的记录数来修复损坏的数据库。
    ' 一开始，只是简单地修复了一下，没有成功，还以为是模块的问题，后来，看到银戒指修复的数据库，损失了6个记录，才意识到，可能损坏的数据库，其所记录的记录数与实际记录数可能相差不止一个，于是用了一个循环，果然修好了，呵呵。
    ' 在此还劝大家在使用易数据库时，使用到数据库时再打开，用完立即关闭数据库，这样可确保不会因为长时间打开数据库，一旦有断电、死机、重启等发生时产生易数据库损坏。并且要定期备份重要的数据库。
    当前库 ＝ 取当前库 () ' 取出当前数据库名称，用于修复数据库后重置当前库。
    可否打开 ＝ 打开 (易数据库名, “要用模块修复的数据库”, , , , , ) ' 使用较长的别名，是为了防止与调用模块的程序的当前库有冲突。下同。
    .如果真 (可否打开)
        关闭 (“要用模块修复的数据库”)
        置当前库 (当前库) ' 重置原来的当前数据库。
        返回 (真)
    .如果真结束
    .如果真 (取错误码 () ≠ -48)
        .如果真 (是否为空 (错误信息) ＝ 假)
            错误信息 ＝ “指定文件非数据库，或数据库损坏类型不是数据库文件尺寸错误，不能用本模块修复。”
        .如果真结束
        返回 (假)
    .如果真结束
    备份文件 ＝ 取临时文件名 ()
    复制文件 (易数据库名, 备份文件) ' 备份数据库，如果修复失败则恢复它。
    .判断循环首 (可否打开 ＝ 假) ' 循环修复，将文件头中记录的记录数递减，直到数据库能正确打开。
        文件号 ＝ 打开文件 (易数据库名, , )
        .如果真 (文件号 ＝ 0)
            .如果真 (是否为空 (错误信息) ＝ 假)
                错误信息 ＝ “读取数据库文件失败。”
                复制文件 (备份文件, 易数据库名) ' 用备份的数据库文件恢复被修改过的数据库文件。
            .如果真结束
            返回 (假)
        .如果真结束
        移动读写位置 (文件号, #文件首, 16)
        记录数1 ＝ 取字节集数据 (读入字节集 (文件号, 4), #长整数型) ' 从第17位开始读取，共4位。
        .如果真 (记录数1 ＝ 0) ' 如果经过递减，记录数为0时仍不能打开，说明修复失败，返回假。
            .如果真 (是否为空 (错误信息) ＝ 假)
                错误信息 ＝ “修复数据库未成功，原因未知。”
                复制文件 (备份文件, 易数据库名)
            .如果真结束
            返回 (假)
        .如果真结束
        移动读写位置 (文件号, #文件首, 20)
        记录数2 ＝ 取字节集数据 (读入字节集 (文件号, 4), #长整数型) ' 从第21位开始读取，共4位。
        记录数1 ＝ 记录数1 － 1 ' 记录数1递减1。
        记录数2 ＝ 记录数2 － 1 ' 记录数2递减1。
        移动读写位置 (文件号, #文件首, 16)
        写出字节集 (文件号, 取字节集左边 (到字节集 (记录数1) ＋ { 0, 0, 0, 0 }, 4)) ' 将记录数递减1，写出至数据库文件头，并确保写出字节集长度为4位，下同。
        移动读写位置 (文件号, #文件首, 20)
        写出字节集 (文件号, 取字节集左边 (到字节集 (记录数2) ＋ { 0, 0, 0, 0 }, 4)) ' 将记录数递减1，并写出至数据库文件头。
        关闭文件 (文件号)
        可否打开 ＝ 打开 (易数据库名, “要用模块修复的数据库”, , , , , )
    .判断循环尾 ()
    关闭 (“要用模块修复的数据库”)
    置当前库 (当前库) ' 重置原来的当前数据库。
    .如果真 (是否为空 (错误信息) ＝ 假)
        错误信息 ＝ “”
    .如果真结束
    返回 (真) ' 如果能跳出循环，说明打开数据库成功，数据库被修复。将其关闭后，返回真。
    

.子程序 取默认目录, 文本型
    .如果真 (目录_是否存在 (取运行目录 () ＋ “\data”) ＝ 假)
        目录_创建 (取运行目录 () ＋ “\data”)
    .如果真结束
    返回 (取运行目录 () ＋ “\data\setsoft.ini”)

.子程序 内部_对比, 逻辑型
    .参数 对比原文本, 文本型
    .参数 对比文本, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_计次, 整数型

    清除数组 (局_数组)
    局_数组 ＝ 分割文本 (对比原文本, “|”, )
    .计次循环首 (取数组成员数 (局_数组), 局_计次)
        .如果真 (文本比较 (局_数组 [局_计次], 对比文本, 真) ＝ 0)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 批量_单选框_保存配置, 整数型, 公开, 保存窗口上所有选择框的选中状态!与"批量_单选框_读取配置()"命令一起用的!  返回被操作的单选框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 单选框
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “单选框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    
    
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            写配置项 (配置文件名, “单选框”, 取组件名称 (局_组件), 到文本 (局_组件.选中))
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_单选框_读取配置, 整数型, 公开, 与"批量_单选框_保存配置()"命令一起用的!  返回被操作的单选框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 单选框
    .局部变量 局_组件数量, 整数型
    .局部变量 局_临时文本, 文本型
    .局部变量 选中项, 逻辑型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “单选框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “单选框”, 取组件名称 (局_组件), “假”)
        选中项 ＝ 选择 (局_临时文本 ＝ “假”, 假, 真)
        .如果真 (局_组件.选中 ≠ 选中项)
            局_组件.选中 ＝ 选中项
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_选择框_保存配置, 整数型, 公开, 保存窗口上所有选择框的选中状态!与"批量_选择框_读取配置()"命令一起用的!  返回被操作的选择框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 选择框
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “选择框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            写配置项 (配置文件名, “选择框”, 取组件名称 (局_组件), 到文本 (局_组件.选中))
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_选择框_读取配置, 整数型, 公开, 与"批量_选择框_保存配置()"命令一起用的!  返回被操作的选择框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 选择框
    .局部变量 局_组件数量, 整数型
    .局部变量 局_临时文本, 文本型
    .局部变量 是否选中, 逻辑型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “选择框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “选择框”, 取组件名称 (局_组件), “假”)
        是否选中 ＝ 选择 (局_临时文本 ＝ “假”, 假, 真)
        .如果真 (局_组件.选中 ≠ 是否选中)
            局_组件.选中 ＝ 是否选中
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_编辑框_保存配置, 整数型, 公开, 保存窗口上所有编辑框的内容!与"批量_编辑框_读取配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 编辑框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “编辑框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            写配置项 (配置文件名, “编辑框”, 取组件名称 (局_组件), 局_组件.内容)
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_编辑框_读取配置, 整数型, 公开, 与"批量_编辑框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 编辑框
    .局部变量 局_组件数量, 整数型
    .局部变量 局_临时文本, 文本型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “编辑框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “编辑框”, 取组件名称 (局_组件), )
        .如果真 (局_组件.内容 ≠ 局_临时文本)
            局_组件.内容 ＝ 局_临时文本
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_组合框_保存配置, 整数型, 公开, 保存窗口上所有组合框的内容!与"批量_组合框_读取配置()"命令一起用的!  返回被操作的组合框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 组合框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型
    .局部变量 局_组合框计次, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_临时文本 ＝ “”
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            局_临时文本 ＝ 到文本 (局_组件.现行选中项) ＋ “<|>” ＋ 局_组件.内容
            写配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), 局_临时文本)
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_组合框_读取配置, 整数型, 公开, 与"批量_组合框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 组合框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型
    .局部变量 局_组合框计次, 整数型
    .局部变量 局_临时数组, 文本型, , "0"
    .局部变量 数量, 整数型
    .局部变量 选中项, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), “”)
        .如果真 (局_临时文本 ＝ “”)
            .如果真 (局_组件.现行选中项 ≠ 0)
                局_组件.现行选中项 ＝ 0
            .如果真结束
            到循环尾 ()
        .如果真结束
        选中项 ＝ 到整数 (文本_取左边 (局_临时文本, “<|>”))
        .如果真 (选中项 ≠ 局_组件.现行选中项)
            局_组件.现行选中项 ＝ 到整数 (选中项)
        .如果真结束
        清除数组 (局_临时数组)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)
    
    
    
    
    
    
    ' .如果真 (配置文件名 ＝ “”)
        ' 配置文件名 ＝ 取默认目录 ()
    ' .如果真结束
    ' 局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
    ' 局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    ' .计次循环首 (局_组件数量, 局_计次)
        ' 局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        ' 局_临时文本 ＝ 读配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), “”)
        ' ' 局_临时文本 ＝ 子文本替换 (局_临时文本, “#引号”, #引号, , , 真)
        ' .如果真 (局_临时文本 ＝ “”)
            ' 到循环尾 ()
        ' .如果真结束
        ' ' 局_组件.清空 ()
        ' 局_临时数组 ＝ 分割文本 (局_临时文本, “<||>”, )
        ' .计次循环首 (取数组成员数 (局_临时数组) － 1, 局_组合框计次)
            ' ' 局_组件.加入项目 (文本_取左边 (局_临时数组 [局_组合框计次], “<|>”), 到数值 (文本_取右边 (局_临时数组 [局_组合框计次], “<|>”)))
        ' .计次循环尾 ()
        ' 数量 ＝ 取数组成员数 (局_临时数组)
        ' .如果真 (数量 ＞ 0)
            ' 选中项 ＝ 文本_取左边 (局_临时数组 [数量], “<|>”)
            ' .如果真 (选中项 ≠ “”)
                ' 局_组件.现行选中项 ＝ 到整数 (选中项)
            ' .如果真结束
            
            ' ' 局_组件.内容 ＝ 文本_取右边 (局_临时数组 [取数组成员数 (局_临时数组)], “<|>”)
        ' .如果真结束
        ' 清除数组 (局_临时数组)
    ' .计次循环尾 ()
    ' 清除组件寻找句柄 (局_寻找句柄)
    ' 返回 (局_组件数量)

.子程序 批量_日期框_保存配置, 整数型, 公开, 保存窗口上所有日期框的内容!与"批量_日期框_读取配置()"命令一起用的!  返回被操作的日期框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 日期框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “日期框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_临时文本 ＝ “”
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            局_临时文本 ＝ 时间到文本 (局_组件.今天, )
            写配置项 (配置文件名, “日期框”, 取组件名称 (局_组件), 局_临时文本)
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_日期框_读取配置, 整数型, 公开, 与"批量_日期框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 日期框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “日期框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “日期框”, 取组件名称 (局_组件), “”)
        局_组件.今天 ＝ 到时间 (局_临时文本)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 OCX_注册, , 公开, 注册OCX组件
    .参数 OCX文件路径, 文本型

    运行 (“regsvr32 ” ＋ OCX文件路径 ＋ “ /s”, 假, 1)

.子程序 OCX_卸载, , 公开, 卸载OCX组件
    .参数 OCX文件路径, 文本型

    运行 (“regsvr32 ” ＋ OCX文件路径 ＋ “ /u”, 假, 1)

.子程序 文件拖放_回调函数, 整数型, , [文件拖放]
    .参数 hwnd, 整数型
    .参数 iMsg, 整数型
    .参数 hDrop, 整数型
    .参数 lParam, 整数型
    .局部变量 sFileName, 文本型
    .局部变量 IReturn, 整数型
    .局部变量 nCount, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 数组位置, 整数型
    .局部变量 文件后缀名, 文本型
    .局部变量 局_窗口过程
    .局部变量 局_函数指针

    局_窗口过程 ＝ GetPropA (hwnd, “NewWindowsProc”)
    局_函数指针 ＝ GetPropA (hwnd, “Subaddress”)
    .判断开始 (iMsg ＝ 563)
        nCount ＝ DragQueryFileA (hDrop, -1, “”, 0)
        .计次循环首 (nCount, 局_计次)
            sFileName ＝ 取空白文本 (260)
            IReturn ＝ DragQueryFileA (hDrop, 局_计次 － 1, sFileName, 260)
            .如果真 (IReturn ＞ 0)
                文件后缀名 ＝ 取文本右边 (sFileName, 取文本长度 (sFileName) － 倒找文本 (sFileName, “.”, , 假))
                CallWindowProcA (局_函数指针, nCount, 局_计次, 取指针_文本型 (sFileName), 取指针_文本型 (文件后缀名))
            .如果真结束
            
        .计次循环尾 ()
        DragFinish (hDrop)
        返回 (1)
    .默认
        
    .判断结束
    返回 (CallWindowProcA (局_窗口过程, hwnd, iMsg, hDrop, lParam))

.子程序 子_字节型数组到文本, 文本型
    .参数 字节, 字节型, 数组
    .局部变量 局_计次, 整数型
    .局部变量 局_ret, 文本型

    局_ret ＝ “”
    .计次循环首 (取数组成员数 (字节), 局_计次)
        .如果 (字节 [局_计次] ≠ 0)
            局_ret ＝ 局_ret ＋ 字符 (字节 [局_计次])
        .否则
            跳出循环 ()
        .如果结束
        
    .计次循环尾 ()
    返回 (局_ret)

.子程序 子_文本到字节型数组
    .参数 字节, 字节型, 参考 数组
    .参数 文本, 文本型
    .局部变量 局_计次, 整数型

    局_计次 ＝ 取文本长度 (文本)
    重定义数组 (字节, 假, 局_计次 ＋ 2)
    .计次循环首 (取数组成员数 (字节), 局_计次)
        字节 [局_计次] ＝ 取代码 (取文本中间 (文本, 局_计次, 1), )
    .计次循环尾 ()

.子程序 子_GetRasEntryCount, 整数型, , 获取RAS项计数
    .局部变量 局_SizeOfRasEntryName, 整数型
    .局部变量 局_Ret, 整数型
    .局部变量 局_Count, 整数型
    .局部变量 局_RasEntry, 取连接信息用结构

    局_SizeOfRasEntryName ＝ GlobalSize_取连接信息用结构 (局_RasEntry)
    局_RasEntry.内存大小 ＝ 局_SizeOfRasEntryName
    局_Ret ＝ RasEnumEntrie (0, 0, 局_RasEntry, 局_SizeOfRasEntryName, 局_Count)
    .如果 (局_Ret ＝ 603 或 局_Ret ＝ 0)
        重定义数组 (FLSAList, 假, 局_Count)
        局_Ret ＝ 局_Count
    .否则
        局_Ret ＝ 0
    .如果结束
    返回 (局_Ret)

.子程序 子_GetLSAPasswords, , , 获取LSA的密码
    .局部变量 局_PrivateData, LSA_UNICODE_STRING

    .如果真 (子_GetLsaData (4, “RasDialParams!” ＋ 子_GetLocalSid () ＋ “#0”, 局_PrivateData))
        子_ProcessLSABuffer (局_PrivateData.缓冲区, 局_PrivateData.长度)
        LsaFreeMemory (局_PrivateData.缓冲区)
    .如果真结束
    .如果真 (子_GetLsaData (4, “L$_RasDefaultCredentials#0”, 局_PrivateData))
        子_ProcessLSABuffer (局_PrivateData.缓冲区, 局_PrivateData.长度)
        LsaFreeMemory (局_PrivateData.缓冲区)
    .如果真结束
    

.子程序 子_GetLocalSid, 文本型, , 获取本地SID
    .局部变量 局_sUserName, 文本型
    .局部变量 局_iResult, 整数型
    .局部变量 局_bUserSid, 字节集
    .局部变量 局_iUserSIDSize, 整数型
    .局部变量 局_sDomainName, 文本型
    .局部变量 局_iDomainNameLength, 整数型
    .局部变量 局_iSIDType, 整数型
    .局部变量 局_sUserSid, 文本型
    .局部变量 局_hUserSid, 整数型

    局_sUserName ＝ 取空白文本 (256)
    GetUserNameA (局_sUserName, 255)
    局_bUserSid ＝ 取空白字节集 (255)
    局_iResult ＝ LookupAccountName (取空白文本 (0), 局_sUserName, 局_bUserSid, 局_iUserSIDSize, 局_sDomainName, 局_iDomainNameLength, 局_iSIDType)
    局_sDomainName ＝ 取空白文本 (局_iDomainNameLength)
    局_bUserSid ＝ 取空白字节集 (局_iUserSIDSize)
    局_iResult ＝ LookupAccountName (取空白文本 (0), 局_sUserName, 局_bUserSid, 局_iUserSIDSize, 局_sDomainName, 局_iDomainNameLength, 局_iSIDType)
    .如果真 (IsValidSid (取指针地址_字节集型 (局_bUserSid)) ＝ 0)
        返回 (“”)
    .如果真结束
    局_iResult ＝ ConvertSidToStringSid (局_bUserSid, 局_hUserSid)
    .如果真 (局_iResult ≠ 0)
        局_iResult ＝ lstrlen (局_hUserSid)
        .如果真 (局_iResult ＞ 0)
            局_sUserSid ＝ 取空白文本 (局_iResult × 2)
            局_bUserSid ＝ 取空白字节集 (局_iResult × 2)
            RtlMoveMemory_整数型 (取指针地址_字节集型 (局_bUserSid), 局_hUserSid, 局_iResult × 2)
            局_sUserSid ＝ 编码_Unicode到Ansi (局_bUserSid)
        .如果真结束
        
    .如果真结束
    返回 (局_sUserSid)

.子程序 子_GetLsaData, 逻辑型, , 获取LSA的数据
    .参数 Policy, 整数型
    .参数 KeyName, 文本型
    .参数 OutData, LSA_UNICODE_STRING, 参考
    .局部变量 局_LsaObjectAttribs, LSA_OBJECT_ATTRIBUTES
    .局部变量 局_LsaHandle, 整数型
    .局部变量 局_LsaKeyName, LSA_UNICODE_STRING
    .局部变量 局_LsaPrivateData, 整数型
    .局部变量 局_status, 整数型
    .局部变量 局_temp1, 字节集
    .局部变量 局_temp2, 整数型

    .如果真 (LsaOpenPolicy (0, 局_LsaObjectAttribs, Policy, 局_LsaHandle) ＞ 0)
        返回 (假)
    .如果真结束
    子_AnsiStringToLsaStr (KeyName, 局_LsaKeyName)
    局_status ＝ LsaRetrievePrivateData (局_LsaHandle, 局_LsaKeyName, 局_LsaPrivateData)
    .如果真 (局_status ＝ 0)
        局_temp1 ＝ 指针到字节集 (局_LsaPrivateData, 8)
        RtlMoveMemory_LSA_UNICODE_STRING (OutData, 局_temp1, 8)
        局_temp1 ＝ 取字节集右边 (局_temp1, 4)
        局_temp2 ＝ 取字节集数据 (局_temp1, #整数型, )
        OutData.缓冲区 ＝ 指针到字节集 (局_temp2, OutData.长度)
        LsaClose (局_LsaHandle)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 子_AnsiStringToLsaStr, , , ANSI字符串str中的LSA
    .参数 AValue, 文本型
    .参数 LStr, LSA_UNICODE_STRING, 参考

    LStr.长度 ＝ 取文本长度 (AValue) × 2
    LStr.最大长度 ＝ LStr.长度 ＋ 2
    LStr.缓冲区 ＝ 编码_Ansi到Unicode (AValue)

.子程序 子_ProcessLSABuffer, , , LSA的缓冲过程
    .参数 Buffer, 字节集
    .参数 BufLen, 整数型
    .局部变量 局_c, 字节集
    .局部变量 局_记录, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_SPos, 整数型
    .局部变量 局_S, 字节集
    .局部变量 局_BookID, 文本型
    .局部变量 局_用户名, 文本型
    .局部变量 局_密码, 文本型

    局_记录 ＝ 1
    .变量循环首 (1, BufLen, 2, 局_计次)
        局_c ＝ 取字节集中间 (Buffer, 局_计次, 2)
        .如果 (局_c ＝ { 0, 0 })
            局_SPos ＝ 局_SPos ＋ 1
            .判断开始 (局_SPos ＝ 1)
                局_BookID ＝ 编码_Unicode到Ansi (局_S)
            .判断 (局_SPos ＝ 6)
                局_用户名 ＝ 编码_Unicode到Ansi (局_S)
            .判断 (局_SPos ＝ 7)
                局_密码 ＝ 编码_Unicode到Ansi (局_S)
                .如果真 (取数组成员数 (FLSAList) ＜ 局_记录)
                    重定义数组 (FLSAList, 真, 局_记录)
                .如果真结束
                FLSAList [局_记录].名字 ＝ 局_BookID
                FLSAList [局_记录].值 ＝ 局_密码
                FLSAList [局_记录].用户 ＝ 局_用户名
            .默认
                
            .判断结束
            局_S ＝ { }
        .否则
            局_S ＝ 局_S ＋ 局_c
        .如果结束
        .如果真 (局_SPos ＝ 9)
            局_记录 ＝ 局_记录 ＋ 1
            局_BookID ＝ “”
            局_SPos ＝ 0
        .如果真结束
        
    .变量循环尾 ()

.子程序 内部_线程, , , 线程池相关
    .参数 数据传递指针, 整数型, , 单位为：毫秒
    .局部变量 lpNumberOfBytesTransferred, 整数型
    .局部变量 IOCP句柄, 整数型
    .局部变量 线程池状态, 逻辑型
    .局部变量 处理函数, 整数型
    .局部变量 超时时间, 整数型

    .局部变量 处理状态, 整数型

    ' 地址结构依次为：
    ' 完成端口IOCP句柄
    ' 线程池状态。 1运行，0停止
    ' 处理函数。到整数(子程序指针)
    ' 超时时间
    
    IOCP句柄 ＝ 指针_到整数 (数据传递指针)
    ' 线程池状态 ＝ 指针_到整数 (数据传递指针 ＋ 4) ＝ 1  ' 暂时废弃 退出时发送一个退出的消息给循环，让循环退出
    线程池状态 ＝ 真
    处理函数 ＝ 指针_到整数 (数据传递指针 ＋ 8)
    超时时间 ＝ 指针_到整数 (数据传递指针 ＋ 12)
    HeapFree (GetProcessHeap (), 0, 数据传递指针)
    
    .判断循环首 (线程池状态)
        .如果 (GetQueuedCompletionStatus (IOCP句柄, lpNumberOfBytesTransferred, 处理状态, 0, -1) ＝ 1)
            .判断开始 (处理状态 ＝ 0)
                ' 输出调试文本 (lpNumberOfBytesTransferred)
                call (处理函数, lpNumberOfBytesTransferred)
            .判断 (处理状态 ＝ -999)
                返回 () ' 退出线程
            .默认
                
            .判断结束
            
        .否则
            ' GetLastError ()
            ' GetLastError ()
            跳出循环 () ' 错误后跳出，避免CPU增涨
        .如果结束
        
        
    .判断循环尾 ()
    输出调试文本 (“线程退出”)

.子程序 call, 整数型, , 线程池相关
    .参数 参数一, 整数型
    .参数 参数二, 整数型

    置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
    返回 (0)

.子程序 ___RAR解压_测试, , , ---------
    

.子程序 RAR_解压文件, 逻辑型, 公开, 解压 RAR 档案的所有文件或指定文件，成功返回真，失败返回假。本命令需要unrar.dll的支持,下载地址:http://www.rarlab.com/rar_add.htm
    .参数 待解压文件, 文本型, , 欲解压文件的压缩档案全路径名称
    .参数 解压密码, 文本型, 可空, 欲解压文件的压缩档案密码，无密码时为空
    .参数 解压路径, 文本型, 可空, 指定解压文件的路径，为空表示解压到压缩档案所在目录

    .如果真 (是否为空 (解压路径) 或 解压路径 ＝ “”)
        解压路径 ＝ 文件_取目录 (待解压文件)
    .如果真结束
    返回 (RAR_操作档案文件 (2, 待解压文件, 解压密码, 解压路径)) ' 文件数据 中保存符合条件且被成功处理的文件信息列表，如果需要可将其返回。（如转为 压缩文件信息 自定义类型返回）

.子程序 RAR_测试压缩文件, 逻辑型, 公开, 测试RAR压缩文件是否无误，如：压缩包损坏将返回假，否则返回真。
    .参数 待测试压缩文件, 文本型, , 欲解压文件的压缩档案全路径名称
    .参数 解压密码, 文本型, 可空, 欲解压文件的压缩档案密码，无密码时为空

    返回 (RAR_操作档案文件 (0, 待测试压缩文件, 解压密码))

.子程序 RAR_操作档案文件, 逻辑型, , 操作 RAR 档案文件，如获取信息、文件列表、测试文件、解压文件等，成功返回真，失败返回假。
    .参数 操作方式, 整数型, , RAR_SKIP/RAR_TEST/RAR_EXTRACT，分别用于 信息获取/测试/解压
    .参数 待解压文件, 文本型, , 欲进行的压缩档案全路径名称
    .参数 解压密码, 文本型, 可空, 可空。欲进行操作的压缩档案密码，无密码时为空
    .参数 解压路径, 文本型, 可空, 可空。留空将解压在当前目录。 指定解压文件的路径
    .局部变量 档案数据, RAROpenArchiveDataEx
    .局部变量 打开句柄, 整数型
    .局部变量 读取结果, 整数型
    .局部变量 处理结果, 整数型
    .局部变量 临时数据, RARHeaderData
    .局部变量 临时名称, 文本型, , , 该名称由于要传递指针，应单独使用不再赋值后再次修改
    .局部变量 文件有效, 逻辑型
    .局部变量 是否解压成功, 短整数型

    档案数据.ArcName ＝ 待解压文件
    档案数据.OpenMode ＝ 选择 (操作方式 ＝ 0, 2, 1)
    打开句柄 ＝ RAROpenArchiveEx (档案数据)
    .如果真 (档案数据.OpenResult ≠ 0) ' 函数执行失败
        返回 (假)
    .如果真结束
    .如果真 (是否为空 (解压密码) ＝ 假 且 解压密码 ≠ “”)
        RARSetPassword (打开句柄, 解压密码)
    .如果真结束
    .判断循环首 (真) ' 无限循环
        读取结果 ＝ RARReadHeader (打开句柄, 临时数据)
        .判断开始 (读取结果 ＝ 0) ' 成功
            临时名称 ＝ 到文本 (临时数据.FileName)
            RARSetCallback (打开句柄, &RAR_档案回调函数, 取指针地址_文本型 (临时名称)) ' 设置回调函数
            .如果 (操作方式 ＝ 0)
                文件有效 ＝ 真 ' 测试压缩包
            .否则
                文件有效 ＝ 是否匹配文件 (临时名称, “*.*”) ' 解压
            .如果结束
            处理结果 ＝ RARProcessFile (打开句柄, 选择 (文件有效, 操作方式, 0), 选择 (操作方式 ＝ 2, 解压路径, “”), “”)
            .如果 (处理结果 ＝ 0) ' 成功执行处理函数
                .如果真 (文件有效)
                    是否解压成功 ＝ 是否解压成功 ＋ 1
                .如果真结束
                
            .否则
                RARCloseArchive (打开句柄)
                返回 (假)
            .如果结束
            
        .判断 (读取结果 ＝ 10) ' 到达档案末尾
            跳出循环 ()
        .默认
            RARCloseArchive (打开句柄)
            返回 (假)
        .判断结束
        
    .判断循环尾 ()
    RARCloseArchive (打开句柄)
    返回 (是否解压成功 ＞ 0)

.子程序 RAR_档案回调函数, 整数型
    .参数 信息, 整数型
    .参数 用户数据, 整数型
    .参数 参数一, 整数型
    .参数 参数二, 整数型

    返回 (0)

.子程序 是否匹配文件, 逻辑型, , 文件名辅助处理函数,判断指定文件名是否符合过滤器
    .参数 文件名, 文本型, , 欲判断的文件名，可以包含路径
    .参数 过滤器, 文本型, , 允许，多个过滤器以 ; 间隔,支持通配符 */?
    .参数 区分大小写, 逻辑型, 可空, 是否区分大小写, 默认不区分
    .局部变量 过滤数组, 文本型, , "0"
    .局部变量 计次, 整数型
    .局部变量 字符, 文本型

    .如果真 (过滤器 ＝ “”)
        返回 (假)
    .如果真结束
    .如果真 (过滤器 ＝ “*.*”)
        返回 (真)
    .如果真结束
    文件名 ＝ PathFindFileNameA (文件名)
    .如果真 (区分大小写)
        .变量循环首 (65, 122, 1, 计次) ' A~Z,a~z
            .如果真 (计次 ≥ 91 且 计次 ≤ 96) ' [ \ ] ^ _ ` 不转换
                到循环尾 ()
            .如果真结束
            字符 ＝ 字符 (计次)
            文件名 ＝ 子文本替换 (文件名, 字符, 到全角 (字符), , , 真)
            过滤器 ＝ 子文本替换 (过滤器, 字符, 到全角 (字符), , , 真)
        .变量循环尾 ()
    .如果真结束
    过滤数组 ＝ 分割文本 (过滤器, “;”, )
    .计次循环首 (取数组成员数 (过滤数组), 计次)
        .如果真 (PathMatchSpec (文件名, 过滤数组 [计次]))
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 取指针文本_, 整数型, 公开
    .参数 参数_文本, 文本型

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' mov eax,[eax]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针整数_, 整数型, 公开
    .参数 参数_整数, 整数型, 参考

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针小数_, 整数型, 公开
    .参数 参数_小数, 小数型, 参考

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针双精度_, 整数型, 公开
    .参数 参数_双精度小数, 双精度小数型, 参考

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针字节集_, 整数型, 公开
    .参数 参数_字节集, 字节集

    置入代码 ({ 139, 69, 8, 139, 0, 5, 8, 0, 0, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+08]
    ' mov eax,[eax]
    ' add eax,08
    ' leave
    ' retn 04
    返回 (0)

.子程序 MyGetOpenFileNameA, 整数型
    .参数 参数, 整数型, , 这里获得OpenFilename这个结构的地址
    .局部变量 指针地址, 整数型

    指针地址 ＝ 取字节集数据 (指针到字节集 (参数 ＋ 28, 4), #整数型, 1) ' 结构地址偏移28的地址取整数是文件名的在内存中的地址
    写到内存 (编码_Ansi到Unicode (全_文本), 指针地址, ) ' 写入新的文件名
    返回 (1)

.子程序 系统_取宽带用户名密码, 逻辑型, 公开, 成功返回真,失败返回假  注：只有ADSL拨号上网的才能取
    .参数 连接名称, 文本型, 可空, 请提供一个文本变量,用于存放 连接名称
    .参数 宽带用户名, 文本型, 可空, 请提供一个文本变量,用于存放 宽带用户名
    .参数 宽带密码, 文本型, 可空, 请提供一个文本变量,用于存放 宽带密码
    .局部变量 局_RasArraySize, 整数型
    .局部变量 局_信息, 整数型
    .局部变量 局_RasCount, 整数型
    .局部变量 局_RasArray, 取连接信息用结构, , "0"
    .局部变量 局_图书1, 文本型
    .局部变量 局_图书2, 文本型
    .局部变量 局_osi, OSVersionInfo
    .局部变量 局_计次, 整数型
    .局部变量 局_RasParams, ADSL拨号0
    .局部变量 局_RasEntryProperties, RasEntry
    .局部变量 局_名字1, 字节集
    .局部变量 局_名字2, 字节集
    .局部变量 局_DialParamsUID, 整数型

    局_RasCount ＝ 子_GetRasEntryCount ()
    .如果真 (局_RasCount ＝ 0)
        返回 (假)
    .如果真结束
    重定义数组 (局_RasArray, 假, 局_RasCount)
    .如果真 (取数组成员数 (局_RasArray) ≥ 1)
        局_RasArray [1].内存大小 ＝ GlobalSize_取连接信息用结构 (局_RasArray [1])
        局_RasArraySize ＝ 局_RasCount × 局_RasArray [1].内存大小
    .如果真结束
    .如果真 (RasEnumEntries (0, 0, 局_RasArray, 局_RasArraySize, 局_RasCount) ≠ 0)
        返回 (假)
    .如果真结束
    ' 局_osi.版本信息大小 ＝ 148
    ' 局_osi.CSD版本 ＝ 取空白文本 (128)
    ' API_GetVersionEx (局_osi)
    ' .如果真 (局_osi.平台标识符 ＝ 2 且 局_osi.主版本 ≥ 5)
        局_图书1 ＝ 取空白文本 (255)
        局_图书2 ＝ 取空白文本 (255)
        .如果真 (SHGetSpecialFolderPath (0, 局_图书1, 26, 假))
            局_图书1 ＝ 局_图书1 ＋ “\Microsoft\Network\Connections\pbk\rasphone.pbk”
        .如果真结束
        .如果真 (SHGetSpecialFolderPath (0, 局_图书2, 35, 假))
            局_图书2 ＝ 局_图书2 ＋ “\Microsoft\Network\Connections\pbk\rasphone.pbk”
        .如果真结束
        子_GetLSAPasswords ()
    ' .如果真结束
    .计次循环首 (取数组成员数 (局_RasArray), 局_计次)
        局_RasParams.结构的大小 ＝ GlobalSize_RASDIALPARAMS (局_RasParams)
        RtlMoveMemory_字节型_数组 (局_RasParams.访问的入口名, 局_RasArray [局_计次].拨号连接名称, 255)
        RasGetEntryDialParams (“”, 局_RasParams, 真)
        局_RasArraySize ＝ GlobalSize_RASENTRY (局_RasEntryProperties)
        局_RasEntryProperties.dwSize ＝ 局_RasArraySize
        RasGetEntryProperties (“”, 局_RasArray [局_计次].拨号连接名称, 局_RasEntryProperties, 局_RasArraySize, “”, 局_信息)
        .如果真 (局_图书1 ≠ “” 或 局_图书2 ≠ “”)
            局_名字1 ＝ 到字节集 (子_字节型数组到文本 (局_RasParams.访问的入口名)) ＋ { 0 }
            局_名字2 ＝ 编码_Ansi到Utf8 (子_字节型数组到文本 (局_RasParams.访问的入口名))
            局_DialParamsUID ＝ GetPrivateProfileInt (局_名字1, “DialParamsUID”, 0, 局_图书1)
            .如果真 (局_DialParamsUID ＝ 0)
                局_DialParamsUID ＝ GetPrivateProfileInt (局_名字1, “DialParamsUID”, 0, 局_图书2)
            .如果真结束
            .如果真 (局_DialParamsUID ＝ 0)
                局_DialParamsUID ＝ GetPrivateProfileInt (局_名字2, “DialParamsUID”, 0, 局_图书1)
            .如果真结束
            .如果真 (局_DialParamsUID ＝ 0)
                局_DialParamsUID ＝ GetPrivateProfileInt (局_名字2, “DialParamsUID”, 0, 局_图书2)
            .如果真结束
            .如果真 (局_DialParamsUID ＞ 0)
                .计次循环首 (取数组成员数 (FLSAList), 局_计次)
                    .如果真 (FLSAList [局_计次].名字 ＝ 到文本 (局_DialParamsUID) 且 FLSAList [局_计次].值 ≠ “”)
                        子_文本到字节型数组 (局_RasParams.指定用户名称, FLSAList [局_计次].用户)
                        子_文本到字节型数组 (局_RasParams.指定用户密码, FLSAList [局_计次].值)
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            
        .如果真结束
        连接名称 ＝ 子_字节型数组到文本 (局_RasParams.访问的入口名)
        宽带用户名 ＝ 子_字节型数组到文本 (局_RasParams.指定用户名称)
        宽带密码 ＝ 子_字节型数组到文本 (局_RasParams.指定用户密码)
    .计次循环尾 ()
    返回 (删首尾空 (宽带用户名) ≠ “”)

.子程序 取_类_函数地址, 整数型
    .参数 this
    .参数 index, , , 从1开始,[_初始化][_销毁],[xx]
    .局部变量 函数数组

    index ＝ index － 1
    函数数组 ＝ 取指针内容_整数 (this)
    返回 (取指针内容_整数 (函数数组 ＋ index × 4))

.子程序 到数值_从子程序指针, 整数型
    .参数 proc, 子程序指针
    .局部变量 ret, 整数型

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (ret)

.子程序 到子程序指针_从数值, 子程序指针
    .参数 val, 整数型
    .局部变量 ret, 子程序指针

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (ret)

.子程序 取上层函数首参, 整数型
    .局部变量 ret

    置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 137, 69, 252 })
    ' 置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 137, 69, 252 })
    返回 (ret)

.子程序 get_retn_code, 整数型
    .局部变量 static_ptr, , 静态
    .局部变量 data, 字节集

    .如果真 (static_ptr ≠ 0)
        返回 (static_ptr)
    .如果真结束
    ' mov     edx, dword ptr [ebp-4]
    ' mov     ebx, dword ptr [ebp-8]
    ' mov     esi, dword ptr [ebp-C]
    ' mov     edi, dword ptr [ebp-10]
    ' fldcw   word ptr [ebp-14]
    ' mov     esp, ebp
    ' pop     ebp
    ' pop     ecx
    ' add     esp, edx
    ' jmp     ecx
    data ＝ { 139, 77, 252, 139, 93, 248, 139, 117, 244, 139, 125, 240, 217, 109, 236, 139, 229, 93, 141, 100, 12, 4, 247, 217, 139, 76, 12, 252, 255, 225 }
    static_ptr ＝ DumpCode (data)
    返回 (static_ptr)

.子程序 辅_生成_方法回调, 整数型, , [不需要fcw复位]
    .参数 回调地址
    .参数 参数个数, , 可空
    .参数 push_ecx, 逻辑型, 可空, 当有[附加参数1]附加到第二个参数，当没有[附加参数1]时附加到第一个参数;默认为假
    .参数 cdecl方式, 逻辑型, 可空, 默认为假
    .参数 附加参数1, , 可空, 附加到第一个的参数.不为0则附加
    .局部变量 data, 字节集

    .局部变量 arg_length
    .局部变量 ret_len_WORD, 短整数型

    .如果真 (回调地址 ＝ 0)
        输出调试文本 (“[辅_生成_方法回调][失败]：回调地址错误”)
        返回 (0)
    .如果真结束
    .如果 (cdecl方式)
        ret_len_WORD ＝ 0
    .否则
        ret_len_WORD ＝ 参数个数 × 4
    .如果结束
    arg_length ＝ 参数个数 × 4
    .如果真 (arg_length ＞ 512 或 arg_length ＜ 0)
        输出调试文本 (“[辅_生成_方法回调]局部变量长度错误”)
        返回 (0)
    .如果真结束
    data ＝ { }
    data ＝ data ＋ { 85 } ' push ebp;
    data ＝ data ＋ { 139, 236 } ' mov ebp,esp;
    data ＝ data ＋ { 106 } ＋ 到字节集_从字节 (ret_len_WORD) ' push [retn_size]; // [ebp-04]
    data ＝ data ＋ { 83 } ' push ebx; // [ebp-08]
    data ＝ data ＋ { 86 } ' push esi; // [ebp-0C]
    data ＝ data ＋ { 87 } ' push edi; // [ebp-10]
    data ＝ data ＋ { 106 } ＋ { 0 } ' push 0; // [ebp-14]
    data ＝ data ＋ { 217, 60, 36 } ' fstcw [esp];
    data ＝ data ＋ { 219, 227 } ' finit;
    ' ////////////////////////////////////////////////////////////////////////////
    .如果真 (参数个数 ≠ 0)
        data ＝ data ＋ { 185 } ＋ 到字节集_从整数_ (arg_length) ' mov ecx,arg_length;
        data ＝ data ＋ { 43, 225 } ' sub esp,ecx;
        data ＝ data ＋ { 141, 117, 8 } ' lea esi,[ebp+8];
        data ＝ data ＋ { 141, 60, 36 } ' lea edi,[esp];
        data ＝ data ＋ { 252 } ' cld;
        data ＝ data ＋ { 243, 164 } ' rep movsb;
        data ＝ data ＋ { 139, 77, 248 } ' mov ecx,[ebp-8];
        data ＝ data ＋ { 139, 117, 244 } ' mov esi.[ebp-C];
        data ＝ data ＋ { 139, 125, 240 } ' mov edi,[ebp-10];
    .如果真结束
    .如果真 (push_ecx)
        data ＝ data ＋ { 81 } ' push ecx;
    .如果真结束
    .如果真 (附加参数1 ≠ 0)
        data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (附加参数1) ' push arg_1
    .如果真结束
    data ＝ data ＋ { 184 } ＋ 到字节集_从整数_ (回调地址) ' mov eax,addr;
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (get_retn_code ()) ' push arg_1; //retn to static code
    data ＝ data ＋ { 255, 224 } ' jmp eax
    返回 (DumpCode (data))

.子程序 类回调_取类地址, 整数型, 公开, [只能在类里调用]
    .参数 函数序号, , , 从1开始,[_初始化][_销毁],[xx]
    .参数 参数个数, , 可空
    .参数 push_ecx, 逻辑型, 可空, 附加到第一个参数;默认为假
    .参数 cdecl方式, 逻辑型, 可空, 默认为假
    .局部变量 this

    .局部变量 回调地址
    .局部变量 data, 字节集

    .局部变量 arg_length
    .局部变量 sizeof_int
    .局部变量 ret_len_WORD, 短整数型

    this ＝ 取指针内容_整数 (取上层函数首参 ())
    回调地址 ＝ 取_类_函数地址 (this, 函数序号)
    
    .如果真 (回调地址 ≤ 0)
        输出调试文本 (“[辅_生成_类回调_易][失败]：回调地址错误”)
        返回 (0)
    .如果真结束
    sizeof_int ＝ 4 ' #sizeof_int
    .如果 (cdecl方式)
        ret_len_WORD ＝ 0
    .否则
        ret_len_WORD ＝ 参数个数 × sizeof_int
    .如果结束
    arg_length ＝ 参数个数 × sizeof_int
    .如果真 (arg_length ＞ 512 或 arg_length ＜ 0)
        输出调试文本 (“[辅_生成_类回调_易]局部变量长度错误”)
        返回 (0)
    .如果真结束
    data ＝ { }
    data ＝ data ＋ { 85 } ' push ebp;
    data ＝ data ＋ { 139, 236 } ' mov ebp,esp;
    data ＝ data ＋ { 106 } ＋ 到字节集_从字节 (ret_len_WORD) ' push [retn_size]; // [ebp-04]
    data ＝ data ＋ { 83 } ' push ebx; // [ebp-8]
    data ＝ data ＋ { 86 } ' push esi; // [ebp-0C]
    data ＝ data ＋ { 87 } ' push edi; // [ebp-10]
    data ＝ data ＋ { 106 } ＋ { 0 } ' push 0; // [ebp-14]
    data ＝ data ＋ { 217, 60, 36 } ' fstcw [esp];
    data ＝ data ＋ { 219, 227 } ' finit;
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (this) ' push dwThis;
    data ＝ data ＋ { 139, 196 } ' mov eax,esp
    .如果真 (参数个数 ≠ 0)
        data ＝ data ＋ { 185 } ＋ 到字节集_从整数_ (arg_length) ' mov ecx,arg_length;
        data ＝ data ＋ { 43, 225 } ' sub esp,ecx;
        data ＝ data ＋ { 141, 117, 8 } ' lea esi,[ebp+8];
        data ＝ data ＋ { 141, 60, 36 } ' lea edi,[esp];
        data ＝ data ＋ { 252 } ' cld;
        data ＝ data ＋ { 243, 164 } ' rep movsb;
        data ＝ data ＋ { 139, 77, 248 } ' mov ecx,[ebp-8];
        data ＝ data ＋ { 139, 117, 244 } ' mov esi.[ebp-C];
        data ＝ data ＋ { 139, 125, 240 } ' mov edi,[ebp-10];
    .如果真结束
    .如果真 (push_ecx)
        data ＝ data ＋ { 81 } ' push ecx;
    .如果真结束
    data ＝ data ＋ { 80 } ' push eax;  // push &(this)
    data ＝ data ＋ { 184 } ＋ 到字节集_从整数_ (回调地址) ' mov eax,addr;
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (get_retn_code ()) ' push arg_1; //retn to static code
    data ＝ data ＋ { 255, 224 } ' jmp eax
    返回 (DumpCode (data))
    

.子程序 类回调_释放回调, , 公开, 用于释放生成代码后的返回指针，若你确定你的回调已经停用了才能释放
    .参数 ptr

    VirtualFreeEx (GetCurrentProcess (), ptr, 0, 32768)

.子程序 DumpCode, 整数型
    .参数 data, 字节集
    .局部变量 hMem
    .局部变量 Ptr
    .局部变量 len

    len ＝ 取字节集长度 (data)
    hMem ＝ VirtualAlloc (0, len, 4096, 64)
    CopyMemory_Bytes2int (hMem, data, len)
    返回 (hMem)

.子程序 取指针内容_整数, 整数型
    .参数 内存地址
    .局部变量 ret

    置入代码 ({ 139, 69, 8, 139, 0, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov eax,[eax] | mov [ebp-4],eax”)
    返回 (ret)

.子程序 到字节集_从整数_, 字节集
    .参数 欲转换的数值, 整数型, 参考
    .局部变量 ptr

    ptr ＝ 取变量地址_整数 (欲转换的数值)
    返回 (指针到字节集 (ptr, 4))

.子程序 到字节集_从短整数_, 字节集
    .参数 欲转换的数值, 短整数型, 参考
    .局部变量 ptr

    ptr ＝ 取变量地址_短整数 (欲转换的数值)
    返回 (指针到字节集 (ptr, 2))

.子程序 到字节集_从字节, 字节集
    .参数 欲转换的数值, 短整数型, 参考
    .局部变量 ptr

    ptr ＝ 取变量地址_短整数 (欲转换的数值)
    返回 (指针到字节集 (ptr, 1))

.子程序 取变量地址_字节, 整数型
    .参数 变量, 字节型, 参考
    .局部变量 reuslt

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (reuslt)

.子程序 取变量堆栈地址_字节集, 整数型, 公开
    .参数 字节集变量, 字节集

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 取变量地址_整数, 整数型
    .参数 var, 整数型, 参考
    .局部变量 ptr

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (ptr)

.子程序 取变量地址_短整数, 整数型
    .参数 变量, 短整数型, 参考
    .局部变量 reuslt

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (reuslt)

.子程序 辅_取字节集长度, 整数型
    .参数 v, 字节集
    .局部变量 len

    .如果真 (v ＝ { })
        返回 (0)
    .如果真结束
    置入代码 ({ 139, 69, 8, 139, 0, 139, 64, 4, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov eax,[eax] | mov eax,[eax+4] | mov [ebp-4],eax ”)
    返回 (len)

.子程序 托盘消息回调, 整数型
    .参数 hwnd
    .参数 uMsg
    .参数 wParam
    .参数 lParam
    .局部变量 pointer
    .局部变量 Message
    .局部变量 TaskbarCreated
    .局部变量 Event

    pointer ＝ GetPropA (hwnd, “WinProc”)
    Message ＝ GetPropA (hwnd, “CallbackMessage”)
    TaskbarCreated ＝ GetPropA (hwnd, “TaskbarCreatedMessage”)
    Event ＝ GetPropA (hwnd, “Exec Event”)
    .判断开始 (uMsg ＝ Message)
        .如果真 (Event ≠ 0)
            程序_Call (Event, lParam)
            返回 (0)
        .如果真结束
        
    .判断 (uMsg ＝ TaskbarCreated)
        .如果真 (Event ≠ 0)
            程序_Call (Event, 1120)
            返回 (0)
        .如果真结束
        
    .判断 (uMsg ＝ 2)
        .如果真 (Event ≠ 0)
            程序_Call (Event, 1130)
        .如果真结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcA (pointer, hwnd, uMsg, wParam, lParam))
    

.子程序 逻辑左移, 整数型, , （逻辑左移） （算术左移） 
    .参数 欲移动的整数, 整数型
    .参数 欲被移动的位数, 字节型

    置入代码 ({ 81, 139, 69, 8, 138, 77, 12, 211, 224, 89, 139, 229, 93, 194, 8, 0 })
    返回 (-1)

.子程序 逻辑右移, 整数型, , （逻辑右移） （算术右移） 寄存器，1
    .参数 欲移动的整数, 整数型
    .参数 欲被移动的位数, 字节型

    置入代码 ({ 81, 139, 69, 8, 138, 77, 12, 211, 232, 89, 139, 229, 93, 194, 8, 0 })
    返回 (-1)
    

.子程序 地址_取API地址, 整数型, 公开, 返回API地址
    .参数 动态链接库名, 文本型
    .参数 函数名, 文本型
    .局部变量 模块句柄, 整数型
    .局部变量 是否加载模块, 逻辑型
    .局部变量 返回值, 整数型

    模块句柄 ＝ GetModuleHandleA (动态链接库名) ' 获取动态库句柄(如果已被加载)
    .如果真 (模块句柄 ＝ 0)
        是否加载模块 ＝ 真
        模块句柄 ＝ LoadLibraryA (动态链接库名) ' 加载动态库并获取句柄
    .如果真结束
    .如果真 (模块句柄 ＝ 0)
        返回 (0)
    .如果真结束
    返回值 ＝ GetProcAddress (模块句柄, 函数名)
    .如果真 (是否加载模块 ＝ 真)
        FreeLibrary (模块句柄)
    .如果真结束
    返回 (返回值)

.子程序 调用子程序_数组, 整数型, 公开
    .参数 调用地址, 整数型
    .参数 参数数组, 整数型, 可空 数组
    .参数 是否为C调用, 逻辑型, 可空

    .如果真 (IsBadCodePtr (调用地址))
        返回 (0)
    .如果真结束
    置入代码 ({ 131, 236, 8, 86, 62, 139, 117, 12, 139, 54, 139, 118, 4, 141, 78, 255, 133, 201, 124, 18, 139, 69, 12, 139, 0, 141, 68, 136, 8, 65, 255, 48, 131, 232, 4, 73, 117, 248, 255, 85, 8, 137, 69, 252, 139, 69, 20, 133, 192, 116, 10, 62, 141, 4, 181, 0, 0, 0, 0, 3, 224, 139, 69, 252, 94, 139, 229, 93, 194, 20, 0 })
    返回 (0)

